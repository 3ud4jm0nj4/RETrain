GLOBAL CONST $BS_GROUPBOX = 7
GLOBAL CONST $BS_BOTTOM = 2048
GLOBAL CONST $BS_CENTER = 768
GLOBAL CONST $BS_DEFPUSHBUTTON = 1
GLOBAL CONST $BS_LEFT = 256
GLOBAL CONST $BS_MULTILINE = 8192
GLOBAL CONST $BS_PUSHBOX = 10
GLOBAL CONST $BS_PUSHLIKE = 4096
GLOBAL CONST $BS_RIGHT = 512
GLOBAL CONST $BS_RIGHTBUTTON = 32
GLOBAL CONST $BS_TOP = 1024
GLOBAL CONST $BS_VCENTER = 3072
GLOBAL CONST $BS_FLAT = 32768
GLOBAL CONST $BS_ICON = 64
GLOBAL CONST $BS_BITMAP = 128
GLOBAL CONST $BS_NOTIFY = 16384
GLOBAL CONST $BS_SPLITBUTTON = 12
GLOBAL CONST $BS_DEFSPLITBUTTON = 13
GLOBAL CONST $BS_COMMANDLINK = 14
GLOBAL CONST $BS_DEFCOMMANDLINK = 15
GLOBAL CONST $BCSIF_GLYPH = 1
GLOBAL CONST $BCSIF_IMAGE = 2
GLOBAL CONST $BCSIF_STYLE = 4
GLOBAL CONST $BCSIF_SIZE = 8
GLOBAL CONST $BCSS_NOSPLIT = 1
GLOBAL CONST $BCSS_STRETCH = 2
GLOBAL CONST $BCSS_ALIGNLEFT = 4
GLOBAL CONST $BCSS_IMAGE = 8
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_LEFT = 0
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_RIGHT = 1
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_TOP = 2
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_BOTTOM = 3
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_CENTER = 4
GLOBAL CONST $BS_3STATE = 5
GLOBAL CONST $BS_AUTO3STATE = 6
GLOBAL CONST $BS_AUTOCHECKBOX = 3
GLOBAL CONST $BS_CHECKBOX = 2
GLOBAL CONST $BS_RADIOBUTTON = 4
GLOBAL CONST $BS_AUTORADIOBUTTON = 9
GLOBAL CONST $BS_OWNERDRAW = 11
GLOBAL CONST $GUI_SS_DEFAULT_BUTTON = 0
GLOBAL CONST $GUI_SS_DEFAULT_CHECKBOX = 0
GLOBAL CONST $GUI_SS_DEFAULT_GROUP = 0
GLOBAL CONST $GUI_SS_DEFAULT_RADIO = 0
GLOBAL CONST $BCM_FIRST = 5632
GLOBAL CONST $BCM_GETIDEALSIZE = ($BCM_FIRST + 1)
GLOBAL CONST $BCM_GETIMAGELIST = ($BCM_FIRST + 3)
GLOBAL CONST $BCM_GETNOTE = ($BCM_FIRST + 10)
GLOBAL CONST $BCM_GETNOTELENGTH = ($BCM_FIRST + 11)
GLOBAL CONST $BCM_GETSPLITINFO = ($BCM_FIRST + 8)
GLOBAL CONST $BCM_GETTEXTMARGIN = ($BCM_FIRST + 5)
GLOBAL CONST $BCM_SETDROPDOWNSTATE = ($BCM_FIRST + 6)
GLOBAL CONST $BCM_SETIMAGELIST = ($BCM_FIRST + 2)
GLOBAL CONST $BCM_SETNOTE = ($BCM_FIRST + 9)
GLOBAL CONST $BCM_SETSHIELD = ($BCM_FIRST + 12)
GLOBAL CONST $BCM_SETSPLITINFO = ($BCM_FIRST + 7)
GLOBAL CONST $BCM_SETTEXTMARGIN = ($BCM_FIRST + 4)
GLOBAL CONST $BM_CLICK = 245
GLOBAL CONST $BM_GETCHECK = 240
GLOBAL CONST $BM_GETIMAGE = 246
GLOBAL CONST $BM_GETSTATE = 242
GLOBAL CONST $BM_SETCHECK = 241
GLOBAL CONST $BM_SETDONTCLICK = 248
GLOBAL CONST $BM_SETIMAGE = 247
GLOBAL CONST $BM_SETSTATE = 243
GLOBAL CONST $BM_SETSTYLE = 244
GLOBAL CONST $BCN_FIRST = -1250
GLOBAL CONST $BCN_DROPDOWN = ($BCN_FIRST + 2)
GLOBAL CONST $BCN_HOTITEMCHANGE = ($BCN_FIRST + 1)
GLOBAL CONST $BN_CLICKED = 0
GLOBAL CONST $BN_PAINT = 1
GLOBAL CONST $BN_HILITE = 2
GLOBAL CONST $BN_UNHILITE = 3
GLOBAL CONST $BN_DISABLE = 4
GLOBAL CONST $BN_DOUBLECLICKED = 5
GLOBAL CONST $BN_SETFOCUS = 6
GLOBAL CONST $BN_KILLFOCUS = 7
GLOBAL CONST $BN_PUSHED = $BN_HILITE
GLOBAL CONST $BN_UNPUSHED = $BN_UNHILITE
GLOBAL CONST $BN_DBLCLK = $BN_DOUBLECLICKED
GLOBAL CONST $BST_CHECKED = 1
GLOBAL CONST $BST_INDETERMINATE = 2
GLOBAL CONST $BST_UNCHECKED = 0
GLOBAL CONST $BST_FOCUS = 8
GLOBAL CONST $BST_PUSHED = 4
GLOBAL CONST $BST_DONTCLICK = 128
GLOBAL CONST $ES_LEFT = 0
GLOBAL CONST $ES_CENTER = 1
GLOBAL CONST $ES_RIGHT = 2
GLOBAL CONST $ES_MULTILINE = 4
GLOBAL CONST $ES_UPPERCASE = 8
GLOBAL CONST $ES_LOWERCASE = 16
GLOBAL CONST $ES_PASSWORD = 32
GLOBAL CONST $ES_AUTOVSCROLL = 64
GLOBAL CONST $ES_AUTOHSCROLL = 128
GLOBAL CONST $ES_NOHIDESEL = 256
GLOBAL CONST $ES_OEMCONVERT = 1024
GLOBAL CONST $ES_READONLY = 2048
GLOBAL CONST $ES_WANTRETURN = 4096
GLOBAL CONST $ES_NUMBER = 8192
GLOBAL CONST $EC_ERR = -1
GLOBAL CONST $ECM_FIRST = 5376
GLOBAL CONST $EM_CANUNDO = 198
GLOBAL CONST $EM_CHARFROMPOS = 215
GLOBAL CONST $EM_EMPTYUNDOBUFFER = 205
GLOBAL CONST $EM_FMTLINES = 200
GLOBAL CONST $EM_GETCUEBANNER = ($ECM_FIRST + 2)
GLOBAL CONST $EM_GETFIRSTVISIBLELINE = 206
GLOBAL CONST $EM_GETHANDLE = 189
GLOBAL CONST $EM_GETIMESTATUS = 217
GLOBAL CONST $EM_GETLIMITTEXT = 213
GLOBAL CONST $EM_GETLINE = 196
GLOBAL CONST $EM_GETLINECOUNT = 186
GLOBAL CONST $EM_GETMARGINS = 212
GLOBAL CONST $EM_GETMODIFY = 184
GLOBAL CONST $EM_GETPASSWORDCHAR = 210
GLOBAL CONST $EM_GETRECT = 178
GLOBAL CONST $EM_GETSEL = 176
GLOBAL CONST $EM_GETTHUMB = 190
GLOBAL CONST $EM_GETWORDBREAKPROC = 209
GLOBAL CONST $EM_HIDEBALLOONTIP = ($ECM_FIRST + 4)
GLOBAL CONST $EM_LIMITTEXT = 197
GLOBAL CONST $EM_LINEFROMCHAR = 201
GLOBAL CONST $EM_LINEINDEX = 187
GLOBAL CONST $EM_LINELENGTH = 193
GLOBAL CONST $EM_LINESCROLL = 182
GLOBAL CONST $EM_POSFROMCHAR = 214
GLOBAL CONST $EM_REPLACESEL = 194
GLOBAL CONST $EM_SCROLL = 181
GLOBAL CONST $EM_SCROLLCARET = 183
GLOBAL CONST $EM_SETCUEBANNER = ($ECM_FIRST + 1)
GLOBAL CONST $EM_SETHANDLE = 188
GLOBAL CONST $EM_SETIMESTATUS = 216
GLOBAL CONST $EM_SETLIMITTEXT = $EM_LIMITTEXT
GLOBAL CONST $EM_SETMARGINS = 211
GLOBAL CONST $EM_SETMODIFY = 185
GLOBAL CONST $EM_SETPASSWORDCHAR = 204
GLOBAL CONST $EM_SETREADONLY = 207
GLOBAL CONST $EM_SETRECT = 179
GLOBAL CONST $EM_SETRECTNP = 180
GLOBAL CONST $EM_SETSEL = 177
GLOBAL CONST $EM_SETTABSTOPS = 203
GLOBAL CONST $EM_SETWORDBREAKPROC = 208
GLOBAL CONST $EM_SHOWBALLOONTIP = ($ECM_FIRST + 3)
GLOBAL CONST $EM_UNDO = 199
GLOBAL CONST $EC_LEFTMARGIN = 1
GLOBAL CONST $EC_RIGHTMARGIN = 2
GLOBAL CONST $EC_USEFONTINFO = 65535
GLOBAL CONST $EMSIS_COMPOSITIONSTRING = 1
GLOBAL CONST $EIMES_GETCOMPSTRATONCE = 1
GLOBAL CONST $EIMES_CANCELCOMPSTRINFOCUS = 2
GLOBAL CONST $EIMES_COMPLETECOMPSTRKILLFOCUS = 4
GLOBAL CONST $EN_ALIGN_LTR_EC = 1792
GLOBAL CONST $EN_ALIGN_RTL_EC = 1793
GLOBAL CONST $EN_CHANGE = 768
GLOBAL CONST $EN_ERRSPACE = 1280
GLOBAL CONST $EN_HSCROLL = 1537
GLOBAL CONST $EN_KILLFOCUS = 512
GLOBAL CONST $EN_MAXTEXT = 1281
GLOBAL CONST $EN_SETFOCUS = 256
GLOBAL CONST $EN_UPDATE = 1024
GLOBAL CONST $EN_VSCROLL = 1538
GLOBAL CONST $GUI_SS_DEFAULT_EDIT = 3150016
GLOBAL CONST $GUI_SS_DEFAULT_INPUT = 128
GLOBAL CONST $GUI_EVENT_SINGLE = 0
GLOBAL CONST $GUI_EVENT_ARRAY = 1
GLOBAL CONST $GUI_EVENT_NONE = 0
GLOBAL CONST $GUI_EVENT_CLOSE = -3
GLOBAL CONST $GUI_EVENT_MINIMIZE = -4
GLOBAL CONST $GUI_EVENT_RESTORE = -5
GLOBAL CONST $GUI_EVENT_MAXIMIZE = -6
GLOBAL CONST $GUI_EVENT_PRIMARYDOWN = -7
GLOBAL CONST $GUI_EVENT_PRIMARYUP = -8
GLOBAL CONST $GUI_EVENT_SECONDARYDOWN = -9
GLOBAL CONST $GUI_EVENT_SECONDARYUP = -10
GLOBAL CONST $GUI_EVENT_MOUSEMOVE = -11
GLOBAL CONST $GUI_EVENT_RESIZED = -12
GLOBAL CONST $GUI_EVENT_DROPPED = -13
GLOBAL CONST $GUI_RUNDEFMSG = "GUI_RUNDEFMSG"
GLOBAL CONST $GUI_AVISTOP = 0
GLOBAL CONST $GUI_AVISTART = 1
GLOBAL CONST $GUI_AVICLOSE = 2
GLOBAL CONST $GUI_CHECKED = 1
GLOBAL CONST $GUI_INDETERMINATE = 2
GLOBAL CONST $GUI_UNCHECKED = 4
GLOBAL CONST $GUI_DROPACCEPTED = 8
GLOBAL CONST $GUI_NODROPACCEPTED = 4096
GLOBAL CONST $GUI_ACCEPTFILES = $GUI_DROPACCEPTED
GLOBAL CONST $GUI_SHOW = 16
GLOBAL CONST $GUI_HIDE = 32
GLOBAL CONST $GUI_ENABLE = 64
GLOBAL CONST $GUI_DISABLE = 128
GLOBAL CONST $GUI_FOCUS = 256
GLOBAL CONST $GUI_NOFOCUS = 8192
GLOBAL CONST $GUI_DEFBUTTON = 512
GLOBAL CONST $GUI_EXPAND = 1024
GLOBAL CONST $GUI_ONTOP = 2048
GLOBAL CONST $GUI_FONTNORMAL = 0
GLOBAL CONST $GUI_FONTITALIC = 2
GLOBAL CONST $GUI_FONTUNDER = 4
GLOBAL CONST $GUI_FONTSTRIKE = 8
GLOBAL CONST $GUI_DOCKAUTO = 1
GLOBAL CONST $GUI_DOCKLEFT = 2
GLOBAL CONST $GUI_DOCKRIGHT = 4
GLOBAL CONST $GUI_DOCKHCENTER = 8
GLOBAL CONST $GUI_DOCKTOP = 32
GLOBAL CONST $GUI_DOCKBOTTOM = 64
GLOBAL CONST $GUI_DOCKVCENTER = 128
GLOBAL CONST $GUI_DOCKWIDTH = 256
GLOBAL CONST $GUI_DOCKHEIGHT = 512
GLOBAL CONST $GUI_DOCKSIZE = 768
GLOBAL CONST $GUI_DOCKMENUBAR = 544
GLOBAL CONST $GUI_DOCKSTATEBAR = 576
GLOBAL CONST $GUI_DOCKALL = 802
GLOBAL CONST $GUI_DOCKBORDERS = 102
GLOBAL CONST $GUI_GR_CLOSE = 1
GLOBAL CONST $GUI_GR_LINE = 2
GLOBAL CONST $GUI_GR_BEZIER = 4
GLOBAL CONST $GUI_GR_MOVE = 6
GLOBAL CONST $GUI_GR_COLOR = 8
GLOBAL CONST $GUI_GR_RECT = 10
GLOBAL CONST $GUI_GR_ELLIPSE = 12
GLOBAL CONST $GUI_GR_PIE = 14
GLOBAL CONST $GUI_GR_DOT = 16
GLOBAL CONST $GUI_GR_PIXEL = 18
GLOBAL CONST $GUI_GR_HINT = 20
GLOBAL CONST $GUI_GR_REFRESH = 22
GLOBAL CONST $GUI_GR_PENSIZE = 24
GLOBAL CONST $GUI_GR_NOBKCOLOR = -2
GLOBAL CONST $GUI_BKCOLOR_DEFAULT = -1
GLOBAL CONST $GUI_BKCOLOR_TRANSPARENT = -2
GLOBAL CONST $GUI_BKCOLOR_LV_ALTERNATE = -33554432
GLOBAL CONST $GUI_READ_DEFAULT = 0
GLOBAL CONST $GUI_READ_EXTENDED = 1
GLOBAL CONST $GUI_CURSOR_NOOVERRIDE = 0
GLOBAL CONST $GUI_CURSOR_OVERRIDE = 1
GLOBAL CONST $GUI_WS_EX_PARENTDRAG = 1048576
GLOBAL CONST $SS_LEFT = 0
GLOBAL CONST $SS_CENTER = 1
GLOBAL CONST $SS_RIGHT = 2
GLOBAL CONST $SS_ICON = 3
GLOBAL CONST $SS_BLACKRECT = 4
GLOBAL CONST $SS_GRAYRECT = 5
GLOBAL CONST $SS_WHITERECT = 6
GLOBAL CONST $SS_BLACKFRAME = 7
GLOBAL CONST $SS_GRAYFRAME = 8
GLOBAL CONST $SS_WHITEFRAME = 9
GLOBAL CONST $SS_SIMPLE = 11
GLOBAL CONST $SS_LEFTNOWORDWRAP = 12
GLOBAL CONST $SS_BITMAP = 14
GLOBAL CONST $SS_ENHMETAFILE = 15
GLOBAL CONST $SS_ETCHEDHORZ = 16
GLOBAL CONST $SS_ETCHEDVERT = 17
GLOBAL CONST $SS_ETCHEDFRAME = 18
GLOBAL CONST $SS_REALSIZECONTROL = 64
GLOBAL CONST $SS_NOPREFIX = 128
GLOBAL CONST $SS_NOTIFY = 256
GLOBAL CONST $SS_CENTERIMAGE = 512
GLOBAL CONST $SS_RIGHTJUST = 1024
GLOBAL CONST $SS_SUNKEN = 4096
GLOBAL CONST $GUI_SS_DEFAULT_LABEL = 0
GLOBAL CONST $GUI_SS_DEFAULT_GRAPHIC = 0
GLOBAL CONST $GUI_SS_DEFAULT_ICON = $SS_NOTIFY
GLOBAL CONST $GUI_SS_DEFAULT_PIC = $SS_NOTIFY
GLOBAL CONST $STM_SETICON = 368
GLOBAL CONST $STM_GETICON = 369
GLOBAL CONST $STM_SETIMAGE = 370
GLOBAL CONST $STM_GETIMAGE = 371
GLOBAL CONST $WC_ANIMATE = "SysAnimate32"
GLOBAL CONST $WC_BUTTON = "Button"
GLOBAL CONST $WC_COMBOBOX = "ComboBox"
GLOBAL CONST $WC_COMBOBOXEX = "ComboBoxEx32"
GLOBAL CONST $WC_DATETIMEPICK = "SysDateTimePick32"
GLOBAL CONST $WC_EDIT = "Edit"
GLOBAL CONST $WC_HEADER = "SysHeader32"
GLOBAL CONST $WC_HOTKEY = "msctls_hotkey32"
GLOBAL CONST $WC_IPADDRESS = "SysIPAddress32"
GLOBAL CONST $WC_LINK = "SysLink"
GLOBAL CONST $WC_LISTBOX = "ListBox"
GLOBAL CONST $WC_LISTVIEW = "SysListView32"
GLOBAL CONST $WC_MONTHCAL = "SysMonthCal32"
GLOBAL CONST $WC_NATIVEFONTCTL = "NativeFontCtl"
GLOBAL CONST $WC_PAGESCROLLER = "SysPager"
GLOBAL CONST $WC_PROGRESS = "msctls_progress32"
GLOBAL CONST $WC_REBAR = "ReBarWindow32"
GLOBAL CONST $WC_SCROLLBAR = "ScrollBar"
GLOBAL CONST $WC_STATIC = "Static"
GLOBAL CONST $WC_STATUSBAR = "msctls_statusbar32"
GLOBAL CONST $WC_TABCONTROL = "SysTabControl32"
GLOBAL CONST $WC_TOOLBAR = "ToolbarWindow32"
GLOBAL CONST $WC_TOOLTIPS = "tooltips_class32"
GLOBAL CONST $WC_TRACKBAR = "msctls_trackbar32"
GLOBAL CONST $WC_TREEVIEW = "SysTreeView32"
GLOBAL CONST $WC_UPDOWN = "msctls_updown32"
GLOBAL CONST $WS_OVERLAPPED = 0
GLOBAL CONST $WS_TILED = $WS_OVERLAPPED
GLOBAL CONST $WS_MAXIMIZEBOX = 65536
GLOBAL CONST $WS_MINIMIZEBOX = 131072
GLOBAL CONST $WS_TABSTOP = 65536
GLOBAL CONST $WS_GROUP = 131072
GLOBAL CONST $WS_SIZEBOX = 262144
GLOBAL CONST $WS_THICKFRAME = $WS_SIZEBOX
GLOBAL CONST $WS_SYSMENU = 524288
GLOBAL CONST $WS_HSCROLL = 1048576
GLOBAL CONST $WS_VSCROLL = 2097152
GLOBAL CONST $WS_DLGFRAME = 4194304
GLOBAL CONST $WS_BORDER = 8388608
GLOBAL CONST $WS_CAPTION = 12582912
GLOBAL CONST $WS_OVERLAPPEDWINDOW = BITOR($WS_CAPTION, $WS_MAXIMIZEBOX, $WS_MINIMIZEBOX, $WS_OVERLAPPED, $WS_SYSMENU, $WS_THICKFRAME)
GLOBAL CONST $WS_TILEDWINDOW = $WS_OVERLAPPEDWINDOW
GLOBAL CONST $WS_MAXIMIZE = 16777216
GLOBAL CONST $WS_CLIPCHILDREN = 33554432
GLOBAL CONST $WS_CLIPSIBLINGS = 67108864
GLOBAL CONST $WS_DISABLED = 134217728
GLOBAL CONST $WS_VISIBLE = 268435456
GLOBAL CONST $WS_MINIMIZE = 536870912
GLOBAL CONST $WS_ICONIC = $WS_MINIMIZE
GLOBAL CONST $WS_CHILD = 1073741824
GLOBAL CONST $WS_CHILDWINDOW = $WS_CHILD
GLOBAL CONST $WS_POPUP = -2147483648
GLOBAL CONST $WS_POPUPWINDOW = -2138570752
GLOBAL CONST $DS_3DLOOK = 4
GLOBAL CONST $DS_ABSALIGN = 1
GLOBAL CONST $DS_CENTER = 2048
GLOBAL CONST $DS_CENTERMOUSE = 4096
GLOBAL CONST $DS_CONTEXTHELP = 8192
GLOBAL CONST $DS_CONTROL = 1024
GLOBAL CONST $DS_FIXEDSYS = 8
GLOBAL CONST $DS_LOCALEDIT = 32
GLOBAL CONST $DS_MODALFRAME = 128
GLOBAL CONST $DS_NOFAILCREATE = 16
GLOBAL CONST $DS_NOIDLEMSG = 256
GLOBAL CONST $DS_SETFONT = 64
GLOBAL CONST $DS_SETFOREGROUND = 512
GLOBAL CONST $DS_SHELLFONT = BITOR($DS_FIXEDSYS, $DS_SETFONT)
GLOBAL CONST $DS_SYSMODAL = 2
GLOBAL CONST $WS_EX_ACCEPTFILES = 16
GLOBAL CONST $WS_EX_APPWINDOW = 262144
GLOBAL CONST $WS_EX_COMPOSITED = 33554432
GLOBAL CONST $WS_EX_CONTROLPARENT = 65536
GLOBAL CONST $WS_EX_CLIENTEDGE = 512
GLOBAL CONST $WS_EX_CONTEXTHELP = 1024
GLOBAL CONST $WS_EX_DLGMODALFRAME = 1
GLOBAL CONST $WS_EX_LAYERED = 524288
GLOBAL CONST $WS_EX_LAYOUTRTL = 4194304
GLOBAL CONST $WS_EX_LEFT = 0
GLOBAL CONST $WS_EX_LEFTSCROLLBAR = 16384
GLOBAL CONST $WS_EX_LTRREADING = 0
GLOBAL CONST $WS_EX_MDICHILD = 64
GLOBAL CONST $WS_EX_NOACTIVATE = 134217728
GLOBAL CONST $WS_EX_NOINHERITLAYOUT = 1048576
GLOBAL CONST $WS_EX_NOPARENTNOTIFY = 4
GLOBAL CONST $WS_EX_NOREDIRECTIONBITMAP = 2097152
GLOBAL CONST $WS_EX_RIGHT = 4096
GLOBAL CONST $WS_EX_RIGHTSCROLLBAR = 0
GLOBAL CONST $WS_EX_RTLREADING = 8192
GLOBAL CONST $WS_EX_STATICEDGE = 131072
GLOBAL CONST $WS_EX_TOOLWINDOW = 128
GLOBAL CONST $WS_EX_TOPMOST = 8
GLOBAL CONST $WS_EX_TRANSPARENT = 32
GLOBAL CONST $WS_EX_WINDOWEDGE = 256
GLOBAL CONST $WS_EX_OVERLAPPEDWINDOW = BITOR($WS_EX_CLIENTEDGE, $WS_EX_WINDOWEDGE)
GLOBAL CONST $WS_EX_PALETTEWINDOW = BITOR($WS_EX_TOOLWINDOW, $WS_EX_TOPMOST, $WS_EX_WINDOWEDGE)
GLOBAL CONST $WM_NULL = 0
GLOBAL CONST $WM_CREATE = 1
GLOBAL CONST $WM_DESTROY = 2
GLOBAL CONST $WM_MOVE = 3
GLOBAL CONST $WM_SIZEWAIT = 4
GLOBAL CONST $WM_SIZE = 5
GLOBAL CONST $WM_ACTIVATE = 6
GLOBAL CONST $WM_SETFOCUS = 7
GLOBAL CONST $WM_KILLFOCUS = 8
GLOBAL CONST $WM_SETVISIBLE = 9
GLOBAL CONST $WM_ENABLE = 10
GLOBAL CONST $WM_SETREDRAW = 11
GLOBAL CONST $WM_SETTEXT = 12
GLOBAL CONST $WM_GETTEXT = 13
GLOBAL CONST $WM_GETTEXTLENGTH = 14
GLOBAL CONST $WM_PAINT = 15
GLOBAL CONST $WM_CLOSE = 16
GLOBAL CONST $WM_QUERYENDSESSION = 17
GLOBAL CONST $WM_QUIT = 18
GLOBAL CONST $WM_ERASEBKGND = 20
GLOBAL CONST $WM_QUERYOPEN = 19
GLOBAL CONST $WM_SYSCOLORCHANGE = 21
GLOBAL CONST $WM_ENDSESSION = 22
GLOBAL CONST $WM_SYSTEMERROR = 23
GLOBAL CONST $WM_SHOWWINDOW = 24
GLOBAL CONST $WM_CTLCOLOR = 25
GLOBAL CONST $WM_SETTINGCHANGE = 26
GLOBAL CONST $WM_WININICHANGE = 26
GLOBAL CONST $WM_DEVMODECHANGE = 27
GLOBAL CONST $WM_ACTIVATEAPP = 28
GLOBAL CONST $WM_FONTCHANGE = 29
GLOBAL CONST $WM_TIMECHANGE = 30
GLOBAL CONST $WM_CANCELMODE = 31
GLOBAL CONST $WM_SETCURSOR = 32
GLOBAL CONST $WM_MOUSEACTIVATE = 33
GLOBAL CONST $WM_CHILDACTIVATE = 34
GLOBAL CONST $WM_QUEUESYNC = 35
GLOBAL CONST $WM_GETMINMAXINFO = 36
GLOBAL CONST $WM_LOGOFF = 37
GLOBAL CONST $WM_PAINTICON = 38
GLOBAL CONST $WM_ICONERASEBKGND = 39
GLOBAL CONST $WM_NEXTDLGCTL = 40
GLOBAL CONST $WM_ALTTABACTIVE = 41
GLOBAL CONST $WM_SPOOLERSTATUS = 42
GLOBAL CONST $WM_DRAWITEM = 43
GLOBAL CONST $WM_MEASUREITEM = 44
GLOBAL CONST $WM_DELETEITEM = 45
GLOBAL CONST $WM_VKEYTOITEM = 46
GLOBAL CONST $WM_CHARTOITEM = 47
GLOBAL CONST $WM_SETFONT = 48
GLOBAL CONST $WM_GETFONT = 49
GLOBAL CONST $WM_SETHOTKEY = 50
GLOBAL CONST $WM_GETHOTKEY = 51
GLOBAL CONST $WM_FILESYSCHANGE = 52
GLOBAL CONST $WM_ISACTIVEICON = 53
GLOBAL CONST $WM_QUERYPARKICON = 54
GLOBAL CONST $WM_QUERYDRAGICON = 55
GLOBAL CONST $WM_WINHELP = 56
GLOBAL CONST $WM_COMPAREITEM = 57
GLOBAL CONST $WM_FULLSCREEN = 58
GLOBAL CONST $WM_CLIENTSHUTDOWN = 59
GLOBAL CONST $WM_DDEMLEVENT = 60
GLOBAL CONST $WM_GETOBJECT = 61
GLOBAL CONST $WM_CALCSCROLL = 63
GLOBAL CONST $WM_TESTING = 64
GLOBAL CONST $WM_COMPACTING = 65
GLOBAL CONST $WM_OTHERWINDOWCREATED = 66
GLOBAL CONST $WM_OTHERWINDOWDESTROYED = 67
GLOBAL CONST $WM_COMMNOTIFY = 68
GLOBAL CONST $WM_MEDIASTATUSCHANGE = 69
GLOBAL CONST $WM_WINDOWPOSCHANGING = 70
GLOBAL CONST $WM_WINDOWPOSCHANGED = 71
GLOBAL CONST $WM_POWER = 72
GLOBAL CONST $WM_COPYGLOBALDATA = 73
GLOBAL CONST $WM_COPYDATA = 74
GLOBAL CONST $WM_CANCELJOURNAL = 75
GLOBAL CONST $WM_LOGONNOTIFY = 76
GLOBAL CONST $WM_KEYF1 = 77
GLOBAL CONST $WM_NOTIFY = 78
GLOBAL CONST $WM_ACCESS_WINDOW = 79
GLOBAL CONST $WM_INPUTLANGCHANGEREQUEST = 80
GLOBAL CONST $WM_INPUTLANGCHANGE = 81
GLOBAL CONST $WM_TCARD = 82
GLOBAL CONST $WM_HELP = 83
GLOBAL CONST $WM_USERCHANGED = 84
GLOBAL CONST $WM_NOTIFYFORMAT = 85
GLOBAL CONST $WM_QM_ACTIVATE = 96
GLOBAL CONST $WM_HOOK_DO_CALLBACK = 97
GLOBAL CONST $WM_SYSCOPYDATA = 98
GLOBAL CONST $WM_FINALDESTROY = 112
GLOBAL CONST $WM_MEASUREITEM_CLIENTDATA = 113
GLOBAL CONST $WM_CONTEXTMENU = 123
GLOBAL CONST $WM_STYLECHANGING = 124
GLOBAL CONST $WM_STYLECHANGED = 125
GLOBAL CONST $WM_DISPLAYCHANGE = 126
GLOBAL CONST $WM_GETICON = 127
GLOBAL CONST $WM_SETICON = 128
GLOBAL CONST $WM_NCCREATE = 129
GLOBAL CONST $WM_NCDESTROY = 130
GLOBAL CONST $WM_NCCALCSIZE = 131
GLOBAL CONST $WM_NCHITTEST = 132
GLOBAL CONST $WM_NCPAINT = 133
GLOBAL CONST $WM_NCACTIVATE = 134
GLOBAL CONST $WM_GETDLGCODE = 135
GLOBAL CONST $WM_SYNCPAINT = 136
GLOBAL CONST $WM_SYNCTASK = 137
GLOBAL CONST $WM_KLUDGEMINRECT = 139
GLOBAL CONST $WM_LPKDRAWSWITCHWND = 140
GLOBAL CONST $WM_UAHDESTROYWINDOW = 144
GLOBAL CONST $WM_UAHDRAWMENU = 145
GLOBAL CONST $WM_UAHDRAWMENUITEM = 146
GLOBAL CONST $WM_UAHINITMENU = 147
GLOBAL CONST $WM_UAHMEASUREMENUITEM = 148
GLOBAL CONST $WM_UAHNCPAINTMENUPOPUP = 149
GLOBAL CONST $WM_NCMOUSEMOVE = 160
GLOBAL CONST $WM_NCLBUTTONDOWN = 161
GLOBAL CONST $WM_NCLBUTTONUP = 162
GLOBAL CONST $WM_NCLBUTTONDBLCLK = 163
GLOBAL CONST $WM_NCRBUTTONDOWN = 164
GLOBAL CONST $WM_NCRBUTTONUP = 165
GLOBAL CONST $WM_NCRBUTTONDBLCLK = 166
GLOBAL CONST $WM_NCMBUTTONDOWN = 167
GLOBAL CONST $WM_NCMBUTTONUP = 168
GLOBAL CONST $WM_NCMBUTTONDBLCLK = 169
GLOBAL CONST $WM_NCXBUTTONDOWN = 171
GLOBAL CONST $WM_NCXBUTTONUP = 172
GLOBAL CONST $WM_NCXBUTTONDBLCLK = 173
GLOBAL CONST $WM_NCUAHDRAWCAPTION = 174
GLOBAL CONST $WM_NCUAHDRAWFRAME = 175
GLOBAL CONST $WM_INPUT_DEVICE_CHANGE = 254
GLOBAL CONST $WM_INPUT = 255
GLOBAL CONST $WM_KEYDOWN = 256
GLOBAL CONST $WM_KEYFIRST = 256
GLOBAL CONST $WM_KEYUP = 257
GLOBAL CONST $WM_CHAR = 258
GLOBAL CONST $WM_DEADCHAR = 259
GLOBAL CONST $WM_SYSKEYDOWN = 260
GLOBAL CONST $WM_SYSKEYUP = 261
GLOBAL CONST $WM_SYSCHAR = 262
GLOBAL CONST $WM_SYSDEADCHAR = 263
GLOBAL CONST $WM_YOMICHAR = 264
GLOBAL CONST $WM_KEYLAST = 265
GLOBAL CONST $WM_UNICHAR = 265
GLOBAL CONST $WM_CONVERTREQUEST = 266
GLOBAL CONST $WM_CONVERTRESULT = 267
GLOBAL CONST $WM_IM_INFO = 268
GLOBAL CONST $WM_IME_STARTCOMPOSITION = 269
GLOBAL CONST $WM_IME_ENDCOMPOSITION = 270
GLOBAL CONST $WM_IME_COMPOSITION = 271
GLOBAL CONST $WM_IME_KEYLAST = 271
GLOBAL CONST $WM_INITDIALOG = 272
GLOBAL CONST $WM_COMMAND = 273
GLOBAL CONST $WM_SYSCOMMAND = 274
GLOBAL CONST $WM_TIMER = 275
GLOBAL CONST $WM_HSCROLL = 276
GLOBAL CONST $WM_VSCROLL = 277
GLOBAL CONST $WM_INITMENU = 278
GLOBAL CONST $WM_INITMENUPOPUP = 279
GLOBAL CONST $WM_SYSTIMER = 280
GLOBAL CONST $WM_GESTURE = 281
GLOBAL CONST $WM_GESTURENOTIFY = 282
GLOBAL CONST $WM_GESTUREINPUT = 283
GLOBAL CONST $WM_GESTURENOTIFIED = 284
GLOBAL CONST $WM_MENUSELECT = 287
GLOBAL CONST $WM_MENUCHAR = 288
GLOBAL CONST $WM_ENTERIDLE = 289
GLOBAL CONST $WM_MENURBUTTONUP = 290
GLOBAL CONST $WM_MENUDRAG = 291
GLOBAL CONST $WM_MENUGETOBJECT = 292
GLOBAL CONST $WM_UNINITMENUPOPUP = 293
GLOBAL CONST $WM_MENUCOMMAND = 294
GLOBAL CONST $WM_CHANGEUISTATE = 295
GLOBAL CONST $WM_UPDATEUISTATE = 296
GLOBAL CONST $WM_QUERYUISTATE = 297
GLOBAL CONST $WM_LBTRACKPOINT = 305
GLOBAL CONST $WM_CTLCOLORMSGBOX = 306
GLOBAL CONST $WM_CTLCOLOREDIT = 307
GLOBAL CONST $WM_CTLCOLORLISTBOX = 308
GLOBAL CONST $WM_CTLCOLORBTN = 309
GLOBAL CONST $WM_CTLCOLORDLG = 310
GLOBAL CONST $WM_CTLCOLORSCROLLBAR = 311
GLOBAL CONST $WM_CTLCOLORSTATIC = 312
GLOBAL CONST $MN_GETHMENU = 481
GLOBAL CONST $WM_PARENTNOTIFY = 528
GLOBAL CONST $WM_ENTERMENULOOP = 529
GLOBAL CONST $WM_EXITMENULOOP = 530
GLOBAL CONST $WM_NEXTMENU = 531
GLOBAL CONST $WM_SIZING = 532
GLOBAL CONST $WM_CAPTURECHANGED = 533
GLOBAL CONST $WM_MOVING = 534
GLOBAL CONST $WM_POWERBROADCAST = 536
GLOBAL CONST $WM_DEVICECHANGE = 537
GLOBAL CONST $WM_MDICREATE = 544
GLOBAL CONST $WM_MDIDESTROY = 545
GLOBAL CONST $WM_MDIACTIVATE = 546
GLOBAL CONST $WM_MDIRESTORE = 547
GLOBAL CONST $WM_MDINEXT = 548
GLOBAL CONST $WM_MDIMAXIMIZE = 549
GLOBAL CONST $WM_MDITILE = 550
GLOBAL CONST $WM_MDICASCADE = 551
GLOBAL CONST $WM_MDIICONARRANGE = 552
GLOBAL CONST $WM_MDIGETACTIVE = 553
GLOBAL CONST $WM_DROPOBJECT = 554
GLOBAL CONST $WM_QUERYDROPOBJECT = 555
GLOBAL CONST $WM_BEGINDRAG = 556
GLOBAL CONST $WM_DRAGLOOP = 557
GLOBAL CONST $WM_DRAGSELECT = 558
GLOBAL CONST $WM_DRAGMOVE = 559
GLOBAL CONST $WM_MDISETMENU = 560
GLOBAL CONST $WM_ENTERSIZEMOVE = 561
GLOBAL CONST $WM_EXITSIZEMOVE = 562
GLOBAL CONST $WM_DROPFILES = 563
GLOBAL CONST $WM_MDIREFRESHMENU = 564
GLOBAL CONST $WM_TOUCH = 576
GLOBAL CONST $WM_IME_SETCONTEXT = 641
GLOBAL CONST $WM_IME_NOTIFY = 642
GLOBAL CONST $WM_IME_CONTROL = 643
GLOBAL CONST $WM_IME_COMPOSITIONFULL = 644
GLOBAL CONST $WM_IME_SELECT = 645
GLOBAL CONST $WM_IME_CHAR = 646
GLOBAL CONST $WM_IME_SYSTEM = 647
GLOBAL CONST $WM_IME_REQUEST = 648
GLOBAL CONST $WM_IME_KEYDOWN = 656
GLOBAL CONST $WM_IME_KEYUP = 657
GLOBAL CONST $WM_NCMOUSEHOVER = 672
GLOBAL CONST $WM_MOUSEHOVER = 673
GLOBAL CONST $WM_NCMOUSELEAVE = 674
GLOBAL CONST $WM_MOUSELEAVE = 675
GLOBAL CONST $WM_WTSSESSION_CHANGE = 689
GLOBAL CONST $WM_TABLET_FIRST = 704
GLOBAL CONST $WM_TABLET_LAST = 735
GLOBAL CONST $WM_CUT = 768
GLOBAL CONST $WM_COPY = 769
GLOBAL CONST $WM_PASTE = 770
GLOBAL CONST $WM_CLEAR = 771
GLOBAL CONST $WM_UNDO = 772
GLOBAL CONST $WM_PALETTEISCHANGING = 784
GLOBAL CONST $WM_HOTKEY = 786
GLOBAL CONST $WM_PALETTECHANGED = 785
GLOBAL CONST $WM_SYSMENU = 787
GLOBAL CONST $WM_HOOKMSG = 788
GLOBAL CONST $WM_EXITPROCESS = 789
GLOBAL CONST $WM_WAKETHREAD = 790
GLOBAL CONST $WM_PRINT = 791
GLOBAL CONST $WM_PRINTCLIENT = 792
GLOBAL CONST $WM_APPCOMMAND = 793
GLOBAL CONST $WM_QUERYNEWPALETTE = 783
GLOBAL CONST $WM_THEMECHANGED = 794
GLOBAL CONST $WM_UAHINIT = 795
GLOBAL CONST $WM_DESKTOPNOTIFY = 796
GLOBAL CONST $WM_CLIPBOARDUPDATE = 797
GLOBAL CONST $WM_DWMCOMPOSITIONCHANGED = 798
GLOBAL CONST $WM_DWMNCRENDERINGCHANGED = 799
GLOBAL CONST $WM_DWMCOLORIZATIONCOLORCHANGED = 800
GLOBAL CONST $WM_DWMWINDOWMAXIMIZEDCHANGE = 801
GLOBAL CONST $WM_DWMEXILEFRAME = 802
GLOBAL CONST $WM_DWMSENDICONICTHUMBNAIL = 803
GLOBAL CONST $WM_MAGNIFICATION_STARTED = 804
GLOBAL CONST $WM_MAGNIFICATION_ENDED = 805
GLOBAL CONST $WM_DWMSENDICONICLIVEPREVIEWBITMAP = 806
GLOBAL CONST $WM_DWMTHUMBNAILSIZECHANGED = 807
GLOBAL CONST $WM_MAGNIFICATION_OUTPUT = 808
GLOBAL CONST $WM_MEASURECONTROL = 816
GLOBAL CONST $WM_GETACTIONTEXT = 817
GLOBAL CONST $WM_FORWARDKEYDOWN = 819
GLOBAL CONST $WM_FORWARDKEYUP = 820
GLOBAL CONST $WM_GETTITLEBARINFOEX = 831
GLOBAL CONST $WM_NOTIFYWOW = 832
GLOBAL CONST $WM_HANDHELDFIRST = 856
GLOBAL CONST $WM_HANDHELDLAST = 863
GLOBAL CONST $WM_AFXFIRST = 864
GLOBAL CONST $WM_AFXLAST = 895
GLOBAL CONST $WM_PENWINFIRST = 896
GLOBAL CONST $WM_PENWINLAST = 911
GLOBAL CONST $WM_DDE_INITIATE = 992
GLOBAL CONST $WM_DDE_TERMINATE = 993
GLOBAL CONST $WM_DDE_ADVISE = 994
GLOBAL CONST $WM_DDE_UNADVISE = 995
GLOBAL CONST $WM_DDE_ACK = 996
GLOBAL CONST $WM_DDE_DATA = 997
GLOBAL CONST $WM_DDE_REQUEST = 998
GLOBAL CONST $WM_DDE_POKE = 999
GLOBAL CONST $WM_DDE_EXECUTE = 1000
GLOBAL CONST $WM_DBNOTIFICATION = 1021
GLOBAL CONST $WM_NETCONNECT = 1022
GLOBAL CONST $WM_HIBERNATE = 1023
GLOBAL CONST $WM_USER = 1024
GLOBAL CONST $WM_APP = 32768
GLOBAL CONST $NM_FIRST = 0
GLOBAL CONST $NM_OUTOFMEMORY = $NM_FIRST - 1
GLOBAL CONST $NM_CLICK = $NM_FIRST - 2
GLOBAL CONST $NM_DBLCLK = $NM_FIRST - 3
GLOBAL CONST $NM_RETURN = $NM_FIRST - 4
GLOBAL CONST $NM_RCLICK = $NM_FIRST - 5
GLOBAL CONST $NM_RDBLCLK = $NM_FIRST - 6
GLOBAL CONST $NM_SETFOCUS = $NM_FIRST - 7
GLOBAL CONST $NM_KILLFOCUS = $NM_FIRST - 8
GLOBAL CONST $NM_CUSTOMDRAW = $NM_FIRST - 12
GLOBAL CONST $NM_HOVER = $NM_FIRST - 13
GLOBAL CONST $NM_NCHITTEST = $NM_FIRST - 14
GLOBAL CONST $NM_KEYDOWN = $NM_FIRST - 15
GLOBAL CONST $NM_RELEASEDCAPTURE = $NM_FIRST - 16
GLOBAL CONST $NM_SETCURSOR = $NM_FIRST - 17
GLOBAL CONST $NM_CHAR = $NM_FIRST - 18
GLOBAL CONST $NM_TOOLTIPSCREATED = $NM_FIRST - 19
GLOBAL CONST $NM_LDOWN = $NM_FIRST - 20
GLOBAL CONST $NM_RDOWN = $NM_FIRST - 21
GLOBAL CONST $NM_THEMECHANGED = $NM_FIRST - 22
GLOBAL CONST $WM_MOUSEFIRST = 512
GLOBAL CONST $WM_MOUSEMOVE = 512
GLOBAL CONST $WM_LBUTTONDOWN = 513
GLOBAL CONST $WM_LBUTTONUP = 514
GLOBAL CONST $WM_LBUTTONDBLCLK = 515
GLOBAL CONST $WM_RBUTTONDOWN = 516
GLOBAL CONST $WM_RBUTTONUP = 517
GLOBAL CONST $WM_RBUTTONDBLCLK = 518
GLOBAL CONST $WM_MBUTTONDOWN = 519
GLOBAL CONST $WM_MBUTTONUP = 520
GLOBAL CONST $WM_MBUTTONDBLCLK = 521
GLOBAL CONST $WM_MOUSEWHEEL = 522
GLOBAL CONST $WM_XBUTTONDOWN = 523
GLOBAL CONST $WM_XBUTTONUP = 524
GLOBAL CONST $WM_XBUTTONDBLCLK = 525
GLOBAL CONST $WM_MOUSEHWHEEL = 526
GLOBAL CONST $PS_SOLID = 0
GLOBAL CONST $PS_DASH = 1
GLOBAL CONST $PS_DOT = 2
GLOBAL CONST $PS_DASHDOT = 3
GLOBAL CONST $PS_DASHDOTDOT = 4
GLOBAL CONST $PS_NULL = 5
GLOBAL CONST $PS_INSIDEFRAME = 6
GLOBAL CONST $PS_USERSTYLE = 7
GLOBAL CONST $PS_ALTERNATE = 8
GLOBAL CONST $PS_ENDCAP_ROUND = 0
GLOBAL CONST $PS_ENDCAP_SQUARE = 256
GLOBAL CONST $PS_ENDCAP_FLAT = 512
GLOBAL CONST $PS_JOIN_BEVEL = 4096
GLOBAL CONST $PS_JOIN_MITER = 8192
GLOBAL CONST $PS_JOIN_ROUND = 0
GLOBAL CONST $PS_GEOMETRIC = 65536
GLOBAL CONST $PS_COSMETIC = 0
GLOBAL CONST $LWA_ALPHA = 2
GLOBAL CONST $LWA_COLORKEY = 1
GLOBAL CONST $RGN_AND = 1
GLOBAL CONST $RGN_OR = 2
GLOBAL CONST $RGN_XOR = 3
GLOBAL CONST $RGN_DIFF = 4
GLOBAL CONST $RGN_COPY = 5
GLOBAL CONST $ERRORREGION = 0
GLOBAL CONST $NULLREGION = 1
GLOBAL CONST $SIMPLEREGION = 2
GLOBAL CONST $COMPLEXREGION = 3
GLOBAL CONST $TRANSPARENT = 1
GLOBAL CONST $OPAQUE = 2
GLOBAL CONST $CCM_FIRST = 8192
GLOBAL CONST $CCM_GETUNICODEFORMAT = ($CCM_FIRST + 6)
GLOBAL CONST $CCM_SETUNICODEFORMAT = ($CCM_FIRST + 5)
GLOBAL CONST $CCM_SETBKCOLOR = $CCM_FIRST + 1
GLOBAL CONST $CCM_SETCOLORSCHEME = $CCM_FIRST + 2
GLOBAL CONST $CCM_GETCOLORSCHEME = $CCM_FIRST + 3
GLOBAL CONST $CCM_GETDROPTARGET = $CCM_FIRST + 4
GLOBAL CONST $CCM_SETWINDOWTHEME = $CCM_FIRST + 11
GLOBAL CONST $GA_PARENT = 1
GLOBAL CONST $GA_ROOT = 2
GLOBAL CONST $GA_ROOTOWNER = 3
GLOBAL CONST $SM_CXSCREEN = 0
GLOBAL CONST $SM_CYSCREEN = 1
GLOBAL CONST $SM_CXVSCROLL = 2
GLOBAL CONST $SM_CYHSCROLL = 3
GLOBAL CONST $SM_CYCAPTION = 4
GLOBAL CONST $SM_CXBORDER = 5
GLOBAL CONST $SM_CYBORDER = 6
GLOBAL CONST $SM_CXFIXEDFRAME = 7
GLOBAL CONST $SM_CXDLGFRAME = $SM_CXFIXEDFRAME
GLOBAL CONST $SM_CYFIXEDFRAME = 8
GLOBAL CONST $SM_CYDLGFRAME = $SM_CYFIXEDFRAME
GLOBAL CONST $SM_CYVTHUMB = 9
GLOBAL CONST $SM_CXHTHUMB = 10
GLOBAL CONST $SM_CXICON = 11
GLOBAL CONST $SM_CYICON = 12
GLOBAL CONST $SM_CXCURSOR = 13
GLOBAL CONST $SM_CYCURSOR = 14
GLOBAL CONST $SM_CYMENU = 15
GLOBAL CONST $SM_CXFULLSCREEN = 16
GLOBAL CONST $SM_CYFULLSCREEN = 17
GLOBAL CONST $SM_CYKANJIWINDOW = 18
GLOBAL CONST $SM_MOUSEPRESENT = 19
GLOBAL CONST $SM_CYVSCROLL = 20
GLOBAL CONST $SM_CXHSCROLL = 21
GLOBAL CONST $SM_DEBUG = 22
GLOBAL CONST $SM_SWAPBUTTON = 23
GLOBAL CONST $SM_RESERVED1 = 24
GLOBAL CONST $SM_RESERVED2 = 25
GLOBAL CONST $SM_RESERVED3 = 26
GLOBAL CONST $SM_RESERVED4 = 27
GLOBAL CONST $SM_CXMIN = 28
GLOBAL CONST $SM_CYMIN = 29
GLOBAL CONST $SM_CXSIZE = 30
GLOBAL CONST $SM_CYSIZE = 31
GLOBAL CONST $SM_CXSIZEFRAME = 32
GLOBAL CONST $SM_CXFRAME = $SM_CXSIZEFRAME
GLOBAL CONST $SM_CYSIZEFRAME = 33
GLOBAL CONST $SM_CYFRAME = $SM_CYSIZEFRAME
GLOBAL CONST $SM_CXMINTRACK = 34
GLOBAL CONST $SM_CYMINTRACK = 35
GLOBAL CONST $SM_CXDOUBLECLK = 36
GLOBAL CONST $SM_CYDOUBLECLK = 37
GLOBAL CONST $SM_CXICONSPACING = 38
GLOBAL CONST $SM_CYICONSPACING = 39
GLOBAL CONST $SM_MENUDROPALIGNMENT = 40
GLOBAL CONST $SM_PENWINDOWS = 41
GLOBAL CONST $SM_DBCSENABLED = 42
GLOBAL CONST $SM_CMOUSEBUTTONS = 43
GLOBAL CONST $SM_SECURE = 44
GLOBAL CONST $SM_CXEDGE = 45
GLOBAL CONST $SM_CYEDGE = 46
GLOBAL CONST $SM_CXMINSPACING = 47
GLOBAL CONST $SM_CYMINSPACING = 48
GLOBAL CONST $SM_CXSMICON = 49
GLOBAL CONST $SM_CYSMICON = 50
GLOBAL CONST $SM_CYSMCAPTION = 51
GLOBAL CONST $SM_CXSMSIZE = 52
GLOBAL CONST $SM_CYSMSIZE = 53
GLOBAL CONST $SM_CXMENUSIZE = 54
GLOBAL CONST $SM_CYMENUSIZE = 55
GLOBAL CONST $SM_ARRANGE = 56
GLOBAL CONST $SM_CXMINIMIZED = 57
GLOBAL CONST $SM_CYMINIMIZED = 58
GLOBAL CONST $SM_CXMAXTRACK = 59
GLOBAL CONST $SM_CYMAXTRACK = 60
GLOBAL CONST $SM_CXMAXIMIZED = 61
GLOBAL CONST $SM_CYMAXIMIZED = 62
GLOBAL CONST $SM_NETWORK = 63
GLOBAL CONST $SM_CLEANBOOT = 67
GLOBAL CONST $SM_CXDRAG = 68
GLOBAL CONST $SM_CYDRAG = 69
GLOBAL CONST $SM_SHOWSOUNDS = 70
GLOBAL CONST $SM_CXMENUCHECK = 71
GLOBAL CONST $SM_CYMENUCHECK = 72
GLOBAL CONST $SM_SLOWMACHINE = 73
GLOBAL CONST $SM_MIDEASTENABLED = 74
GLOBAL CONST $SM_MOUSEWHEELPRESENT = 75
GLOBAL CONST $SM_XVIRTUALSCREEN = 76
GLOBAL CONST $SM_YVIRTUALSCREEN = 77
GLOBAL CONST $SM_CXVIRTUALSCREEN = 78
GLOBAL CONST $SM_CYVIRTUALSCREEN = 79
GLOBAL CONST $SM_CMONITORS = 80
GLOBAL CONST $SM_SAMEDISPLAYFORMAT = 81
GLOBAL CONST $SM_IMMENABLED = 82
GLOBAL CONST $SM_CXFOCUSBORDER = 83
GLOBAL CONST $SM_CYFOCUSBORDER = 84
GLOBAL CONST $SM_TABLETPC = 86
GLOBAL CONST $SM_MEDIACENTER = 87
GLOBAL CONST $SM_STARTER = 88
GLOBAL CONST $SM_SERVERR2 = 89
GLOBAL CONST $SM_CMETRICS = 90
GLOBAL CONST $SM_REMOTESESSION = 4096
GLOBAL CONST $SM_SHUTTINGDOWN = 8192
GLOBAL CONST $SM_REMOTECONTROL = 8193
GLOBAL CONST $SM_CARETBLINKINGENABLED = 8194
GLOBAL CONST $BLACKNESS = 66
GLOBAL CONST $CAPTUREBLT = 1073741824
GLOBAL CONST $DSTINVERT = 5570569
GLOBAL CONST $MERGECOPY = 12583114
GLOBAL CONST $MERGEPAINT = 12255782
GLOBAL CONST $NOMIRRORBITMAP = -2147483648
GLOBAL CONST $NOTSRCCOPY = 3342344
GLOBAL CONST $NOTSRCERASE = 1114278
GLOBAL CONST $PATCOPY = 15728673
GLOBAL CONST $PATINVERT = 5898313
GLOBAL CONST $PATPAINT = 16452105
GLOBAL CONST $SRCAND = 8913094
GLOBAL CONST $SRCCOPY = 13369376
GLOBAL CONST $SRCERASE = 4457256
GLOBAL CONST $SRCINVERT = 6684742
GLOBAL CONST $SRCPAINT = 15597702
GLOBAL CONST $WHITENESS = 16711778
GLOBAL CONST $DT_BOTTOM = 8
GLOBAL CONST $DT_CALCRECT = 1024
GLOBAL CONST $DT_CENTER = 1
GLOBAL CONST $DT_EDITCONTROL = 8192
GLOBAL CONST $DT_END_ELLIPSIS = 32768
GLOBAL CONST $DT_EXPANDTABS = 64
GLOBAL CONST $DT_EXTERNALLEADING = 512
GLOBAL CONST $DT_HIDEPREFIX = 1048576
GLOBAL CONST $DT_INTERNAL = 4096
GLOBAL CONST $DT_LEFT = 0
GLOBAL CONST $DT_MODIFYSTRING = 65536
GLOBAL CONST $DT_NOCLIP = 256
GLOBAL CONST $DT_NOFULLWIDTHCHARBREAK = 524288
GLOBAL CONST $DT_NOPREFIX = 2048
GLOBAL CONST $DT_PATH_ELLIPSIS = 16384
GLOBAL CONST $DT_PREFIXONLY = 2097152
GLOBAL CONST $DT_RIGHT = 2
GLOBAL CONST $DT_RTLREADING = 131072
GLOBAL CONST $DT_SINGLELINE = 32
GLOBAL CONST $DT_TABSTOP = 128
GLOBAL CONST $DT_TOP = 0
GLOBAL CONST $DT_VCENTER = 4
GLOBAL CONST $DT_WORDBREAK = 16
GLOBAL CONST $DT_WORD_ELLIPSIS = 262144
GLOBAL CONST $RDW_ERASE = 4
GLOBAL CONST $RDW_FRAME = 1024
GLOBAL CONST $RDW_INTERNALPAINT = 2
GLOBAL CONST $RDW_INVALIDATE = 1
GLOBAL CONST $RDW_NOERASE = 32
GLOBAL CONST $RDW_NOFRAME = 2048
GLOBAL CONST $RDW_NOINTERNALPAINT = 16
GLOBAL CONST $RDW_VALIDATE = 8
GLOBAL CONST $RDW_ERASENOW = 512
GLOBAL CONST $RDW_UPDATENOW = 256
GLOBAL CONST $RDW_ALLCHILDREN = 128
GLOBAL CONST $RDW_NOCHILDREN = 64
GLOBAL CONST $WM_RENDERFORMAT = 773
GLOBAL CONST $WM_RENDERALLFORMATS = 774
GLOBAL CONST $WM_DESTROYCLIPBOARD = 775
GLOBAL CONST $WM_DRAWCLIPBOARD = 776
GLOBAL CONST $WM_PAINTCLIPBOARD = 777
GLOBAL CONST $WM_VSCROLLCLIPBOARD = 778
GLOBAL CONST $WM_SIZECLIPBOARD = 779
GLOBAL CONST $WM_ASKCBFORMATNAME = 780
GLOBAL CONST $WM_CHANGECBCHAIN = 781
GLOBAL CONST $WM_HSCROLLCLIPBOARD = 782
GLOBAL CONST $HTERROR = -2
GLOBAL CONST $HTTRANSPARENT = -1
GLOBAL CONST $HTNOWHERE = 0
GLOBAL CONST $HTCLIENT = 1
GLOBAL CONST $HTCAPTION = 2
GLOBAL CONST $HTSYSMENU = 3
GLOBAL CONST $HTGROWBOX = 4
GLOBAL CONST $HTSIZE = $HTGROWBOX
GLOBAL CONST $HTMENU = 5
GLOBAL CONST $HTHSCROLL = 6
GLOBAL CONST $HTVSCROLL = 7
GLOBAL CONST $HTMINBUTTON = 8
GLOBAL CONST $HTMAXBUTTON = 9
GLOBAL CONST $HTLEFT = 10
GLOBAL CONST $HTRIGHT = 11
GLOBAL CONST $HTTOP = 12
GLOBAL CONST $HTTOPLEFT = 13
GLOBAL CONST $HTTOPRIGHT = 14
GLOBAL CONST $HTBOTTOM = 15
GLOBAL CONST $HTBOTTOMLEFT = 16
GLOBAL CONST $HTBOTTOMRIGHT = 17
GLOBAL CONST $HTBORDER = 18
GLOBAL CONST $HTREDUCE = $HTMINBUTTON
GLOBAL CONST $HTZOOM = $HTMAXBUTTON
GLOBAL CONST $HTSIZEFIRST = $HTLEFT
GLOBAL CONST $HTSIZELAST = $HTBOTTOMRIGHT
GLOBAL CONST $HTOBJECT = 19
GLOBAL CONST $HTCLOSE = 20
GLOBAL CONST $HTHELP = 21
GLOBAL CONST $COLOR_SCROLLBAR = 0
GLOBAL CONST $COLOR_BACKGROUND = 1
GLOBAL CONST $COLOR_ACTIVECAPTION = 2
GLOBAL CONST $COLOR_INACTIVECAPTION = 3
GLOBAL CONST $COLOR_MENU = 4
GLOBAL CONST $COLOR_WINDOW = 5
GLOBAL CONST $COLOR_WINDOWFRAME = 6
GLOBAL CONST $COLOR_MENUTEXT = 7
GLOBAL CONST $COLOR_WINDOWTEXT = 8
GLOBAL CONST $COLOR_CAPTIONTEXT = 9
GLOBAL CONST $COLOR_ACTIVEBORDER = 10
GLOBAL CONST $COLOR_INACTIVEBORDER = 11
GLOBAL CONST $COLOR_APPWORKSPACE = 12
GLOBAL CONST $COLOR_HIGHLIGHT = 13
GLOBAL CONST $COLOR_HIGHLIGHTTEXT = 14
GLOBAL CONST $COLOR_BTNFACE = 15
GLOBAL CONST $COLOR_BTNSHADOW = 16
GLOBAL CONST $COLOR_GRAYTEXT = 17
GLOBAL CONST $COLOR_BTNTEXT = 18
GLOBAL CONST $COLOR_INACTIVECAPTIONTEXT = 19
GLOBAL CONST $COLOR_BTNHIGHLIGHT = 20
GLOBAL CONST $COLOR_3DDKSHADOW = 21
GLOBAL CONST $COLOR_3DLIGHT = 22
GLOBAL CONST $COLOR_INFOTEXT = 23
GLOBAL CONST $COLOR_INFOBK = 24
GLOBAL CONST $COLOR_HOTLIGHT = 26
GLOBAL CONST $COLOR_GRADIENTACTIVECAPTION = 27
GLOBAL CONST $COLOR_GRADIENTINACTIVECAPTION = 28
GLOBAL CONST $COLOR_MENUHILIGHT = 29
GLOBAL CONST $COLOR_MENUBAR = 30
GLOBAL CONST $COLOR_DESKTOP = 1
GLOBAL CONST $COLOR_3DFACE = 15
GLOBAL CONST $COLOR_3DSHADOW = 16
GLOBAL CONST $COLOR_3DHIGHLIGHT = 20
GLOBAL CONST $COLOR_3DHILIGHT = 20
GLOBAL CONST $COLOR_BTNHILIGHT = 20
GLOBAL CONST $HINST_COMMCTRL = -1
GLOBAL CONST $IDB_STD_SMALL_COLOR = 0
GLOBAL CONST $IDB_STD_LARGE_COLOR = 1
GLOBAL CONST $IDB_VIEW_SMALL_COLOR = 4
GLOBAL CONST $IDB_VIEW_LARGE_COLOR = 5
GLOBAL CONST $IDB_HIST_SMALL_COLOR = 8
GLOBAL CONST $IDB_HIST_LARGE_COLOR = 9
GLOBAL CONST $STARTF_FORCEOFFFEEDBACK = 128
GLOBAL CONST $STARTF_FORCEONFEEDBACK = 64
GLOBAL CONST $STARTF_PREVENTPINNING = 8192
GLOBAL CONST $STARTF_RUNFULLSCREEN = 32
GLOBAL CONST $STARTF_TITLEISAPPID = 4096
GLOBAL CONST $STARTF_TITLEISLINKNAME = 2048
GLOBAL CONST $STARTF_USECOUNTCHARS = 8
GLOBAL CONST $STARTF_USEFILLATTRIBUTE = 16
GLOBAL CONST $STARTF_USEHOTKEY = 512
GLOBAL CONST $STARTF_USEPOSITION = 4
GLOBAL CONST $STARTF_USESHOWWINDOW = 1
GLOBAL CONST $STARTF_USESIZE = 2
GLOBAL CONST $STARTF_USESTDHANDLES = 256
GLOBAL CONST $CDDS_PREPAINT = 1
GLOBAL CONST $CDDS_POSTPAINT = 2
GLOBAL CONST $CDDS_PREERASE = 3
GLOBAL CONST $CDDS_POSTERASE = 4
GLOBAL CONST $CDDS_ITEM = 65536
GLOBAL CONST $CDDS_ITEMPREPAINT = 65537
GLOBAL CONST $CDDS_ITEMPOSTPAINT = 65538
GLOBAL CONST $CDDS_ITEMPREERASE = 65539
GLOBAL CONST $CDDS_ITEMPOSTERASE = 65540
GLOBAL CONST $CDDS_SUBITEM = 131072
GLOBAL CONST $CDIS_SELECTED = 1
GLOBAL CONST $CDIS_GRAYED = 2
GLOBAL CONST $CDIS_DISABLED = 4
GLOBAL CONST $CDIS_CHECKED = 8
GLOBAL CONST $CDIS_FOCUS = 16
GLOBAL CONST $CDIS_DEFAULT = 32
GLOBAL CONST $CDIS_HOT = 64
GLOBAL CONST $CDIS_MARKED = 128
GLOBAL CONST $CDIS_INDETERMINATE = 256
GLOBAL CONST $CDIS_SHOWKEYBOARDCUES = 512
GLOBAL CONST $CDIS_NEARHOT = 1024
GLOBAL CONST $CDIS_OTHERSIDEHOT = 2048
GLOBAL CONST $CDIS_DROPHILITED = 4096
GLOBAL CONST $CDRF_DODEFAULT = 0
GLOBAL CONST $CDRF_NEWFONT = 2
GLOBAL CONST $CDRF_SKIPDEFAULT = 4
GLOBAL CONST $CDRF_NOTIFYPOSTPAINT = 16
GLOBAL CONST $CDRF_NOTIFYITEMDRAW = 32
GLOBAL CONST $CDRF_NOTIFYSUBITEMDRAW = 32
GLOBAL CONST $CDRF_NOTIFYPOSTERASE = 64
GLOBAL CONST $CDRF_DOERASE = 8
GLOBAL CONST $CDRF_SKIPPOSTPAINT = 256
GLOBAL CONST $GUI_SS_DEFAULT_GUI = BITOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU)
GLOBAL CONST $OPT_COORDSRELATIVE = 0
GLOBAL CONST $OPT_COORDSABSOLUTE = 1
GLOBAL CONST $OPT_COORDSCLIENT = 2
GLOBAL CONST $OPT_ERRORSILENT = 0
GLOBAL CONST $OPT_ERRORFATAL = 1
GLOBAL CONST $OPT_CAPSNOSTORE = 0
GLOBAL CONST $OPT_CAPSSTORE = 1
GLOBAL CONST $OPT_MATCHSTART = 1
GLOBAL CONST $OPT_MATCHANY = 2
GLOBAL CONST $OPT_MATCHEXACT = 3
GLOBAL CONST $OPT_MATCHADVANCED = 4
GLOBAL CONST $CCS_TOP = 1
GLOBAL CONST $CCS_NOMOVEY = 2
GLOBAL CONST $CCS_BOTTOM = 3
GLOBAL CONST $CCS_NORESIZE = 4
GLOBAL CONST $CCS_NOPARENTALIGN = 8
GLOBAL CONST $CCS_NOHILITE = 16
GLOBAL CONST $CCS_ADJUSTABLE = 32
GLOBAL CONST $CCS_NODIVIDER = 64
GLOBAL CONST $CCS_VERT = 128
GLOBAL CONST $CCS_LEFT = 129
GLOBAL CONST $CCS_NOMOVEX = 130
GLOBAL CONST $CCS_RIGHT = 131
GLOBAL CONST $DT_DRIVETYPE = 1
GLOBAL CONST $DT_SSDSTATUS = 2
GLOBAL CONST $DT_BUSTYPE = 3
GLOBAL CONST $PROXY_IE = 0
GLOBAL CONST $PROXY_NONE = 1
GLOBAL CONST $PROXY_SPECIFIED = 2
GLOBAL CONST $OBJID_WINDOW = 0
GLOBAL CONST $OBJID_TITLEBAR = -2
GLOBAL CONST $OBJID_SIZEGRIP = -7
GLOBAL CONST $OBJID_CARET = -8
GLOBAL CONST $OBJID_CURSOR = -9
GLOBAL CONST $OBJID_ALERT = -10
GLOBAL CONST $OBJID_SOUND = -11
GLOBAL CONST $DLG_CENTERONTOP = 0
GLOBAL CONST $DLG_NOTITLE = 1
GLOBAL CONST $DLG_NOTONTOP = 2
GLOBAL CONST $DLG_TEXTLEFT = 4
GLOBAL CONST $DLG_TEXTRIGHT = 8
GLOBAL CONST $DLG_MOVEABLE = 16
GLOBAL CONST $DLG_TEXTVCENTER = 32
GLOBAL CONST $MCID_UNKNOWN = -1
GLOBAL CONST $MCID_HAND = 0
GLOBAL CONST $MCID_APPSTARTING = 1
GLOBAL CONST $MCID_ARROW = 2
GLOBAL CONST $MCID_CROSS = 3
GLOBAL CONST $MCID_HELP = 4
GLOBAL CONST $MCID_IBEAM = 5
GLOBAL CONST $MCID_ICON = 6
GLOBAL CONST $MCID_NO = 7
GLOBAL CONST $MCID_SIZE = 8
GLOBAL CONST $MCID_SIZEALL = 9
GLOBAL CONST $MCID_SIZENESW = 10
GLOBAL CONST $MCID_SIZENS = 11
GLOBAL CONST $MCID_SIZENWSE = 12
GLOBAL CONST $MCID_SIZEWE = 13
GLOBAL CONST $MCID_UPARROW = 14
GLOBAL CONST $MCID_WAIT = 15
GLOBAL CONST $MCID_NONE = 16
GLOBAL CONST $SD_LOGOFF = 0
GLOBAL CONST $SD_SHUTDOWN = 1
GLOBAL CONST $SD_REBOOT = 2
GLOBAL CONST $SD_FORCE = 4
GLOBAL CONST $SD_POWERDOWN = 8
GLOBAL CONST $SD_FORCEHUNG = 16
GLOBAL CONST $SD_STANDBY = 32
GLOBAL CONST $SD_HIBERNATE = 64
GLOBAL CONST $STDIN_CHILD = 1
GLOBAL CONST $STDOUT_CHILD = 2
GLOBAL CONST $STDERR_CHILD = 4
GLOBAL CONST $STDERR_MERGED = 8
GLOBAL CONST $STDIO_INHERIT_PARENT = 16
GLOBAL CONST $RUN_CREATE_NEW_CONSOLE = 65536
GLOBAL CONST $UBOUND_DIMENSIONS = 0
GLOBAL CONST $UBOUND_ROWS = 1
GLOBAL CONST $UBOUND_COLUMNS = 2
GLOBAL CONST $MOUSEEVENTF_ABSOLUTE = 32768
GLOBAL CONST $MOUSEEVENTF_MOVE = 1
GLOBAL CONST $MOUSEEVENTF_LEFTDOWN = 2
GLOBAL CONST $MOUSEEVENTF_LEFTUP = 4
GLOBAL CONST $MOUSEEVENTF_RIGHTDOWN = 8
GLOBAL CONST $MOUSEEVENTF_RIGHTUP = 16
GLOBAL CONST $MOUSEEVENTF_MIDDLEDOWN = 32
GLOBAL CONST $MOUSEEVENTF_MIDDLEUP = 64
GLOBAL CONST $MOUSEEVENTF_WHEEL = 2048
GLOBAL CONST $MOUSEEVENTF_XDOWN = 128
GLOBAL CONST $MOUSEEVENTF_XUP = 256
GLOBAL CONST $REG_NONE = 0
GLOBAL CONST $REG_SZ = 1
GLOBAL CONST $REG_EXPAND_SZ = 2
GLOBAL CONST $REG_BINARY = 3
GLOBAL CONST $REG_DWORD = 4
GLOBAL CONST $REG_DWORD_LITTLE_ENDIAN = 4
GLOBAL CONST $REG_DWORD_BIG_ENDIAN = 5
GLOBAL CONST $REG_LINK = 6
GLOBAL CONST $REG_MULTI_SZ = 7
GLOBAL CONST $REG_RESOURCE_LIST = 8
GLOBAL CONST $REG_FULL_RESOURCE_DESCRIPTOR = 9
GLOBAL CONST $REG_RESOURCE_REQUIREMENTS_LIST = 10
GLOBAL CONST $REG_QWORD = 11
GLOBAL CONST $REG_QWORD_LITTLE_ENDIAN = 11
GLOBAL CONST $HWND_BOTTOM = 1
GLOBAL CONST $HWND_NOTOPMOST = -2
GLOBAL CONST $HWND_TOP = 0
GLOBAL CONST $HWND_TOPMOST = -1
GLOBAL CONST $SWP_NOSIZE = 1
GLOBAL CONST $SWP_NOMOVE = 2
GLOBAL CONST $SWP_NOZORDER = 4
GLOBAL CONST $SWP_NOREDRAW = 8
GLOBAL CONST $SWP_NOACTIVATE = 16
GLOBAL CONST $SWP_FRAMECHANGED = 32
GLOBAL CONST $SWP_DRAWFRAME = 32
GLOBAL CONST $SWP_SHOWWINDOW = 64
GLOBAL CONST $SWP_HIDEWINDOW = 128
GLOBAL CONST $SWP_NOCOPYBITS = 256
GLOBAL CONST $SWP_NOOWNERZORDER = 512
GLOBAL CONST $SWP_NOREPOSITION = 512
GLOBAL CONST $SWP_NOSENDCHANGING = 1024
GLOBAL CONST $SWP_DEFERERASE = 8192
GLOBAL CONST $SWP_ASYNCWINDOWPOS = 16384
GLOBAL CONST $KEYWORD_DEFAULT = 1
GLOBAL CONST $KEYWORD_NULL = 2
GLOBAL CONST $DECLARED_LOCAL = -1
GLOBAL CONST $DECLARED_UNKNOWN = 0
GLOBAL CONST $DECLARED_GLOBAL = 1
GLOBAL CONST $ASSIGN_CREATE = 0
GLOBAL CONST $ASSIGN_FORCELOCAL = 1
GLOBAL CONST $ASSIGN_FORCEGLOBAL = 2
GLOBAL CONST $ASSIGN_EXISTFAIL = 4
GLOBAL CONST $BI_ENABLE = 0
GLOBAL CONST $BI_DISABLE = 1
GLOBAL CONST $BREAK_ENABLE = 1
GLOBAL CONST $BREAK_DISABLE = 0
GLOBAL CONST $CDTRAY_OPEN = "open"
GLOBAL CONST $CDTRAY_CLOSED = "closed"
GLOBAL CONST $SEND_DEFAULT = 0
GLOBAL CONST $SEND_RAW = 1
GLOBAL CONST $DIR_DEFAULT = 0
GLOBAL CONST $DIR_EXTENDED = 1
GLOBAL CONST $DIR_NORECURSE = 2
GLOBAL CONST $DIR_REMOVE = 1
GLOBAL CONST $DT_ALL = "ALL"
GLOBAL CONST $DT_CDROM = "CDROM"
GLOBAL CONST $DT_REMOVABLE = "REMOVABLE"
GLOBAL CONST $DT_FIXED = "FIXED"
GLOBAL CONST $DT_NETWORK = "NETWORK"
GLOBAL CONST $DT_RAMDISK = "RAMDISK"
GLOBAL CONST $DT_UNKNOWN = "UNKNOWN"
GLOBAL CONST $DT_UNDEFINED = 1
GLOBAL CONST $DT_FAT = "FAT"
GLOBAL CONST $DT_FAT32 = "FAT32"
GLOBAL CONST $DT_EXFAT = "exFAT"
GLOBAL CONST $DT_NTFS = "NTFS"
GLOBAL CONST $DT_NWFS = "NWFS"
GLOBAL CONST $DT_CDFS = "CDFS"
GLOBAL CONST $DT_UDF = "UDF"
GLOBAL CONST $DMA_DEFAULT = 0
GLOBAL CONST $DMA_PERSISTENT = 1
GLOBAL CONST $DMA_AUTHENTICATION = 8
GLOBAL CONST $DS_UNKNOWN = "UNKNOWN"
GLOBAL CONST $DS_READY = "READY"
GLOBAL CONST $DS_NOTREADY = "NOTREADY"
GLOBAL CONST $DS_INVALID = "INVALID"
GLOBAL CONST $MOUSE_CLICK_LEFT = "left"
GLOBAL CONST $MOUSE_CLICK_RIGHT = "right"
GLOBAL CONST $MOUSE_CLICK_MIDDLE = "middle"
GLOBAL CONST $MOUSE_CLICK_MAIN = "main"
GLOBAL CONST $MOUSE_CLICK_MENU = "menu"
GLOBAL CONST $MOUSE_CLICK_PRIMARY = "primary"
GLOBAL CONST $MOUSE_CLICK_SECONDARY = "secondary"
GLOBAL CONST $MOUSE_WHEEL_UP = "up"
GLOBAL CONST $MOUSE_WHEEL_DOWN = "down"
GLOBAL CONST $NUMBER_AUTO = 0
GLOBAL CONST $NUMBER_32BIT = 1
GLOBAL CONST $NUMBER_64BIT = 2
GLOBAL CONST $NUMBER_DOUBLE = 3
GLOBAL CONST $OBJ_NAME = 1
GLOBAL CONST $OBJ_STRING = 2
GLOBAL CONST $OBJ_PROGID = 3
GLOBAL CONST $OBJ_FILE = 4
GLOBAL CONST $OBJ_MODULE = 5
GLOBAL CONST $OBJ_CLSID = 6
GLOBAL CONST $OBJ_IID = 7
GLOBAL CONST $EXITCLOSE_NORMAL = 0
GLOBAL CONST $EXITCLOSE_BYEXIT = 1
GLOBAL CONST $EXITCLOSE_BYCLICK = 2
GLOBAL CONST $EXITCLOSE_BYLOGOFF = 3
GLOBAL CONST $EXITCLOSE_BYSHUTDOWN = 4
GLOBAL CONST $PROCESS_STATS_MEMORY = 0
GLOBAL CONST $PROCESS_STATS_IO = 1
GLOBAL CONST $PROCESS_LOW = 0
GLOBAL CONST $PROCESS_BELOWNORMAL = 1
GLOBAL CONST $PROCESS_NORMAL = 2
GLOBAL CONST $PROCESS_ABOVENORMAL = 3
GLOBAL CONST $PROCESS_HIGH = 4
GLOBAL CONST $PROCESS_REALTIME = 5
GLOBAL CONST $RUN_LOGON_NOPROFILE = 0
GLOBAL CONST $RUN_LOGON_PROFILE = 1
GLOBAL CONST $RUN_LOGON_NETWORK = 2
GLOBAL CONST $RUN_LOGON_INHERIT = 4
GLOBAL CONST $SOUND_NOWAIT = 0
GLOBAL CONST $SOUND_WAIT = 1
GLOBAL CONST $SHEX_OPEN = "open"
GLOBAL CONST $SHEX_EDIT = "edit"
GLOBAL CONST $SHEX_PRINT = "print"
GLOBAL CONST $SHEX_PROPERTIES = "properties"
GLOBAL CONST $TCP_DATA_DEFAULT = 0
GLOBAL CONST $TCP_DATA_BINARY = 1
GLOBAL CONST $UDP_OPEN_DEFAULT = 0
GLOBAL CONST $UDP_OPEN_BROADCAST = 1
GLOBAL CONST $UDP_DATA_DEFAULT = 0
GLOBAL CONST $UDP_DATA_BINARY = 1
GLOBAL CONST $UDP_DATA_ARRAY = 2
GLOBAL CONST $TIP_NOICON = 0
GLOBAL CONST $TIP_INFOICON = 1
GLOBAL CONST $TIP_WARNINGICON = 2
GLOBAL CONST $TIP_ERRORICON = 3
GLOBAL CONST $TIP_BALLOON = 1
GLOBAL CONST $TIP_CENTER = 2
GLOBAL CONST $TIP_FORCEVISIBLE = 4
GLOBAL CONST $WINDOWS_NOONTOP = 0
GLOBAL CONST $WINDOWS_ONTOP = 1
GLOBAL CONST $WIN_STATE_EXISTS = 1
GLOBAL CONST $WIN_STATE_VISIBLE = 2
GLOBAL CONST $WIN_STATE_ENABLED = 4
GLOBAL CONST $WIN_STATE_ACTIVE = 8
GLOBAL CONST $WIN_STATE_MINIMIZED = 16
GLOBAL CONST $WIN_STATE_MAXIMIZED = 32
GLOBAL CONST $FC_NOOVERWRITE = 0
GLOBAL CONST $FC_OVERWRITE = 1
GLOBAL CONST $FC_CREATEPATH = 8
GLOBAL CONST $FT_MODIFIED = 0
GLOBAL CONST $FT_CREATED = 1
GLOBAL CONST $FT_ACCESSED = 2
GLOBAL CONST $FT_ARRAY = 0
GLOBAL CONST $FT_STRING = 1
GLOBAL CONST $FT_MSEC = 2
GLOBAL CONST $FT_UTC = 4
GLOBAL CONST $FSF_CREATEBUTTON = 1
GLOBAL CONST $FSF_NEWDIALOG = 2
GLOBAL CONST $FSF_EDITCONTROL = 4
GLOBAL CONST $FT_NONRECURSIVE = 0
GLOBAL CONST $FT_RECURSIVE = 1
GLOBAL CONST $FO_READ = 0
GLOBAL CONST $FO_APPEND = 1
GLOBAL CONST $FO_OVERWRITE = 2
GLOBAL CONST $FO_CREATEPATH = 8
GLOBAL CONST $FO_BINARY = 16
GLOBAL CONST $FO_UNICODE = 32
GLOBAL CONST $FO_UTF16_LE = 32
GLOBAL CONST $FO_UTF16_BE = 64
GLOBAL CONST $FO_UTF8 = 128
GLOBAL CONST $FO_UTF8_NOBOM = 256
GLOBAL CONST $FO_ANSI = 512
GLOBAL CONST $FO_UTF16_LE_NOBOM = 1024
GLOBAL CONST $FO_UTF16_BE_NOBOM = 2048
GLOBAL CONST $FO_UTF8_FULL = 16384
GLOBAL CONST $FO_FULLFILE_DETECT = 16384
GLOBAL CONST $EOF = -1
GLOBAL CONST $FD_FILEMUSTEXIST = 1
GLOBAL CONST $FD_PATHMUSTEXIST = 2
GLOBAL CONST $FD_MULTISELECT = 4
GLOBAL CONST $FD_PROMPTCREATENEW = 8
GLOBAL CONST $FD_PROMPTOVERWRITE = 16
GLOBAL CONST $CREATE_NEW = 1
GLOBAL CONST $CREATE_ALWAYS = 2
GLOBAL CONST $OPEN_EXISTING = 3
GLOBAL CONST $OPEN_ALWAYS = 4
GLOBAL CONST $TRUNCATE_EXISTING = 5
GLOBAL CONST $INVALID_SET_FILE_POINTER = -1
GLOBAL CONST $FILE_BEGIN = 0
GLOBAL CONST $FILE_CURRENT = 1
GLOBAL CONST $FILE_END = 2
GLOBAL CONST $FILE_ATTRIBUTE_READONLY = 1
GLOBAL CONST $FILE_ATTRIBUTE_HIDDEN = 2
GLOBAL CONST $FILE_ATTRIBUTE_SYSTEM = 4
GLOBAL CONST $FILE_ATTRIBUTE_DIRECTORY = 16
GLOBAL CONST $FILE_ATTRIBUTE_ARCHIVE = 32
GLOBAL CONST $FILE_ATTRIBUTE_DEVICE = 64
GLOBAL CONST $FILE_ATTRIBUTE_NORMAL = 128
GLOBAL CONST $FILE_ATTRIBUTE_TEMPORARY = 256
GLOBAL CONST $FILE_ATTRIBUTE_SPARSE_FILE = 512
GLOBAL CONST $FILE_ATTRIBUTE_REPARSE_POINT = 1024
GLOBAL CONST $FILE_ATTRIBUTE_COMPRESSED = 2048
GLOBAL CONST $FILE_ATTRIBUTE_OFFLINE = 4096
GLOBAL CONST $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192
GLOBAL CONST $FILE_ATTRIBUTE_ENCRYPTED = 16384
GLOBAL CONST $FILE_SHARE_READ = 1
GLOBAL CONST $FILE_SHARE_WRITE = 2
GLOBAL CONST $FILE_SHARE_DELETE = 4
GLOBAL CONST $FILE_SHARE_READWRITE = BITOR($FILE_SHARE_READ, $FILE_SHARE_WRITE)
GLOBAL CONST $FILE_SHARE_ANY = BITOR($FILE_SHARE_READ, $FILE_SHARE_WRITE, $FILE_SHARE_DELETE)
GLOBAL CONST $GENERIC_ALL = 268435456
GLOBAL CONST $GENERIC_EXECUTE = 536870912
GLOBAL CONST $GENERIC_WRITE = 1073741824
GLOBAL CONST $GENERIC_READ = -2147483648
GLOBAL CONST $GENERIC_READWRITE = BITOR($GENERIC_READ, $GENERIC_WRITE)
GLOBAL CONST $FILE_ENCODING_UTF16LE = 32
GLOBAL CONST $FE_ENTIRE_UTF8 = 1
GLOBAL CONST $FE_PARTIALFIRST_UTF8 = 2
GLOBAL CONST $FN_FULLPATH = 0
GLOBAL CONST $FN_RELATIVEPATH = 1
GLOBAL CONST $FV_COMMENTS = "Comments"
GLOBAL CONST $FV_COMPANYNAME = "CompanyName"
GLOBAL CONST $FV_FILEDESCRIPTION = "FileDescription"
GLOBAL CONST $FV_FILEVERSION = "FileVersion"
GLOBAL CONST $FV_INTERNALNAME = "InternalName"
GLOBAL CONST $FV_LEGALCOPYRIGHT = "LegalCopyright"
GLOBAL CONST $FV_LEGALTRADEMARKS = "LegalTrademarks"
GLOBAL CONST $FV_ORIGINALFILENAME = "OriginalFilename"
GLOBAL CONST $FV_PRODUCTNAME = "ProductName"
GLOBAL CONST $FV_PRODUCTVERSION = "ProductVersion"
GLOBAL CONST $FV_PRIVATEBUILD = "PrivateBuild"
GLOBAL CONST $FV_SPECIALBUILD = "SpecialBuild"
GLOBAL CONST $FRTA_NOCOUNT = 0
GLOBAL CONST $FRTA_COUNT = 1
GLOBAL CONST $FRTA_INTARRAYS = 2
GLOBAL CONST $FRTA_ENTIRESPLIT = 4
GLOBAL CONST $FLTA_FILESFOLDERS = 0
GLOBAL CONST $FLTA_FILES = 1
GLOBAL CONST $FLTA_FOLDERS = 2
GLOBAL CONST $FLTAR_FILESFOLDERS = 0
GLOBAL CONST $FLTAR_FILES = 1
GLOBAL CONST $FLTAR_FOLDERS = 2
GLOBAL CONST $FLTAR_NOHIDDEN = 4
GLOBAL CONST $FLTAR_NOSYSTEM = 8
GLOBAL CONST $FLTAR_NOLINK = 16
GLOBAL CONST $FLTAR_NORECUR = 0
GLOBAL CONST $FLTAR_RECUR = 1
GLOBAL CONST $FLTAR_NOSORT = 0
GLOBAL CONST $FLTAR_SORT = 1
GLOBAL CONST $FLTAR_FASTSORT = 2
GLOBAL CONST $FLTAR_NOPATH = 0
GLOBAL CONST $FLTAR_RELPATH = 1
GLOBAL CONST $FLTAR_FULLPATH = 2
GLOBAL CONST $PATH_ORIGINAL = 0
GLOBAL CONST $PATH_DRIVE = 1
GLOBAL CONST $PATH_DIRECTORY = 2
GLOBAL CONST $PATH_FILENAME = 3
GLOBAL CONST $PATH_EXTENSION = 4
GLOBAL CONST $MB_OK = 0
GLOBAL CONST $MB_OKCANCEL = 1
GLOBAL CONST $MB_ABORTRETRYIGNORE = 2
GLOBAL CONST $MB_YESNOCANCEL = 3
GLOBAL CONST $MB_YESNO = 4
GLOBAL CONST $MB_RETRYCANCEL = 5
GLOBAL CONST $MB_CANCELTRYCONTINUE = 6
GLOBAL CONST $MB_HELP = 16384
GLOBAL CONST $MB_ICONNONE = 0
GLOBAL CONST $MB_ICONSTOP = 16
GLOBAL CONST $MB_ICONERROR = 16
GLOBAL CONST $MB_ICONHAND = 16
GLOBAL CONST $MB_ICONQUESTION = 32
GLOBAL CONST $MB_ICONEXCLAMATION = 48
GLOBAL CONST $MB_ICONWARNING = 48
GLOBAL CONST $MB_ICONINFORMATION = 64
GLOBAL CONST $MB_ICONASTERISK = 64
GLOBAL CONST $MB_USERICON = 128
GLOBAL CONST $MB_DEFBUTTON1 = 0
GLOBAL CONST $MB_DEFBUTTON2 = 256
GLOBAL CONST $MB_DEFBUTTON3 = 512
GLOBAL CONST $MB_DEFBUTTON4 = 768
GLOBAL CONST $MB_APPLMODAL = 0
GLOBAL CONST $MB_SYSTEMMODAL = 4096
GLOBAL CONST $MB_TASKMODAL = 8192
GLOBAL CONST $MB_DEFAULT_DESKTOP_ONLY = 131072
GLOBAL CONST $MB_RIGHT = 524288
GLOBAL CONST $MB_RTLREADING = 1048576
GLOBAL CONST $MB_SETFOREGROUND = 65536
GLOBAL CONST $MB_TOPMOST = 262144
GLOBAL CONST $MB_SERVICE_NOTIFICATION = 2097152
GLOBAL CONST $MB_RIGHTJUSTIFIED = $MB_RIGHT
GLOBAL CONST $IDTIMEOUT = -1
GLOBAL CONST $IDOK = 1
GLOBAL CONST $IDCANCEL = 2
GLOBAL CONST $IDABORT = 3
GLOBAL CONST $IDRETRY = 4
GLOBAL CONST $IDIGNORE = 5
GLOBAL CONST $IDYES = 6
GLOBAL CONST $IDNO = 7
GLOBAL CONST $IDCLOSE = 8
GLOBAL CONST $IDHELP = 9
GLOBAL CONST $IDTRYAGAIN = 10
GLOBAL CONST $IDCONTINUE = 11
GLOBAL CONST $SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
GLOBAL CONST $SE_AUDIT_NAME = "SeAuditPrivilege"
GLOBAL CONST $SE_BACKUP_NAME = "SeBackupPrivilege"
GLOBAL CONST $SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
GLOBAL CONST $SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege"
GLOBAL CONST $SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
GLOBAL CONST $SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
GLOBAL CONST $SE_CREATE_SYMBOLIC_LINK_NAME = "SeCreateSymbolicLinkPrivilege"
GLOBAL CONST $SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
GLOBAL CONST $SE_DEBUG_NAME = "SeDebugPrivilege"
GLOBAL CONST $SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege"
GLOBAL CONST $SE_IMPERSONATE_NAME = "SeImpersonatePrivilege"
GLOBAL CONST $SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
GLOBAL CONST $SE_INC_WORKING_SET_NAME = "SeIncreaseWorkingSetPrivilege"
GLOBAL CONST $SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
GLOBAL CONST $SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
GLOBAL CONST $SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
GLOBAL CONST $SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
GLOBAL CONST $SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege"
GLOBAL CONST $SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
GLOBAL CONST $SE_RELABEL_NAME = "SeRelabelPrivilege"
GLOBAL CONST $SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"
GLOBAL CONST $SE_RESTORE_NAME = "SeRestorePrivilege"
GLOBAL CONST $SE_SECURITY_NAME = "SeSecurityPrivilege"
GLOBAL CONST $SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
GLOBAL CONST $SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege"
GLOBAL CONST $SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
GLOBAL CONST $SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
GLOBAL CONST $SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
GLOBAL CONST $SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
GLOBAL CONST $SE_TCB_NAME = "SeTcbPrivilege"
GLOBAL CONST $SE_TIME_ZONE_NAME = "SeTimeZonePrivilege"
GLOBAL CONST $SE_TRUSTED_CREDMAN_ACCESS_NAME = "SeTrustedCredManAccessPrivilege"
GLOBAL CONST $SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
GLOBAL CONST $SE_UNDOCK_NAME = "SeUndockPrivilege"
GLOBAL CONST $SE_PRIVILEGE_ENABLED_BY_DEFAULT = 1
GLOBAL CONST $SE_PRIVILEGE_ENABLED = 2
GLOBAL CONST $SE_PRIVILEGE_REMOVED = 4
GLOBAL CONST $SE_PRIVILEGE_USED_FOR_ACCESS = -2147483648
GLOBAL CONST $SE_GROUP_MANDATORY = 1
GLOBAL CONST $SE_GROUP_ENABLED_BY_DEFAULT = 2
GLOBAL CONST $SE_GROUP_ENABLED = 4
GLOBAL CONST $SE_GROUP_OWNER = 8
GLOBAL CONST $SE_GROUP_USE_FOR_DENY_ONLY = 16
GLOBAL CONST $SE_GROUP_INTEGRITY = 32
GLOBAL CONST $SE_GROUP_INTEGRITY_ENABLED = 64
GLOBAL CONST $SE_GROUP_RESOURCE = 536870912
GLOBAL CONST $SE_GROUP_LOGON_ID = -1073741824
GLOBAL ENUM $TOKENPRIMARY = 1, $TOKENIMPERSONATION
GLOBAL ENUM $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
GLOBAL ENUM $TOKENUSER = 1, $TOKENGROUPS, $TOKENPRIVILEGES, $TOKENOWNER, $TOKENPRIMARYGROUP, $TOKENDEFAULTDACL, $TOKENSOURCE, $TOKENTYPE, $TOKENIMPERSONATIONLEVEL, $TOKENSTATISTICS, $TOKENRESTRICTEDSIDS, $TOKENSESSIONID, $TOKENGROUPSANDPRIVILEGES, $TOKENSESSIONREFERENCE, $TOKENSANDBOXINERT, $TOKENAUDITPOLICY, $TOKENORIGIN, $TOKENELEVATIONTYPE, $TOKENLINKEDTOKEN, $TOKENELEVATION, $TOKENHASRESTRICTIONS, $TOKENACCESSINFORMATION, $TOKENVIRTUALIZATIONALLOWED, $TOKENVIRTUALIZATIONENABLED, $TOKENINTEGRITYLEVEL, $TOKENUIACCESS, $TOKENMANDATORYPOLICY, $TOKENLOGONSID
GLOBAL CONST $TOKEN_ASSIGN_PRIMARY = 1
GLOBAL CONST $TOKEN_DUPLICATE = 2
GLOBAL CONST $TOKEN_IMPERSONATE = 4
GLOBAL CONST $TOKEN_QUERY = 8
GLOBAL CONST $TOKEN_QUERY_SOURCE = 16
GLOBAL CONST $TOKEN_ADJUST_PRIVILEGES = 32
GLOBAL CONST $TOKEN_ADJUST_GROUPS = 64
GLOBAL CONST $TOKEN_ADJUST_DEFAULT = 128
GLOBAL CONST $TOKEN_ADJUST_SESSIONID = 256
GLOBAL CONST $TOKEN_ALL_ACCESS = 983551
GLOBAL CONST $TOKEN_READ = 131080
GLOBAL CONST $TOKEN_WRITE = 131296
GLOBAL CONST $TOKEN_EXECUTE = 131072
GLOBAL CONST $TOKEN_HAS_TRAVERSE_PRIVILEGE = 1
GLOBAL CONST $TOKEN_HAS_BACKUP_PRIVILEGE = 2
GLOBAL CONST $TOKEN_HAS_RESTORE_PRIVILEGE = 4
GLOBAL CONST $TOKEN_HAS_ADMIN_GROUP = 8
GLOBAL CONST $TOKEN_IS_RESTRICTED = 16
GLOBAL CONST $TOKEN_SESSION_NOT_REFERENCED = 32
GLOBAL CONST $TOKEN_SANDBOX_INERT = 64
GLOBAL CONST $TOKEN_HAS_IMPERSONATE_PRIVILEGE = 128
GLOBAL CONST $STANDARD_RIGHTS_DELETE = 65536
GLOBAL CONST $READ_CONTROL = 131072
GLOBAL CONST $WRITE_DAC = 262144
GLOBAL CONST $WRITE_OWNER = 524288
GLOBAL CONST $STANDARD_RIGHTS_SYNCHRONIZE = 1048576
GLOBAL CONST $ACCESS_SYSTEM_SECURITY = 16777216
GLOBAL CONST $STANDARD_RIGHTS_REQUIRED = 983040
GLOBAL CONST $STANDARD_RIGHTS_READ = $READ_CONTROL
GLOBAL CONST $STANDARD_RIGHTS_WRITE = $READ_CONTROL
GLOBAL CONST $STANDARD_RIGHTS_EXECUTE = $READ_CONTROL
GLOBAL CONST $STANDARD_RIGHTS_ALL = 2031616
GLOBAL CONST $SPECIFIC_RIGHTS_ALL = 65535
GLOBAL ENUM $NOT_USED_ACCESS = 0, $GRANT_ACCESS, $SET_ACCESS, $DENY_ACCESS, $REVOKE_ACCESS, $SET_AUDIT_SUCCESS, $SET_AUDIT_FAILURE
GLOBAL ENUM $TRUSTEE_IS_UNKNOWN = 0, $TRUSTEE_IS_USER, $TRUSTEE_IS_GROUP, $TRUSTEE_IS_DOMAIN, $TRUSTEE_IS_ALIAS, $TRUSTEE_IS_WELL_KNOWN_GROUP, $TRUSTEE_IS_DELETED, $TRUSTEE_IS_INVALID, $TRUSTEE_IS_COMPUTER
GLOBAL CONST $LOGON_WITH_PROFILE = 1
GLOBAL CONST $LOGON_NETCREDENTIALS_ONLY = 2
GLOBAL ENUM $SIDTYPEUSER = 1, $SIDTYPEGROUP, $SIDTYPEDOMAIN, $SIDTYPEALIAS, $SIDTYPEWELLKNOWNGROUP, $SIDTYPEDELETEDACCOUNT, $SIDTYPEINVALID, $SIDTYPEUNKNOWN, $SIDTYPECOMPUTER, $SIDTYPELABEL
GLOBAL CONST $SID_ADMINISTRATORS = "S-1-5-32-544"
GLOBAL CONST $SID_USERS = "S-1-5-32-545"
GLOBAL CONST $SID_GUESTS = "S-1-5-32-546"
GLOBAL CONST $SID_ACCOUNT_OPERATORS = "S-1-5-32-548"
GLOBAL CONST $SID_SERVER_OPERATORS = "S-1-5-32-549"
GLOBAL CONST $SID_PRINT_OPERATORS = "S-1-5-32-550"
GLOBAL CONST $SID_BACKUP_OPERATORS = "S-1-5-32-551"
GLOBAL CONST $SID_REPLICATOR = "S-1-5-32-552"
GLOBAL CONST $SID_OWNER = "S-1-3-0"
GLOBAL CONST $SID_EVERYONE = "S-1-1-0"
GLOBAL CONST $SID_NETWORK = "S-1-5-2"
GLOBAL CONST $SID_INTERACTIVE = "S-1-5-4"
GLOBAL CONST $SID_SYSTEM = "S-1-5-18"
GLOBAL CONST $SID_AUTHENTICATED_USERS = "S-1-5-11"
GLOBAL CONST $SID_SCHANNEL_AUTHENTICATION = "S-1-5-64-14"
GLOBAL CONST $SID_DIGEST_AUTHENTICATION = "S-1-5-64-21"
GLOBAL CONST $SID_NT_SERVICE = "S-1-5-80"
GLOBAL CONST $SID_UNTRUSTED_MANDATORY_LEVEL = "S-1-16-0"
GLOBAL CONST $SID_LOW_MANDATORY_LEVEL = "S-1-16-4096"
GLOBAL CONST $SID_MEDIUM_MANDATORY_LEVEL = "S-1-16-8192"
GLOBAL CONST $SID_MEDIUM_PLUS_MANDATORY_LEVEL = "S-1-16-8448"
GLOBAL CONST $SID_HIGH_MANDATORY_LEVEL = "S-1-16-12288"
GLOBAL CONST $SID_SYSTEM_MANDATORY_LEVEL = "S-1-16-16384"
GLOBAL CONST $SID_PROTECTED_PROCESS_MANDATORY_LEVEL = "S-1-16-20480"
GLOBAL CONST $SID_SECURE_PROCESS_MANDATORY_LEVEL = "S-1-16-28672"
GLOBAL CONST $SID_ALL_SERVICES = "S-1-5-80-0"
GLOBAL CONST $STR_NOCASESENSE = 0
GLOBAL CONST $STR_CASESENSE = 1
GLOBAL CONST $STR_NOCASESENSEBASIC = 2
GLOBAL CONST $STR_STRIPLEADING = 1
GLOBAL CONST $STR_STRIPTRAILING = 2
GLOBAL CONST $STR_STRIPSPACES = 4
GLOBAL CONST $STR_STRIPALL = 8
GLOBAL CONST $STR_CHRSPLIT = 0
GLOBAL CONST $STR_ENTIRESPLIT = 1
GLOBAL CONST $STR_NOCOUNT = 2
GLOBAL CONST $STR_REGEXPMATCH = 0
GLOBAL CONST $STR_REGEXPARRAYMATCH = 1
GLOBAL CONST $STR_REGEXPARRAYFULLMATCH = 2
GLOBAL CONST $STR_REGEXPARRAYGLOBALMATCH = 3
GLOBAL CONST $STR_REGEXPARRAYGLOBALFULLMATCH = 4
GLOBAL CONST $STR_ENDISSTART = 0
GLOBAL CONST $STR_ENDNOTSTART = 1
GLOBAL CONST $SB_ANSI = 1
GLOBAL CONST $SB_UTF16LE = 2
GLOBAL CONST $SB_UTF16BE = 3
GLOBAL CONST $SB_UTF8 = 4
GLOBAL CONST $SE_UTF16 = 0
GLOBAL CONST $SE_ANSI = 1
GLOBAL CONST $SE_UTF8 = 2
GLOBAL CONST $STR_UTF16 = 0
GLOBAL CONST $STR_UCS2 = 1
#Region Global Variables and Constants
	GLOBAL CONST $FORMAT_MESSAGE_ALLOCATE_BUFFER = 256
	GLOBAL CONST $FORMAT_MESSAGE_IGNORE_INSERTS = 512
	GLOBAL CONST $FORMAT_MESSAGE_FROM_STRING = 1024
	GLOBAL CONST $FORMAT_MESSAGE_FROM_HMODULE = 2048
	GLOBAL CONST $FORMAT_MESSAGE_FROM_SYSTEM = 4096
	GLOBAL CONST $FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192
#EndRegion Global Variables and Constants
FUNC _WINAPI_BEEP($IFREQ = 500, $IDURATION = 1000)
	LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "Beep", "dword", $IFREQ, "dword", $IDURATION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ACALL[0]
ENDFUNC
FUNC _WINAPI_FORMATMESSAGE($IFLAGS, $PSOURCE, $IMESSAGEID, $ILANGUAGEID, BYREF $PBUFFER, $ISIZE, $VARGUMENTS)
	LOCAL $SBUFFERTYPE = "struct*"
	IF ISSTRING($PBUFFER) THEN $SBUFFERTYPE = "wstr"
	LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "FormatMessageW", "dword", $IFLAGS, "struct*", $PSOURCE, "dword", $IMESSAGEID, "dword", $ILANGUAGEID, $SBUFFERTYPE, $PBUFFER, "dword", $ISIZE, "ptr", $VARGUMENTS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
	IF $SBUFFERTYPE = "wstr" THEN $PBUFFER = $ACALL[5]
	RETURN $ACALL[0]
ENDFUNC
FUNC _WINAPI_GETERRORMESSAGE($ICODE, $ILANGUAGE = 0, CONST $_ICALLERERROR = @ERROR, CONST $_ICALLEREXTENDED = @EXTENDED)
	LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "FormatMessageW", "dword", BITOR($FORMAT_MESSAGE_FROM_SYSTEM, $FORMAT_MESSAGE_IGNORE_INSERTS), "ptr", 0, "dword", $ICODE, "dword", $ILANGUAGE, "wstr", "", "dword", 4096, "ptr", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	RETURN SETERROR($_ICALLERERROR, $_ICALLEREXTENDED, STRINGREGEXPREPLACE($ACALL[5], "[" & @LF & "," & @CR & "]*\Z", ""))
ENDFUNC
FUNC _WINAPI_GETLASTERROR(CONST $_ICALLERERROR = @ERROR, CONST $_ICALLEREXTENDED = @EXTENDED)
	LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetLastError")
	RETURN SETERROR($_ICALLERERROR, $_ICALLEREXTENDED, $ACALL[0])
ENDFUNC
FUNC _WINAPI_GETLASTERRORMESSAGE(CONST $_ICALLERERROR = @ERROR, CONST $_ICALLEREXTENDED = @EXTENDED)
	LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
	LOCAL $TBUFFERPTR = DLLSTRUCTCREATE("ptr")
	LOCAL $NCOUNT = _WINAPI_FORMATMESSAGE(BITOR($FORMAT_MESSAGE_ALLOCATE_BUFFER, $FORMAT_MESSAGE_FROM_SYSTEM, $FORMAT_MESSAGE_IGNORE_INSERTS), 0, $ILASTERROR, 0, $TBUFFERPTR, 0, 0)
	IF @ERROR THEN RETURN SETERROR(-@ERROR, @EXTENDED, "")
	LOCAL $STEXT = ""
	LOCAL $PBUFFER = DLLSTRUCTGETDATA($TBUFFERPTR, 1)
	IF $PBUFFER THEN
		IF $NCOUNT > 0 THEN
			LOCAL $TBUFFER = DLLSTRUCTCREATE("wchar[" & ($NCOUNT + 1) & "]", $PBUFFER)
			$STEXT = DLLSTRUCTGETDATA($TBUFFER, 1)
			IF STRINGRIGHT($STEXT, 2) = @CRLF THEN $STEXT = STRINGTRIMRIGHT($STEXT, 2)
		ENDIF
		DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $PBUFFER)
	ENDIF
	RETURN SETERROR($_ICALLERERROR, $_ICALLEREXTENDED, $STEXT)
ENDFUNC
FUNC _WINAPI_MESSAGEBEEP($ITYPE = 1)
	LOCAL $ISOUND
	SWITCH $ITYPE
		CASE 1
			$ISOUND = 0
		CASE 2
			$ISOUND = 16
		CASE 3
			$ISOUND = 32
		CASE 4
			$ISOUND = 48
		CASE 5
			$ISOUND = 64
		CASE ELSE
			$ISOUND = -1
	ENDSWITCH
	LOCAL $ACALL = DLLCALL("user32.dll", "bool", "MessageBeep", "uint", $ISOUND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ACALL[0]
ENDFUNC
FUNC _WINAPI_MSGBOX($IFLAGS, $STITLE, $STEXT)
	BLOCKINPUT(0)
	MSGBOX($IFLAGS, $STITLE, $STEXT & "      ")
ENDFUNC
FUNC _WINAPI_SETLASTERROR($IERRORCODE, CONST $_ICALLERERROR = @ERROR, CONST $_ICALLEREXTENDED = @EXTENDED)
	DLLCALL("kernel32.dll", "none", "SetLastError", "dword", $IERRORCODE)
	RETURN SETERROR($_ICALLERERROR, $_ICALLEREXTENDED, NULL)
ENDFUNC
FUNC _WINAPI_SHOWERROR($STEXT, $BEXIT = TRUE)
	BLOCKINPUT(0)
	MSGBOX($MB_SYSTEMMODAL, "Error", $STEXT & "      ")
	IF $BEXIT THEN EXIT
ENDFUNC
FUNC _WINAPI_SHOWLASTERROR($STEXT = "", $BABORT = FALSE, $ILANGUAGE = 0, CONST $_ICALLERERROR = @ERROR, CONST $_ICALLEREXTENDED = @EXTENDED)
	LOCAL $SERROR
	LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
	WHILE 1
		$SERROR = _WINAPI_GETERRORMESSAGE($ILASTERROR, $ILANGUAGE)
		IF @ERROR AND $ILANGUAGE THEN
			$ILANGUAGE = 0
		ELSE
			EXITLOOP
		ENDIF
	WEND
	IF STRINGSTRIPWS($STEXT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
		$STEXT &= @CRLF & @CRLF
	ELSE
		$STEXT = ""
	ENDIF
	_WINAPI_MSGBOX(BITOR(262144, BITSHIFT(16, -2 * (NOT $ILASTERROR))), $ILASTERROR, $STEXT & $SERROR)
	IF $ILASTERROR THEN
		_WINAPI_SETLASTERROR($ILASTERROR)
		IF $BABORT THEN
			EXIT $ILASTERROR
		ENDIF
	ENDIF
	RETURN SETERROR($_ICALLERERROR, $_ICALLEREXTENDED, 1)
ENDFUNC
FUNC _WINAPI_SHOWMSG($STEXT)
	_WINAPI_MSGBOX($MB_SYSTEMMODAL, "Information", $STEXT)
ENDFUNC
FUNC __COMERRORFORMATING(BYREF $OCOMERROR, $SPREFIX = @TAB)
	LOCAL CONST $STR_STRIPTRAILING = 2
	LOCAL $SERROR = "COM Error encountered in " & @SCRIPTNAME & " (" & $OCOMERROR.Scriptline & ") :" & @CRLF & $SPREFIX & "Number        " & @TAB & "= 0x" & HEX($OCOMERROR.Number, 8) & " (" & $OCOMERROR.Number & ")" & @CRLF & $SPREFIX & "WinDescription" & @TAB & "= " & STRINGSTRIPWS($OCOMERROR.WinDescription, $STR_STRIPTRAILING) & @CRLF & $SPREFIX & "Description   " & @TAB & "= " & STRINGSTRIPWS($OCOMERROR.Description, $STR_STRIPTRAILING) & @CRLF & $SPREFIX & "Source        " & @TAB & "= " & $OCOMERROR.Source & @CRLF & $SPREFIX & "HelpFile      " & @TAB & "= " & $OCOMERROR.HelpFile & @CRLF & $SPREFIX & "HelpContext   " & @TAB & "= " & $OCOMERROR.HelpContext & @CRLF & $SPREFIX & "LastDllError  " & @TAB & "= " & $OCOMERROR.LastDllError & @CRLF & $SPREFIX & "Retcode       " & @TAB & "= 0x" & HEX($OCOMERROR.retcode)
	RETURN $SERROR
ENDFUNC
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _SECURITY__ADJUSTTOKENPRIVILEGES($HTOKEN, $BDISABLEALL, $TNEWSTATE, $IBUFFERLEN, $TPREVSTATE = 0, $PREQUIRED = 0)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $HTOKEN, "bool", $BDISABLEALL, "struct*", $TNEWSTATE, "dword", $IBUFFERLEN, "struct*", $TPREVSTATE, "struct*", $PREQUIRED)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN NOT($ACALL[0] = 0)
	ENDFUNC
	FUNC _SECURITY__CREATEPROCESSWITHTOKEN($HTOKEN, $ILOGONFLAGS, $SCOMMANDLINE, $ICREATIONFLAGS, $SCURDIR, $TSTARTUPINFO, $TPROCESS_INFORMATION)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $HTOKEN, "dword", $ILOGONFLAGS, "ptr", 0, "wstr", $SCOMMANDLINE, "dword", $ICREATIONFLAGS, "struct*", 0, "wstr", $SCURDIR, "struct*", $TSTARTUPINFO, "struct*", $TPROCESS_INFORMATION)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		RETURN TRUE
	ENDFUNC
	FUNC _SECURITY__DUPLICATETOKENEX($HEXISTINGTOKEN, $IDESIREDACCESS, $IIMPERSONATIONLEVEL, $ITOKENTYPE)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $HEXISTINGTOKEN, "dword", $IDESIREDACCESS, "struct*", 0, "int", $IIMPERSONATIONLEVEL, "int", $ITOKENTYPE, "handle*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[6]
	ENDFUNC
	FUNC _SECURITY__GETACCOUNTSID($SACCOUNT, $SSYSTEM = "")
		LOCAL $AACCT = _SECURITY__LOOKUPACCOUNTNAME($SACCOUNT, $SSYSTEM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF ISARRAY($AACCT) THEN RETURN _SECURITY__STRINGSIDTOSID($AACCT[0])
		RETURN ""
	ENDFUNC
	FUNC _SECURITY__GETLENGTHSID($PSID)
		IF NOT _SECURITY__ISVALIDSID($PSID) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "dword", "GetLengthSid", "struct*", $PSID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _SECURITY__GETTOKENINFORMATION($HTOKEN, $ICLASS)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "int", $ICLASS, "struct*", 0, "dword", 0, "dword*", 0)
		IF @ERROR OR NOT $ACALL[5] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ILEN = $ACALL[5]
		LOCAL $TBUFFER = DLLSTRUCTCREATE("byte[" & $ILEN & "]")
		$ACALL = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "int", $ICLASS, "struct*", $TBUFFER, "dword", DLLSTRUCTGETSIZE($TBUFFER), "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TBUFFER
	ENDFUNC
	FUNC _SECURITY__IMPERSONATESELF($ILEVEL = $SECURITYIMPERSONATION)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "ImpersonateSelf", "int", $ILEVEL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN NOT($ACALL[0] = 0)
	ENDFUNC
	FUNC _SECURITY__ISVALIDSID($PSID)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "IsValidSid", "struct*", $PSID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN NOT($ACALL[0] = 0)
	ENDFUNC
	FUNC _SECURITY__LOOKUPACCOUNTNAME($SACCOUNT, $SSYSTEM = "")
		LOCAL $TDATA = DLLSTRUCTCREATE("byte SID[256]")
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $SSYSTEM, "wstr", $SACCOUNT, "struct*", $TDATA, "dword*", DLLSTRUCTGETSIZE($TDATA), "wstr", "", "dword*", DLLSTRUCTGETSIZE($TDATA), "int*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $AACCT[3]
		$AACCT[0] = _SECURITY__SIDTOSTRINGSID(DLLSTRUCTGETPTR($TDATA, "SID"))
		$AACCT[1] = $ACALL[5]
		$AACCT[2] = $ACALL[7]
		RETURN $AACCT
	ENDFUNC
	FUNC _SECURITY__LOOKUPACCOUNTSID($VSID, $SSYSTEM = "")
		LOCAL $PSID, $AACCT[3]
		IF ISSTRING($VSID) THEN
			$PSID = _SECURITY__STRINGSIDTOSID($VSID)
		ELSE
			$PSID = $VSID
		ENDIF
		IF NOT _SECURITY__ISVALIDSID($PSID) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		IF $SSYSTEM = "" THEN $SSYSTEM = NULL
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "LookupAccountSidW", "wstr", $SSYSTEM, "struct*", $PSID, "wstr", "", "dword*", 65536, "wstr", "", "dword*", 65536, "int*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $AACCT[3]
		$AACCT[0] = $ACALL[3]
		$AACCT[1] = $ACALL[5]
		$AACCT[2] = $ACALL[7]
		RETURN $AACCT
	ENDFUNC
	FUNC _SECURITY__LOOKUPPRIVILEGEVALUE($SSYSTEM, $SNAME)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $SSYSTEM, "wstr", $SNAME, "int64*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _SECURITY__OPENPROCESSTOKEN($HPROCESS, $IACCESS)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "OpenProcessToken", "handle", $HPROCESS, "dword", $IACCESS, "handle*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _SECURITY__OPENTHREADTOKEN($IACCESS, $HTHREAD = 0, $BOPENASSELF = FALSE)
		LOCAL $ACALL
		IF $HTHREAD = 0 THEN
			$ACALL = DLLCALL("kernel32.dll", "handle", "GetCurrentThread")
			IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
			$HTHREAD = $ACALL[0]
		ENDIF
		$ACALL = DLLCALL("advapi32.dll", "bool", "OpenThreadToken", "handle", $HTHREAD, "dword", $IACCESS, "bool", $BOPENASSELF, "handle*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[4]
	ENDFUNC
	FUNC _SECURITY__OPENTHREADTOKENEX($IACCESS, $HTHREAD = 0, $BOPENASSELF = FALSE)
		LOCAL $HTOKEN = _SECURITY__OPENTHREADTOKEN($IACCESS, $HTHREAD, $BOPENASSELF)
		IF $HTOKEN = 0 THEN
			LOCAL CONST $ERROR_NO_TOKEN = 1008
			IF _WINAPI_GETLASTERROR() <> $ERROR_NO_TOKEN THEN RETURN SETERROR(20, _WINAPI_GETLASTERROR(), 0)
			IF NOT _SECURITY__IMPERSONATESELF() THEN RETURN SETERROR(@ERROR + 10, _WINAPI_GETLASTERROR(), 0)
			$HTOKEN = _SECURITY__OPENTHREADTOKEN($IACCESS, $HTHREAD, $BOPENASSELF)
			IF $HTOKEN = 0 THEN RETURN SETERROR(@ERROR, _WINAPI_GETLASTERROR(), 0)
		ENDIF
		RETURN $HTOKEN
	ENDFUNC
	FUNC _SECURITY__SETPRIVILEGE($HTOKEN, $SPRIVILEGE, $BENABLE)
		LOCAL $ILUID = _SECURITY__LOOKUPPRIVILEGEVALUE("", $SPRIVILEGE)
		IF $ILUID = 0 THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		LOCAL CONST $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
		LOCAL $TCURRSTATE = DLLSTRUCTCREATE($TAGTOKEN_PRIVILEGES)
		LOCAL $ICURRSTATE = DLLSTRUCTGETSIZE($TCURRSTATE)
		LOCAL $TPREVSTATE = DLLSTRUCTCREATE($TAGTOKEN_PRIVILEGES)
		LOCAL $IPREVSTATE = DLLSTRUCTGETSIZE($TPREVSTATE)
		LOCAL $TREQUIRED = DLLSTRUCTCREATE("int Data")
		DLLSTRUCTSETDATA($TCURRSTATE, "Count", 1)
		DLLSTRUCTSETDATA($TCURRSTATE, "LUID", $ILUID)
		IF NOT _SECURITY__ADJUSTTOKENPRIVILEGES($HTOKEN, FALSE, $TCURRSTATE, $ICURRSTATE, $TPREVSTATE, $TREQUIRED) THEN RETURN SETERROR(2, @ERROR, FALSE)
		DLLSTRUCTSETDATA($TPREVSTATE, "Count", 1)
		DLLSTRUCTSETDATA($TPREVSTATE, "LUID", $ILUID)
		LOCAL $IATTRIBUTES = DLLSTRUCTGETDATA($TPREVSTATE, "Attributes")
		IF $BENABLE THEN
			$IATTRIBUTES = BITOR($IATTRIBUTES, $SE_PRIVILEGE_ENABLED)
		ELSE
			$IATTRIBUTES = BITAND($IATTRIBUTES, BITNOT($SE_PRIVILEGE_ENABLED))
		ENDIF
		DLLSTRUCTSETDATA($TPREVSTATE, "Attributes", $IATTRIBUTES)
		IF NOT _SECURITY__ADJUSTTOKENPRIVILEGES($HTOKEN, FALSE, $TPREVSTATE, $IPREVSTATE, $TCURRSTATE, $TREQUIRED) THEN RETURN SETERROR(3, @ERROR, FALSE)
		RETURN TRUE
	ENDFUNC
	FUNC _SECURITY__SETTOKENINFORMATION($HTOKEN, $ITOKENINFORMATION, $VTOKENINFORMATION, $ITOKENINFORMATIONLENGTH)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "SetTokenInformation", "handle", $HTOKEN, "int", $ITOKENINFORMATION, "struct*", $VTOKENINFORMATION, "dword", $ITOKENINFORMATIONLENGTH)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		RETURN TRUE
	ENDFUNC
	FUNC _SECURITY__SIDTOSTRINGSID($PSID)
		IF NOT _SECURITY__ISVALIDSID($PSID) THEN RETURN SETERROR(@ERROR + 10, 0, "")
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $PSID, "ptr*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		LOCAL $PSTRINGSID = $ACALL[2]
		LOCAL $ALEN = DLLCALL("kernel32.dll", "int", "lstrlenW", "struct*", $PSTRINGSID)
		LOCAL $SSID = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar Text[" & $ALEN[0] + 1 & "]", $PSTRINGSID), "Text")
		DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $PSTRINGSID)
		RETURN $SSID
	ENDFUNC
	FUNC _SECURITY__SIDTYPESTR($ITYPE)
		SWITCH $ITYPE
			CASE $SIDTYPEUSER
				RETURN "User"
			CASE $SIDTYPEGROUP
				RETURN "Group"
			CASE $SIDTYPEDOMAIN
				RETURN "Domain"
			CASE $SIDTYPEALIAS
				RETURN "Alias"
			CASE $SIDTYPEWELLKNOWNGROUP
				RETURN "Well Known Group"
			CASE $SIDTYPEDELETEDACCOUNT
				RETURN "Deleted Account"
			CASE $SIDTYPEINVALID
				RETURN "Invalid"
			CASE $SIDTYPEUNKNOWN
				RETURN "Unknown Type"
			CASE $SIDTYPECOMPUTER
				RETURN "Computer"
			CASE $SIDTYPELABEL
				RETURN "A mandatory integrity label SID"
			CASE ELSE
				RETURN "Unknown SID Type"
		ENDSWITCH
	ENDFUNC
	FUNC _SECURITY__STRINGSIDTOSID($SSID)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $SSID, "ptr*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $PSID = $ACALL[2]
		LOCAL $TBUFFER = DLLSTRUCTCREATE("byte Data[" & _SECURITY__GETLENGTHSID($PSID) & "]", $PSID)
		LOCAL $TSID = DLLSTRUCTCREATE("byte Data[" & DLLSTRUCTGETSIZE($TBUFFER) & "]")
		DLLSTRUCTSETDATA($TSID, "Data", DLLSTRUCTGETDATA($TBUFFER, "Data"))
		DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $PSID)
		RETURN $TSID
	ENDFUNC
#EndRegion Public Functions
FUNC _SENDMESSAGE($HWND, $IMSG, $WPARAM = 0, $LPARAM = 0, $IRETURN = 0, $WPARAMTYPE = "wparam", $LPARAMTYPE = "lparam", $SRETURNTYPE = "lresult")
	LOCAL $ACALL = DLLCALL("user32.dll", $SRETURNTYPE, "SendMessageW", "hwnd", $HWND, "uint", $IMSG, $WPARAMTYPE, $WPARAM, $LPARAMTYPE, $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	IF $IRETURN >= 0 AND $IRETURN <= 4 THEN RETURN $ACALL[$IRETURN]
	RETURN $ACALL
ENDFUNC
FUNC _SENDMESSAGEA($HWND, $IMSG, $WPARAM = 0, $LPARAM = 0, $IRETURN = 0, $WPARAMTYPE = "wparam", $LPARAMTYPE = "lparam", $SRETURNTYPE = "lresult")
	LOCAL $ACALL = DLLCALL("user32.dll", $SRETURNTYPE, "SendMessageA", "hwnd", $HWND, "uint", $IMSG, $WPARAMTYPE, $WPARAM, $LPARAMTYPE, $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	IF $IRETURN >= 0 AND $IRETURN <= 4 THEN RETURN $ACALL[$IRETURN]
	RETURN $ACALL
ENDFUNC
GLOBAL CONST $TAGPOINT = "struct;long X;long Y;endstruct"
GLOBAL CONST $TAGRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
GLOBAL CONST $TAGSIZE = "struct;long X;long Y;endstruct"
GLOBAL CONST $TAGMARGINS = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
GLOBAL CONST $TAGFILETIME = "struct;dword Lo;dword Hi;endstruct"
GLOBAL CONST $TAGSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
GLOBAL CONST $TAGTIME_ZONE_INFORMATION = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
GLOBAL CONST $TAGNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
GLOBAL CONST $TAGCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
GLOBAL CONST $TAGNMCBEDRAGBEGIN = $TAGNMHDR & ";int ItemID;wchar szText[260]"
GLOBAL CONST $TAGNMCBEENDEDIT = $TAGNMHDR & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
GLOBAL CONST $TAGNMCOMBOBOXEX = $TAGNMHDR & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" & "int SelectedImage;int OverlayImage;int Indent;lparam Param"
GLOBAL CONST $TAGDTPRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" & "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
GLOBAL CONST $TAGNMDATETIMECHANGE = $TAGNMHDR & ";dword Flag;" & $TAGSYSTEMTIME
GLOBAL CONST $TAGNMDATETIMEFORMAT = $TAGNMHDR & ";ptr Format;" & $TAGSYSTEMTIME & ";ptr pDisplay;wchar Display[64]"
GLOBAL CONST $TAGNMDATETIMEFORMATQUERY = $TAGNMHDR & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
GLOBAL CONST $TAGNMDATETIMEKEYDOWN = $TAGNMHDR & ";int VirtKey;ptr Format;" & $TAGSYSTEMTIME
GLOBAL CONST $TAGNMDATETIMESTRING = $TAGNMHDR & ";ptr UserString;" & $TAGSYSTEMTIME & ";dword Flags"
GLOBAL CONST $TAGEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_BLUR = "float Radius; bool ExpandEdge"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_BRIGHTNESSCONTRAST = "int BrightnessLevel; int ContrastLevel"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_COLORBALANCE = "int CyanRed; int MagentaGreen; int YellowBlue"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_COLORCURVE = "int Adjustment; int Channel; int AdjustValue"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_COLORLUT = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_HUESATURATIONLIGHTNESS = "int HueLevel; int SaturationLevel; int LightnessLevel"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_LEVELS = "int Highlight; int Midtone; int Shadow"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_REDEYECORRECTION = "uint NumberOfAreas; ptr Areas"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_SHARPEN = "float Radius; float Amount"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_TINT = "int Hue; int Amount"
GLOBAL CONST $TAGGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
GLOBAL CONST $TAGGDIPCOLORMATRIX = "float m[25]"
GLOBAL CONST $TAGGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
GLOBAL CONST $TAGGDIPENCODERPARAMS = "uint Count;" & $TAGGDIPENCODERPARAM
GLOBAL CONST $TAGGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
GLOBAL CONST $TAGGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
GLOBAL CONST $TAGGDIPSTARTUPOUTPUT = "ptr HookProc;ptr UnhookProc"
GLOBAL CONST $TAGGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
GLOBAL CONST $TAGGDIPPENCODERPARAMS = "uint Count;byte Params[1]"
GLOBAL CONST $TAGHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
GLOBAL CONST $TAGNMHDDISPINFO = $TAGNMHDR & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
GLOBAL CONST $TAGNMHDFILTERBTNCLICK = $TAGNMHDR & ";int Item;" & $TAGRECT
GLOBAL CONST $TAGNMHEADER = $TAGNMHDR & ";int Item;int Button;ptr pItem"
GLOBAL CONST $TAGGETIPADDRESS = "byte Field4;byte Field3;byte Field2;byte Field1"
GLOBAL CONST $TAGNMIPADDRESS = $TAGNMHDR & ";int Field;int Value"
GLOBAL CONST $TAGLVFINDINFO = "struct;uint Flags;ptr Text;lparam Param;" & $TAGPOINT & ";uint Direction;endstruct"
GLOBAL CONST $TAGLVHITTESTINFO = $TAGPOINT & ";uint Flags;int Item;int SubItem;int iGroup"
GLOBAL CONST $TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
GLOBAL CONST $TAGNMLISTVIEW = $TAGNMHDR & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" & "struct;long ActionX;long ActionY;endstruct;lparam Param"
GLOBAL CONST $TAGNMLVCUSTOMDRAW = "struct;" & $TAGNMHDR & ";dword dwDrawStage;handle hdc;" & $TAGRECT & ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" & ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" & "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
GLOBAL CONST $TAGNMLVDISPINFO = $TAGNMHDR & ";" & $TAGLVITEM
GLOBAL CONST $TAGNMLVFINDITEM = $TAGNMHDR & ";int Start;" & $TAGLVFINDINFO
GLOBAL CONST $TAGNMLVGETINFOTIP = $TAGNMHDR & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
GLOBAL CONST $TAGNMITEMACTIVATE = $TAGNMHDR & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" & $TAGPOINT & ";lparam lParam;uint KeyFlags"
GLOBAL CONST $TAGNMLVKEYDOWN = $TAGNMHDR & ";align 2;word VKey;uint Flags"
GLOBAL CONST $TAGNMLVSCROLL = $TAGNMHDR & ";int DX;int DY"
GLOBAL CONST $TAGMCHITTESTINFO = "uint Size;" & $TAGPOINT & ";uint Hit;" & $TAGSYSTEMTIME & ";" & $TAGRECT & ";int iOffset;int iRow;int iCol"
GLOBAL CONST $TAGMCMONTHRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short Span"
GLOBAL CONST $TAGMCRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short MinSet;short MaxSet"
GLOBAL CONST $TAGMCSELRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds"
GLOBAL CONST $TAGNMDAYSTATE = $TAGNMHDR & ";" & $TAGSYSTEMTIME & ";int DayState;ptr pDayState"
GLOBAL CONST $TAGNMSELCHANGE = $TAGNMHDR & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
GLOBAL CONST $TAGNMOBJECTNOTIFY = $TAGNMHDR & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
GLOBAL CONST $TAGNMTCKEYDOWN = $TAGNMHDR & ";align 2;word VKey;uint Flags"
GLOBAL CONST $TAGTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" & "int Children;lparam Param;endstruct"
GLOBAL CONST $TAGTVITEMEX = "struct;" & $TAGTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
GLOBAL CONST $TAGNMTREEVIEW = $TAGNMHDR & ";uint Action;" & "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" & "struct;long PointX;long PointY;endstruct"
GLOBAL CONST $TAGNMTVCUSTOMDRAW = "struct;" & $TAGNMHDR & ";dword DrawStage;handle HDC;" & $TAGRECT & ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" & ";dword ClrText;dword ClrTextBk;int Level"
GLOBAL CONST $TAGNMTVDISPINFO = $TAGNMHDR & ";" & $TAGTVITEM
GLOBAL CONST $TAGNMTVGETINFOTIP = $TAGNMHDR & ";ptr Text;int TextMax;handle hItem;lparam lParam"
GLOBAL CONST $TAGNMTVITEMCHANGE = $TAGNMHDR & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
GLOBAL CONST $TAGTVHITTESTINFO = $TAGPOINT & ";uint Flags;handle Item"
GLOBAL CONST $TAGNMTVKEYDOWN = $TAGNMHDR & ";align 2;word VKey;uint Flags"
GLOBAL CONST $TAGNMMOUSE = $TAGNMHDR & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $TAGPOINT & ";lparam HitInfo"
GLOBAL CONST $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
GLOBAL CONST $TAGIMAGEINFO = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $TAGRECT
GLOBAL CONST $TAGMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
GLOBAL CONST $TAGMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
GLOBAL CONST $TAGREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVERSION = "WIN_XP") ? "" : ";" & $TAGRECT & ";uint uChevronState")
GLOBAL CONST $TAGNMREBARAUTOBREAK = $TAGNMHDR & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
GLOBAL CONST $TAGNMRBAUTOSIZE = $TAGNMHDR & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
GLOBAL CONST $TAGNMREBAR = $TAGNMHDR & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
GLOBAL CONST $TAGNMREBARCHEVRON = $TAGNMHDR & ";uint uBand;uint wID;lparam lParam;" & $TAGRECT & ";lparam lParamNM"
GLOBAL CONST $TAGNMREBARCHILDSIZE = $TAGNMHDR & ";uint uBand;uint wID;" & "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
GLOBAL CONST $TAGCOLORSCHEME = "dword Size;dword BtnHighlight;dword BtnShadow"
GLOBAL CONST $TAGNMTOOLBAR = $TAGNMHDR & ";int iItem;" & "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" & ";int cchText;ptr pszText;" & $TAGRECT
GLOBAL CONST $TAGNMTBHOTITEM = $TAGNMHDR & ";int idOld;int idNew;dword dwFlags"
GLOBAL CONST $TAGTBBUTTON = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
GLOBAL CONST $TAGTBBUTTONINFO = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
GLOBAL CONST $TAGNETRESOURCE = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
GLOBAL CONST $TAGOVERLAPPED = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
GLOBAL CONST $TAGOPENFILENAME = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
GLOBAL CONST $TAGBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
GLOBAL CONST $TAGBITMAPINFO = $TAGBITMAPINFOHEADER & ";dword biRGBQuad[1]"
GLOBAL CONST $TAGBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
GLOBAL CONST $TAGGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
GLOBAL CONST $TAGWINDOWPLACEMENT = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
GLOBAL CONST $TAGWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
GLOBAL CONST $TAGSCROLLINFO = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
GLOBAL CONST $TAGSCROLLBARINFO = "dword cbSize;" & $TAGRECT & ";int dxyLineButton;int xyThumbTop;" & "int xyThumbBottom;int reserved;dword rgstate[6]"
GLOBAL CONST $TAGLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
GLOBAL CONST $TAGKBDLLHOOKSTRUCT = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
GLOBAL CONST $TAGPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
GLOBAL CONST $TAGSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
GLOBAL CONST $TAGSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
GLOBAL CONST $TAGWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
GLOBAL CONST $TAGTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
GLOBAL CONST $HGDI_ERROR = PTR(-1)
GLOBAL CONST $INVALID_HANDLE_VALUE = PTR(-1)
GLOBAL CONST $CLR_INVALID = -1
GLOBAL CONST $MB_PRECOMPOSED = 1
GLOBAL CONST $MB_COMPOSITE = 2
GLOBAL CONST $MB_USEGLYPHCHARS = 4
GLOBAL CONST $ULW_ALPHA = 2
GLOBAL CONST $ULW_COLORKEY = 1
GLOBAL CONST $ULW_OPAQUE = 4
GLOBAL CONST $ULW_EX_NORESIZE = 8
GLOBAL CONST $WH_CALLWNDPROC = 4
GLOBAL CONST $WH_CALLWNDPROCRET = 12
GLOBAL CONST $WH_CBT = 5
GLOBAL CONST $WH_DEBUG = 9
GLOBAL CONST $WH_FOREGROUNDIDLE = 11
GLOBAL CONST $WH_GETMESSAGE = 3
GLOBAL CONST $WH_JOURNALPLAYBACK = 1
GLOBAL CONST $WH_JOURNALRECORD = 0
GLOBAL CONST $WH_KEYBOARD = 2
GLOBAL CONST $WH_KEYBOARD_LL = 13
GLOBAL CONST $WH_MOUSE = 7
GLOBAL CONST $WH_MOUSE_LL = 14
GLOBAL CONST $WH_MSGFILTER = -1
GLOBAL CONST $WH_SHELL = 10
GLOBAL CONST $WH_SYSMSGFILTER = 6
GLOBAL CONST $WPF_ASYNCWINDOWPLACEMENT = 4
GLOBAL CONST $WPF_RESTORETOMAXIMIZED = 2
GLOBAL CONST $WPF_SETMINPOSITION = 1
GLOBAL CONST $KF_EXTENDED = 256
GLOBAL CONST $KF_ALTDOWN = 8192
GLOBAL CONST $KF_UP = 32768
GLOBAL CONST $LLKHF_EXTENDED = BITSHIFT($KF_EXTENDED, 8)
GLOBAL CONST $LLKHF_LOWER_IL_INJECTED = 2
GLOBAL CONST $LLKHF_INJECTED = 16
GLOBAL CONST $LLKHF_ALTDOWN = BITSHIFT($KF_ALTDOWN, 8)
GLOBAL CONST $LLKHF_UP = BITSHIFT($KF_UP, 8)
GLOBAL CONST $LVKF_ALT = 1
GLOBAL CONST $LVKF_CONTROL = 2
GLOBAL CONST $LVKF_SHIFT = 4
GLOBAL CONST $OFN_ALLOWMULTISELECT = 512
GLOBAL CONST $OFN_CREATEPROMPT = 8192
GLOBAL CONST $OFN_DONTADDTORECENT = 33554432
GLOBAL CONST $OFN_ENABLEHOOK = 32
GLOBAL CONST $OFN_ENABLEINCLUDENOTIFY = 4194304
GLOBAL CONST $OFN_ENABLESIZING = 8388608
GLOBAL CONST $OFN_ENABLETEMPLATE = 64
GLOBAL CONST $OFN_ENABLETEMPLATEHANDLE = 128
GLOBAL CONST $OFN_EXPLORER = 524288
GLOBAL CONST $OFN_EXTENSIONDIFFERENT = 1024
GLOBAL CONST $OFN_FILEMUSTEXIST = 4096
GLOBAL CONST $OFN_FORCESHOWHIDDEN = 268435456
GLOBAL CONST $OFN_HIDEREADONLY = 4
GLOBAL CONST $OFN_LONGNAMES = 2097152
GLOBAL CONST $OFN_NOCHANGEDIR = 8
GLOBAL CONST $OFN_NODEREFERENCELINKS = 1048576
GLOBAL CONST $OFN_NOLONGNAMES = 262144
GLOBAL CONST $OFN_NONETWORKBUTTON = 131072
GLOBAL CONST $OFN_NOREADONLYRETURN = 32768
GLOBAL CONST $OFN_NOTESTFILECREATE = 65536
GLOBAL CONST $OFN_NOVALIDATE = 256
GLOBAL CONST $OFN_OVERWRITEPROMPT = 2
GLOBAL CONST $OFN_PATHMUSTEXIST = 2048
GLOBAL CONST $OFN_READONLY = 1
GLOBAL CONST $OFN_SHAREAWARE = 16384
GLOBAL CONST $OFN_SHOWHELP = 16
GLOBAL CONST $OFN_EX_NOPLACESBAR = 1
GLOBAL CONST $STD_CUT = 0
GLOBAL CONST $STD_COPY = 1
GLOBAL CONST $STD_PASTE = 2
GLOBAL CONST $STD_UNDO = 3
GLOBAL CONST $STD_REDOW = 4
GLOBAL CONST $STD_DELETE = 5
GLOBAL CONST $STD_FILENEW = 6
GLOBAL CONST $STD_FILEOPEN = 7
GLOBAL CONST $STD_FILESAVE = 8
GLOBAL CONST $STD_PRINTPRE = 9
GLOBAL CONST $STD_PROPERTIES = 10
GLOBAL CONST $STD_HELP = 11
GLOBAL CONST $STD_FIND = 12
GLOBAL CONST $STD_REPLACE = 13
GLOBAL CONST $STD_PRINT = 14
GLOBAL CONST $KB_SENDSPECIAL = 0
GLOBAL CONST $KB_SENDRAW = 1
GLOBAL CONST $KB_CAPSOFF = 0
GLOBAL CONST $KB_CAPSON = 1
GLOBAL CONST $S_OK = 0
GLOBAL CONST $E_ABORT = -2147467260
GLOBAL CONST $E_ACCESSDENIED = -2147024891
GLOBAL CONST $E_FAIL = -2147467259
GLOBAL CONST $E_HANDLE = -2147024890
GLOBAL CONST $E_INVALIDARG = -2147024809
GLOBAL CONST $E_NOINTERFACE = -2147467262
GLOBAL CONST $E_NOTIMPL = -2147467263
GLOBAL CONST $E_OUTOFMEMORY = -2147024882
GLOBAL CONST $E_POINTER = -2147467261
GLOBAL CONST $E_UNEXPECTED = -2147418113
#Region Global Variables and Constants
	GLOBAL $__G_VENUM, $__G_VEXT = 0
	GLOBAL $__G_IRGBMODE = 1
	GLOBAL CONST $TAGOSVERSIONINFO = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
	GLOBAL CONST $IMAGE_BITMAP = 0
	GLOBAL CONST $IMAGE_ICON = 1
	GLOBAL CONST $IMAGE_CURSOR = 2
	GLOBAL CONST $IMAGE_ENHMETAFILE = 3
	GLOBAL CONST $LR_DEFAULTCOLOR = 0
	GLOBAL CONST $LR_MONOCHROME = 1
	GLOBAL CONST $LR_COLOR = 2
	GLOBAL CONST $LR_COPYRETURNORG = 4
	GLOBAL CONST $LR_COPYDELETEORG = 8
	GLOBAL CONST $LR_LOADFROMFILE = 16
	GLOBAL CONST $LR_LOADTRANSPARENT = 32
	GLOBAL CONST $LR_DEFAULTSIZE = 64
	GLOBAL CONST $LR_VGACOLOR = 128
	GLOBAL CONST $LR_LOADMAP3DCOLORS = 4096
	GLOBAL CONST $LR_CREATEDIBSECTION = 8192
	GLOBAL CONST $LR_COPYFROMRESOURCE = 16384
	GLOBAL CONST $LR_SHARED = 32768
	GLOBAL CONST $__TAGCURSORINFO = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CREATEFILE($SFILENAME, $ICREATION, $IACCESS = 4, $ISHARE = 0, $IATTRIBUTES = 0, $TSECURITY = 0)
		LOCAL $IDA = 0, $ISM = 0, $ICD = 0, $IFA = 0
		IF BITAND($IACCESS, 1) <> 0 THEN $IDA = BITOR($IDA, $GENERIC_EXECUTE)
		IF BITAND($IACCESS, 2) <> 0 THEN $IDA = BITOR($IDA, $GENERIC_READ)
		IF BITAND($IACCESS, 4) <> 0 THEN $IDA = BITOR($IDA, $GENERIC_WRITE)
		IF BITAND($ISHARE, 1) <> 0 THEN $ISM = BITOR($ISM, $FILE_SHARE_DELETE)
		IF BITAND($ISHARE, 2) <> 0 THEN $ISM = BITOR($ISM, $FILE_SHARE_READ)
		IF BITAND($ISHARE, 4) <> 0 THEN $ISM = BITOR($ISM, $FILE_SHARE_WRITE)
		SWITCH $ICREATION
			CASE 0
				$ICD = $CREATE_NEW
			CASE 1
				$ICD = $CREATE_ALWAYS
			CASE 2
				$ICD = $OPEN_EXISTING
			CASE 3
				$ICD = $OPEN_ALWAYS
			CASE 4
				$ICD = $TRUNCATE_EXISTING
		ENDSWITCH
		IF BITAND($IATTRIBUTES, 1) <> 0 THEN $IFA = BITOR($IFA, $FILE_ATTRIBUTE_ARCHIVE)
		IF BITAND($IATTRIBUTES, 2) <> 0 THEN $IFA = BITOR($IFA, $FILE_ATTRIBUTE_HIDDEN)
		IF BITAND($IATTRIBUTES, 4) <> 0 THEN $IFA = BITOR($IFA, $FILE_ATTRIBUTE_READONLY)
		IF BITAND($IATTRIBUTES, 8) <> 0 THEN $IFA = BITOR($IFA, $FILE_ATTRIBUTE_SYSTEM)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "CreateFileW", "wstr", $SFILENAME, "dword", $IDA, "dword", $ISM, "struct*", $TSECURITY, "dword", $ICD, "dword", $IFA, "ptr", 0)
		IF @ERROR OR($ACALL[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FREELIBRARY($HMODULE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FreeLibrary", "handle", $HMODULE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCURSORINFO()
		LOCAL $TCURSOR = DLLSTRUCTCREATE($__TAGCURSORINFO)
		LOCAL $ICURSOR = DLLSTRUCTGETSIZE($TCURSOR)
		DLLSTRUCTSETDATA($TCURSOR, "Size", $ICURSOR)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetCursorInfo", "struct*", $TCURSOR)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ACURSOR[5]
		$ACURSOR[0] = TRUE
		$ACURSOR[1] = DLLSTRUCTGETDATA($TCURSOR, "Flags") <> 0
		$ACURSOR[2] = DLLSTRUCTGETDATA($TCURSOR, "hCursor")
		$ACURSOR[3] = DLLSTRUCTGETDATA($TCURSOR, "X")
		$ACURSOR[4] = DLLSTRUCTGETDATA($TCURSOR, "Y")
		RETURN $ACURSOR
	ENDFUNC
	FUNC _WINAPI_GETDLGCTRLID($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "GetDlgCtrlID", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETMODULEHANDLE($SMODULENAME)
		IF $SMODULENAME = "" THEN $SMODULENAME = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "GetModuleHandleW", "wstr", $SMODULENAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETSTRING($PSTRING, $BUNICODE = TRUE)
		LOCAL $ILENGTH = _WINAPI_STRLEN($PSTRING, $BUNICODE)
		IF @ERROR OR NOT $ILENGTH THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		LOCAL $TSTRING = DLLSTRUCTCREATE(($BUNICODE ? "wchar" : "char") & "[" & ($ILENGTH + 1) & "]", $PSTRING)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ILENGTH, DLLSTRUCTGETDATA($TSTRING, 1))
	ENDFUNC
	FUNC _WINAPI_GETVERSION()
		LOCAL $TOSVI = DLLSTRUCTCREATE($TAGOSVERSIONINFO)
		DLLSTRUCTSETDATA($TOSVI, 1, DLLSTRUCTGETSIZE($TOSVI))
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetVersionExW", "struct*", $TOSVI)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN NUMBER(DLLSTRUCTGETDATA($TOSVI, 2) & "." & DLLSTRUCTGETDATA($TOSVI, 3), $NUMBER_DOUBLE)
	ENDFUNC
	FUNC _WINAPI_ISWOW64PROCESS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (_WINAPI_GETVERSION() < 6 ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "IsWow64Process", "handle", $HPROCESS[0], "bool*", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_LOADIMAGE($HINSTANCE, $SIMAGE, $ITYPE, $IXDESIRED, $IYDESIRED, $ILOAD)
		LOCAL $ACALL, $SIMAGETYPE = "int"
		IF ISSTRING($SIMAGE) THEN $SIMAGETYPE = "wstr"
		$ACALL = DLLCALL("user32.dll", "handle", "LoadImageW", "handle", $HINSTANCE, $SIMAGETYPE, $SIMAGE, "uint", $ITYPE, "int", $IXDESIRED, "int", $IYDESIRED, "uint", $ILOAD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADLIBRARY($SFILENAME)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "LoadLibraryW", "wstr", $SFILENAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISDIRECTORY($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsDirectoryW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_READFILE($HFILE, $PBUFFER, $ITOREAD, BYREF $IREAD, $TOVERLAPPED = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $PBUFFER, "dword", $ITOREAD, "dword*", 0, "struct*", $TOVERLAPPED)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IREAD = $ACALL[4]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_STRLEN($PSTRING, $BUNICODE = TRUE)
		LOCAL $W = ""
		IF $BUNICODE THEN $W = "W"
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "lstrlen" & $W, "struct*", $PSTRING)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SWITCHCOLOR($ICOLOR)
		IF $ICOLOR = -1 THEN RETURN $ICOLOR
		RETURN BITOR(BITAND($ICOLOR, 65280), BITSHIFT(BITAND($ICOLOR, 255), -16), BITSHIFT(BITAND($ICOLOR, 16711680), 16))
	ENDFUNC
	FUNC _WINAPI_WRITEFILE($HFILE, $PBUFFER, $ITOWRITE, BYREF $IWRITTEN, $TOVERLAPPED = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "WriteFile", "handle", $HFILE, "struct*", $PBUFFER, "dword", $ITOWRITE, "dword*", 0, "struct*", $TOVERLAPPED)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IWRITTEN = $ACALL[4]
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __CHECKERRORARRAYBOUNDS(CONST BYREF $ADATA, BYREF $ISTART, BYREF $IEND, $NDIM = 1, $IDIM = $UBOUND_DIMENSIONS)
		IF NOT ISARRAY($ADATA) THEN RETURN SETERROR(1, 0, 1)
		IF UBOUND($ADATA, $IDIM) <> $NDIM THEN RETURN SETERROR(2, 0, 1)
		IF $ISTART < 0 THEN $ISTART = 0
		LOCAL $IUBOUND = UBOUND($ADATA) - 1
		IF $IEND < 1 OR $IEND > $IUBOUND THEN $IEND = $IUBOUND
		IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, 1)
		RETURN 0
	ENDFUNC
	FUNC __CHECKERRORCLOSEHANDLE($ACALL, $HFILE, $BLASTERROR = FALSE, $ICURERR = @ERROR, $ICUREXT = @EXTENDED)
		IF NOT $ICURERR AND NOT $ACALL[0] THEN $ICURERR = 10
		LOCAL $ALASTERROR = DLLCALL("kernel32.dll", "dword", "GetLastError")
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		IF $ICURERR THEN DLLCALL("kernel32.dll", "none", "SetLastError", "dword", $ALASTERROR[0])
		IF $BLASTERROR THEN $ICUREXT = $ALASTERROR[0]
		RETURN SETERROR($ICURERR, $ICUREXT, $ICURERR)
	ENDFUNC
	FUNC __DLL($SPATH, $BPIN = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetModuleHandleExW", "dword", ($BPIN ? 1 : 2), "wstr", $SPATH, "ptr*", 0)
		IF NOT $ACALL[3] THEN
			$ACALL = DLLCALL("kernel32.dll", "handle", "LoadLibraryW", "wstr", $SPATH)
			IF @ERROR OR NOT $ACALL[0] THEN RETURN 0
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMWINDOWSPROC($HWND, $BVISIBLE)
		LOCAL $ACALL
		IF $BVISIBLE THEN
			$ACALL = DLLCALL("user32.dll", "bool", "IsWindowVisible", "hwnd", $HWND)
			IF NOT $ACALL[0] THEN
				RETURN 1
			ENDIF
		ENDIF
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0][0]][0] = $HWND
		$ACALL = DLLCALL("user32.dll", "int", "GetClassNameW", "hwnd", $HWND, "wstr", "", "int", 4096)
		$__G_VENUM[$__G_VENUM[0][0]][1] = $ACALL[2]
		RETURN 1
	ENDFUNC
	FUNC __FATALEXIT($ICODE, $STEXT = "")
		IF $STEXT THEN MSGBOX($MB_SYSTEMMODAL, "AutoIt", $STEXT)
		DLLCALL("kernel32.dll", "none", "FatalExit", "int", $ICODE)
	ENDFUNC
	FUNC __INC(BYREF $ADATA, $IINCREMENT = 100)
		SELECT
			CASE UBOUND($ADATA, $UBOUND_COLUMNS)
				IF $IINCREMENT < 0 THEN
					REDIM $ADATA[$ADATA[0][0] + 1][UBOUND($ADATA, $UBOUND_COLUMNS)]
				ELSE
					$ADATA[0][0] += 1
					IF $ADATA[0][0] > UBOUND($ADATA) - 1 THEN
						REDIM $ADATA[$ADATA[0][0] + $IINCREMENT][UBOUND($ADATA, $UBOUND_COLUMNS)]
					ENDIF
				ENDIF
			CASE UBOUND($ADATA, $UBOUND_ROWS)
				IF $IINCREMENT < 0 THEN
					REDIM $ADATA[$ADATA[0] + 1]
				ELSE
					$ADATA[0] += 1
					IF $ADATA[0] > UBOUND($ADATA) - 1 THEN
						REDIM $ADATA[$ADATA[0] + $IINCREMENT]
					ENDIF
				ENDIF
			CASE ELSE
				RETURN 0
		ENDSELECT
		RETURN 1
	ENDFUNC
	FUNC __RGB($ICOLOR)
		IF $__G_IRGBMODE THEN
			$ICOLOR = _WINAPI_SWITCHCOLOR($ICOLOR)
		ENDIF
		RETURN $ICOLOR
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CHARTOOEM($SSTR)
		LOCAL $ACALL, $SRETSTR = "", $NLEN = STRINGLEN($SSTR) + 1, $ISTART = 1
		WHILE $ISTART < $NLEN
			$ACALL = DLLCALL("user32.dll", "bool", "CharToOemW", "wstr", STRINGMID($SSTR, $ISTART, 65536), "wstr", "")
			IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
			$ISTART += 65536
			$SRETSTR &= $ACALL[2]
		WEND
		RETURN $SRETSTR
	ENDFUNC
	FUNC _WINAPI_CLIENTTOSCREEN($HWND, BYREF $TPOINT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ClientToScreen", "hwnd", $HWND, "struct*", $TPOINT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_DWORDTOFLOAT($IVALUE)
		LOCAL $TDWORD = DLLSTRUCTCREATE("dword")
		LOCAL $TFLOAT = DLLSTRUCTCREATE("float", DLLSTRUCTGETPTR($TDWORD))
		DLLSTRUCTSETDATA($TDWORD, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TFLOAT, 1)
	ENDFUNC
	FUNC _WINAPI_DWORDTOINT($IVALUE)
		LOCAL $TDATA = DLLSTRUCTCREATE("int")
		DLLSTRUCTSETDATA($TDATA, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TDATA, 1)
	ENDFUNC
	FUNC _WINAPI_FLOATTODWORD($IVALUE)
		LOCAL $TFLOAT = DLLSTRUCTCREATE("float")
		LOCAL $TDWORD = DLLSTRUCTCREATE("dword", DLLSTRUCTGETPTR($TFLOAT))
		DLLSTRUCTSETDATA($TFLOAT, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TDWORD, 1)
	ENDFUNC
	FUNC _WINAPI_FLOATTOINT($NFLOAT)
		LOCAL $TFLOAT = DLLSTRUCTCREATE("float")
		LOCAL $TINT = DLLSTRUCTCREATE("int", DLLSTRUCTGETPTR($TFLOAT))
		DLLSTRUCTSETDATA($TFLOAT, 1, $NFLOAT)
		RETURN DLLSTRUCTGETDATA($TINT, 1)
	ENDFUNC
	FUNC _WINAPI_GETXYFROMPOINT(BYREF $TPOINT, BYREF $IX, BYREF $IY)
		$IX = DLLSTRUCTGETDATA($TPOINT, "X")
		$IY = DLLSTRUCTGETDATA($TPOINT, "Y")
	ENDFUNC
	FUNC _WINAPI_GUIDFROMSTRING($SGUID)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		IF NOT _WINAPI_GUIDFROMSTRINGEX($SGUID, $TGUID) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $TGUID
	ENDFUNC
	FUNC _WINAPI_GUIDFROMSTRINGEX($SGUID, $TGUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], FALSE)
		RETURN TRUE
	ENDFUNC
	FUNC _WINAPI_HASHDATA($PMEMORY, $ISIZE, $ILENGTH = 32)
		IF($ILENGTH <= 0) OR($ILENGTH > 256) THEN RETURN SETERROR(11, 0, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & $ILENGTH & "]")
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "uint", "HashData", "struct*", $PMEMORY, "dword", $ISIZE, "struct*", $TDATA, "dword", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN DLLSTRUCTGETDATA($TDATA, 1)
	ENDFUNC
	FUNC _WINAPI_HASHSTRING($SSTRING, $BCASESENSITIVE = TRUE, $ILENGTH = 32)
		LOCAL $ILENGTHS = STRINGLEN($SSTRING)
		IF NOT $ILENGTHS OR($ILENGTH > 256) THEN RETURN SETERROR(12, 0, 0)
		LOCAL $TSTRING = DLLSTRUCTCREATE("wchar[" & ($ILENGTHS + 1) & "]")
		IF NOT $BCASESENSITIVE THEN
			$SSTRING = STRINGLOWER($SSTRING)
		ENDIF
		DLLSTRUCTSETDATA($TSTRING, 1, $SSTRING)
		LOCAL $SHASH = _WINAPI_HASHDATA($TSTRING, 2 * $ILENGTHS, $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $SHASH
	ENDFUNC
	FUNC _WINAPI_HIBYTE($IVALUE)
		RETURN BITAND(BITSHIFT($IVALUE, 8), 255)
	ENDFUNC
	FUNC _WINAPI_HIDWORD($IVALUE)
		LOCAL $TINT64 = DLLSTRUCTCREATE("int64")
		LOCAL $TQWORD = DLLSTRUCTCREATE("dword;dword", DLLSTRUCTGETPTR($TINT64))
		DLLSTRUCTSETDATA($TINT64, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TQWORD, 2)
	ENDFUNC
	FUNC _WINAPI_HIWORD($ILONG)
		RETURN BITSHIFT($ILONG, 16)
	ENDFUNC
	FUNC _WINAPI_INTTODWORD($IVALUE)
		LOCAL $TDATA = DLLSTRUCTCREATE("dword")
		DLLSTRUCTSETDATA($TDATA, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TDATA, 1)
	ENDFUNC
	FUNC _WINAPI_INTTOFLOAT($IINT)
		LOCAL $TINT = DLLSTRUCTCREATE("int")
		LOCAL $TFLOAT = DLLSTRUCTCREATE("float", DLLSTRUCTGETPTR($TINT))
		DLLSTRUCTSETDATA($TINT, 1, $IINT)
		RETURN DLLSTRUCTGETDATA($TFLOAT, 1)
	ENDFUNC
	FUNC _WINAPI_LOBYTE($IVALUE)
		RETURN BITAND($IVALUE, 255)
	ENDFUNC
	FUNC _WINAPI_LODWORD($IVALUE)
		LOCAL $TINT64 = DLLSTRUCTCREATE("int64")
		LOCAL $TQWORD = DLLSTRUCTCREATE("dword;dword", DLLSTRUCTGETPTR($TINT64))
		DLLSTRUCTSETDATA($TINT64, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TQWORD, 1)
	ENDFUNC
	FUNC _WINAPI_LOWORD($ILONG)
		RETURN BITAND($ILONG, 65535)
	ENDFUNC
	FUNC _WINAPI_LONGMID($IVALUE, $ISTART, $ICOUNT)
		RETURN BITAND(BITSHIFT($IVALUE, $ISTART), BITOR(BITSHIFT(BITSHIFT(2147483647, 32 - ($ICOUNT + 1)), 1), BITSHIFT(1, -($ICOUNT - 1))))
	ENDFUNC
	FUNC _WINAPI_MAKELANGID($ILNGIDPRIMARY, $ILNGIDSUB)
		RETURN BITOR(BITSHIFT($ILNGIDSUB, -10), $ILNGIDPRIMARY)
	ENDFUNC
	FUNC _WINAPI_MAKELCID($ILNGID, $ISORTID)
		RETURN BITOR(BITSHIFT($ISORTID, -16), $ILNGID)
	ENDFUNC
	FUNC _WINAPI_MAKELONG($ILO, $IHI)
		RETURN BITOR(BITSHIFT($IHI, -16), BITAND($ILO, 65535))
	ENDFUNC
	FUNC _WINAPI_MAKEQWORD($ILODWORD, $IHIDWORD)
		LOCAL $TINT64 = DLLSTRUCTCREATE("uint64")
		LOCAL $TDWORDS = DLLSTRUCTCREATE("dword;dword", DLLSTRUCTGETPTR($TINT64))
		DLLSTRUCTSETDATA($TDWORDS, 1, $ILODWORD)
		DLLSTRUCTSETDATA($TDWORDS, 2, $IHIDWORD)
		RETURN DLLSTRUCTGETDATA($TINT64, 1)
	ENDFUNC
	FUNC _WINAPI_MAKEWORD($ILO, $IHI)
		LOCAL $TWORD = DLLSTRUCTCREATE("ushort")
		LOCAL $TBYTE = DLLSTRUCTCREATE("byte;byte", DLLSTRUCTGETPTR($TWORD))
		DLLSTRUCTSETDATA($TBYTE, 1, $IHI)
		DLLSTRUCTSETDATA($TBYTE, 2, $ILO)
		RETURN DLLSTRUCTGETDATA($TWORD, 1)
	ENDFUNC
	FUNC _WINAPI_MULTIBYTETOWIDECHAR($VTEXT, $ICODEPAGE = 0, $IFLAGS = 0, $BRETSTRING = FALSE)
		LOCAL $STEXTTYPE = ""
		IF ISSTRING($VTEXT) THEN $STEXTTYPE = "str"
		IF(ISDLLSTRUCT($VTEXT) OR ISPTR($VTEXT)) THEN $STEXTTYPE = "struct*"
		IF $STEXTTYPE = "" THEN RETURN SETERROR(1, 0, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "MultiByteToWideChar", "uint", $ICODEPAGE, "dword", $IFLAGS, $STEXTTYPE, $VTEXT, "int", -1, "ptr", 0, "int", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $IOUT = $ACALL[0]
		LOCAL $TOUT = DLLSTRUCTCREATE("wchar[" & $IOUT & "]")
		$ACALL = DLLCALL("kernel32.dll", "int", "MultiByteToWideChar", "uint", $ICODEPAGE, "dword", $IFLAGS, $STEXTTYPE, $VTEXT, "int", -1, "struct*", $TOUT, "int", $IOUT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		IF $BRETSTRING THEN RETURN DLLSTRUCTGETDATA($TOUT, 1)
		RETURN $TOUT
	ENDFUNC
	FUNC _WINAPI_MULTIBYTETOWIDECHAREX($STEXT, $PTEXT, $ICODEPAGE = 0, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "MultiByteToWideChar", "uint", $ICODEPAGE, "dword", $IFLAGS, "STR", $STEXT, "int", -1, "struct*", $PTEXT, "int", (STRINGLEN($STEXT) + 1) * 2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OEMTOCHAR($SSTR)
		LOCAL $ACALL, $SRETSTR = "", $NLEN = STRINGLEN($SSTR) + 1, $ISTART = 1
		WHILE $ISTART < $NLEN
			$ACALL = DLLCALL("user32.dll", "bool", "OemToCharA", "str", STRINGMID($SSTR, $ISTART, 65536), "str", "")
			IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
			$SRETSTR &= $ACALL[2]
			$ISTART += 65536
		WEND
		RETURN $SRETSTR
	ENDFUNC
	FUNC _WINAPI_POINTFROMRECT(BYREF $TRECT, $BCENTER = TRUE)
		LOCAL $IX1 = DLLSTRUCTGETDATA($TRECT, "Left")
		LOCAL $IY1 = DLLSTRUCTGETDATA($TRECT, "Top")
		LOCAL $IX2 = DLLSTRUCTGETDATA($TRECT, "Right")
		LOCAL $IY2 = DLLSTRUCTGETDATA($TRECT, "Bottom")
		IF $BCENTER THEN
			$IX1 = $IX1 + (($IX2 - $IX1) / 2)
			$IY1 = $IY1 + (($IY2 - $IY1) / 2)
		ENDIF
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		DLLSTRUCTSETDATA($TPOINT, "X", $IX1)
		DLLSTRUCTSETDATA($TPOINT, "Y", $IY1)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_PRIMARYLANGID($ILNGID)
		RETURN BITAND($ILNGID, 1023)
	ENDFUNC
	FUNC _WINAPI_SCREENTOCLIENT($HWND, BYREF $TPOINT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ScreenToClient", "hwnd", $HWND, "struct*", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHORTTOWORD($IVALUE)
		RETURN BITAND($IVALUE, 65535)
	ENDFUNC
	FUNC _WINAPI_STRFORMATBYTESIZE($ISIZE)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "ptr", "StrFormatByteSizeW", "int64", $ISIZE, "wstr", "", "uint", 1024)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_STRFORMATBYTESIZEEX($ISIZE)
		LOCAL $ASYMBOL = DLLCALL("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 15, "wstr", "", "int", 2048)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		LOCAL $SSIZE = _WINAPI_STRFORMATBYTESIZE(0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN STRINGREPLACE($SSIZE, "0", STRINGREGEXPREPLACE(NUMBER($ISIZE), "(?<=\d)(?=(\d{3})+\z)", $ASYMBOL[3]))
	ENDFUNC
	FUNC _WINAPI_STRFORMATKBSIZE($ISIZE)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "ptr", "StrFormatKBSizeW", "int64", $ISIZE, "wstr", "", "uint", 1024)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_STRFROMTIMEINTERVAL($ITIME, $IDIGITS = 7)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "int", "StrFromTimeIntervalW", "wstr", "", "uint", 1024, "dword", $ITIME, "int", $IDIGITS)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN STRINGSTRIPWS($ACALL[1], $STR_STRIPLEADING + $STR_STRIPTRAILING)
	ENDFUNC
	FUNC _WINAPI_STRINGFROMGUID($TGUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "int", "StringFromGUID2", "struct*", $TGUID, "wstr", "", "int", 40)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ACALL[0], $ACALL[2])
	ENDFUNC
	FUNC _WINAPI_SUBLANGID($ILNGID)
		RETURN BITSHIFT($ILNGID, 10)
	ENDFUNC
	FUNC _WINAPI_SWAPDWORD($IVALUE)
		LOCAL $TSTRUCT1 = DLLSTRUCTCREATE("dword;dword")
		LOCAL $TSTRUCT2 = DLLSTRUCTCREATE("byte[4];byte[4]", DLLSTRUCTGETPTR($TSTRUCT1))
		DLLSTRUCTSETDATA($TSTRUCT1, 1, $IVALUE)
		FOR $I = 1 TO 4
			DLLSTRUCTSETDATA($TSTRUCT2, 2, DLLSTRUCTGETDATA($TSTRUCT2, 1, 5 - $I), $I)
		NEXT
		RETURN DLLSTRUCTGETDATA($TSTRUCT1, 2)
	ENDFUNC
	FUNC _WINAPI_SWAPQWORD($IVALUE)
		LOCAL $TSTRUCT1 = DLLSTRUCTCREATE("int64;int64")
		LOCAL $TSTRUCT2 = DLLSTRUCTCREATE("byte[8];byte[8]", DLLSTRUCTGETPTR($TSTRUCT1))
		DLLSTRUCTSETDATA($TSTRUCT1, 1, $IVALUE)
		FOR $I = 1 TO 8
			DLLSTRUCTSETDATA($TSTRUCT2, 2, DLLSTRUCTGETDATA($TSTRUCT2, 1, 9 - $I), $I)
		NEXT
		RETURN DLLSTRUCTGETDATA($TSTRUCT1, 2)
	ENDFUNC
	FUNC _WINAPI_SWAPWORD($IVALUE)
		LOCAL $TSTRUCT1 = DLLSTRUCTCREATE("word;word")
		LOCAL $TSTRUCT2 = DLLSTRUCTCREATE("byte[2];byte[2]", DLLSTRUCTGETPTR($TSTRUCT1))
		DLLSTRUCTSETDATA($TSTRUCT1, 1, $IVALUE)
		FOR $I = 1 TO 2
			DLLSTRUCTSETDATA($TSTRUCT2, 2, DLLSTRUCTGETDATA($TSTRUCT2, 1, 3 - $I), $I)
		NEXT
		RETURN DLLSTRUCTGETDATA($TSTRUCT1, 2)
	ENDFUNC
	FUNC _WINAPI_WIDECHARTOMULTIBYTE($VUNICODE, $ICODEPAGE = 0, $BRETNOSTRUCT = TRUE, $BRETBINARY = FALSE)
		LOCAL $SUNICODETYPE = "wstr"
		IF NOT ISSTRING($VUNICODE) THEN $SUNICODETYPE = "struct*"
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "WideCharToMultiByte", "uint", $ICODEPAGE, "dword", 0, $SUNICODETYPE, $VUNICODE, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		LOCAL $TMULTIBYTE = DLLSTRUCTCREATE((($BRETBINARY) ? ("byte") : ("char")) & "[" & $ACALL[0] & "]")
		$ACALL = DLLCALL("kernel32.dll", "int", "WideCharToMultiByte", "uint", $ICODEPAGE, "dword", 0, $SUNICODETYPE, $VUNICODE, "int", -1, "struct*", $TMULTIBYTE, "int", $ACALL[0], "ptr", 0, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		IF $BRETNOSTRUCT THEN RETURN DLLSTRUCTGETDATA($TMULTIBYTE, 1)
		RETURN $TMULTIBYTE
	ENDFUNC
	FUNC _WINAPI_WORDTOSHORT($IVALUE)
		IF BITAND($IVALUE, 32768) THEN
			RETURN BITOR($IVALUE, -32768)
		ENDIF
		RETURN BITAND($IVALUE, 32767)
	ENDFUNC
#EndRegion Public Functions
GLOBAL CONST $__DLG_WM_USER = 1024
GLOBAL CONST $BIF_BROWSEFILEJUNCTIONS = 65536
GLOBAL CONST $BIF_BROWSEFORCOMPUTER = 4096
GLOBAL CONST $BIF_BROWSEFORPRINTER = 8192
GLOBAL CONST $BIF_BROWSEINCLUDEFILES = 16384
GLOBAL CONST $BIF_BROWSEINCLUDEURLS = 128
GLOBAL CONST $BIF_DONTGOBELOWDOMAIN = 2
GLOBAL CONST $BIF_EDITBOX = 16
GLOBAL CONST $BIF_NEWDIALOGSTYLE = 64
GLOBAL CONST $BIF_NONEWFOLDERBUTTON = 512
GLOBAL CONST $BIF_NOTRANSLATETARGETS = 1024
GLOBAL CONST $BIF_RETURNFSANCESTORS = 8
GLOBAL CONST $BIF_RETURNONLYFSDIRS = 1
GLOBAL CONST $BIF_SHAREABLE = 32768
GLOBAL CONST $BIF_STATUSTEXT = 4
GLOBAL CONST $BIF_USENEWUI = BITOR($BIF_EDITBOX, $BIF_NEWDIALOGSTYLE)
GLOBAL CONST $BIF_UAHINT = 256
GLOBAL CONST $BIF_VALIDATE = 32
GLOBAL CONST $BFFM_INITIALIZED = 1
GLOBAL CONST $BFFM_IUNKNOWN = 5
GLOBAL CONST $BFFM_SELCHANGED = 2
GLOBAL CONST $BFFM_VALIDATEFAILED = 4
GLOBAL CONST $BFFM_SETSTATUSTEXTA = $__DLG_WM_USER + 100
GLOBAL CONST $BFFM_ENABLEOK = $__DLG_WM_USER + 101
GLOBAL CONST $BFFM_SETSELECTIONA = $__DLG_WM_USER + 102
GLOBAL CONST $BFFM_SETSELECTIONW = $__DLG_WM_USER + 103
GLOBAL CONST $BFFM_SETSTATUSTEXTW = $__DLG_WM_USER + 104
GLOBAL CONST $BFFM_SETOKTEXT = $__DLG_WM_USER + 105
GLOBAL CONST $BFFM_SETEXPANDED = $__DLG_WM_USER + 106
GLOBAL CONST $CDERR_DIALOGFAILURE = 65535
GLOBAL CONST $CDERR_FINDRESFAILURE = 6
GLOBAL CONST $CDERR_INITIALIZATION = 2
GLOBAL CONST $CDERR_LOADRESFAILURE = 7
GLOBAL CONST $CDERR_LOADSTRFAILURE = 5
GLOBAL CONST $CDERR_LOCKRESFAILURE = 8
GLOBAL CONST $CDERR_MEMALLOCFAILURE = 9
GLOBAL CONST $CDERR_MEMLOCKFAILURE = 10
GLOBAL CONST $CDERR_NOHINSTANCE = 4
GLOBAL CONST $CDERR_NOHOOK = 11
GLOBAL CONST $CDERR_NOTEMPLATE = 3
GLOBAL CONST $CDERR_REGISTERMSGFAIL = 12
GLOBAL CONST $CDERR_STRUCTSIZE = 1
GLOBAL CONST $PDERR_CREATEICFAILURE = 4106
GLOBAL CONST $PDERR_DEFAULTDIFFERENT = 4108
GLOBAL CONST $PDERR_DNDMMISMATCH = 4105
GLOBAL CONST $PDERR_GETDEVMODEFAIL = 4101
GLOBAL CONST $PDERR_INITFAILURE = 4102
GLOBAL CONST $PDERR_LOADDRVFAILURE = 4100
GLOBAL CONST $PDERR_NODEFAULTPRN = 4104
GLOBAL CONST $PDERR_NODEVICES = 4103
GLOBAL CONST $PDERR_PARSEFAILURE = 4098
GLOBAL CONST $PDERR_PRINTERNOTFOUND = 4107
GLOBAL CONST $PDERR_RETDEFFAILURE = 4099
GLOBAL CONST $PDERR_SETUPFAILURE = 4097
GLOBAL CONST $CFERR_MAXLESSTHANMIN = 8194
GLOBAL CONST $CFERR_NOFONTS = 8193
GLOBAL CONST $FNERR_BUFFERTOOSMALL = 12291
GLOBAL CONST $FNERR_INVALIDFILENAME = 12290
GLOBAL CONST $FNERR_SUBCLASSFAILURE = 12289
GLOBAL CONST $FRERR_BUFFERLENGTHZERO = 16385
GLOBAL CONST $FR_DIALOGTERM = 64
GLOBAL CONST $FR_DOWN = 1
GLOBAL CONST $FR_ENABLEHOOK = 256
GLOBAL CONST $FR_ENABLETEMPLATE = 512
GLOBAL CONST $FR_ENABLETEMPLATEHANDLE = 8192
GLOBAL CONST $FR_FINDNEXT = 8
GLOBAL CONST $FR_HIDEUPDOWN = 16384
GLOBAL CONST $FR_HIDEMATCHCASE = 32768
GLOBAL CONST $FR_HIDEWHOLEWORD = 65536
GLOBAL CONST $FR_MATCHCASE = 4
GLOBAL CONST $FR_NOMATCHCASE = 2048
GLOBAL CONST $FR_NOUPDOWN = 1024
GLOBAL CONST $FR_NOWHOLEWORD = 4096
GLOBAL CONST $FR_REPLACE = 16
GLOBAL CONST $FR_REPLACEALL = 32
GLOBAL CONST $FR_SHOWHELP = 128
GLOBAL CONST $FR_WHOLEWORD = 2
GLOBAL CONST $SHFMT_ID_DEFAULT = 65535
GLOBAL CONST $SHFMT_OPT_FULL = 0
GLOBAL CONST $SHFMT_OPT_QUICKFORMAT = 1
GLOBAL CONST $SHFMT_OPT_SYSONLY = 2
GLOBAL CONST $SHFMT_ERROR = -1
GLOBAL CONST $SHFMT_CANCEL = -2
GLOBAL CONST $SHFMT_NOFORMAT = -3
GLOBAL CONST $CDM_FIRST = $__DLG_WM_USER + 100
GLOBAL CONST $CDM_GETSPEC = $CDM_FIRST
GLOBAL CONST $CDM_GETFILEPATH = $CDM_FIRST + 1
GLOBAL CONST $CDM_GETFOLDERPATH = $CDM_FIRST + 2
GLOBAL CONST $CDM_GETFOLDERIDLIST = $CDM_FIRST + 3
GLOBAL CONST $CDM_SETCONTROLTEXT = $CDM_FIRST + 4
GLOBAL CONST $CDM_HIDECONTROL = $CDM_FIRST + 5
GLOBAL CONST $CDM_SETDEFEXT = $CDM_FIRST + 6
GLOBAL CONST $CDM_LAST = $__DLG_WM_USER + 200
GLOBAL CONST $CDN_FIRST = -601
GLOBAL CONST $CDN_INITDONE = $CDN_FIRST
GLOBAL CONST $CDN_SELCHANGE = $CDN_FIRST - 1
GLOBAL CONST $CDN_FOLDERCHANGE = $CDN_FIRST - 2
GLOBAL CONST $CDN_SHAREVIOLATION = $CDN_FIRST - 3
GLOBAL CONST $CDN_HELP = $CDN_FIRST - 4
GLOBAL CONST $CDN_FILEOK = $CDN_FIRST - 5
GLOBAL CONST $CDN_TYPECHANGE = $CDN_FIRST - 6
GLOBAL CONST $CDN_INCLUDEITEM = $CDN_FIRST - 7
GLOBAL CONST $CDN_LAST = -699
GLOBAL CONST $PSD_DEFAULTMINMARGINS = 0
GLOBAL CONST $PSD_DISABLEMARGINS = 16
GLOBAL CONST $PSD_DISABLEORIENTATION = 256
GLOBAL CONST $PSD_DISABLEPAGEPAINTING = 524288
GLOBAL CONST $PSD_DISABLEPAPER = 512
GLOBAL CONST $PSD_DISABLEPRINTER = 32
GLOBAL CONST $PSD_ENABLEPAGEPAINTHOOK = 262144
GLOBAL CONST $PSD_ENABLEPAGESETUPHOOK = 8192
GLOBAL CONST $PSD_ENABLEPAGESETUPTEMPLATE = 32768
GLOBAL CONST $PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 131072
GLOBAL CONST $PSD_INHUNDREDTHSOFMILLIMETERS = 8
GLOBAL CONST $PSD_INTHOUSANDTHSOFINCHES = 4
GLOBAL CONST $PSD_MARGINS = 2
GLOBAL CONST $PSD_MINMARGINS = 1
GLOBAL CONST $PSD_NONETWORKBUTTON = 2097152
GLOBAL CONST $PSD_NOWARNING = 128
GLOBAL CONST $PSD_RETURNDEFAULT = 1024
GLOBAL CONST $PSD_SHOWHELP = 2048
GLOBAL CONST $WM_PSD_PAGESETUPDLG = $__DLG_WM_USER
GLOBAL CONST $WM_PSD_FULLPAGERECT = $__DLG_WM_USER + 1
GLOBAL CONST $WM_PSD_MINMARGINRECT = $__DLG_WM_USER + 2
GLOBAL CONST $WM_PSD_MARGINRECT = $__DLG_WM_USER + 3
GLOBAL CONST $WM_PSD_GREEKTEXTRECT = $__DLG_WM_USER + 4
GLOBAL CONST $WM_PSD_ENVSTAMPRECT = $__DLG_WM_USER + 5
GLOBAL CONST $WM_PSD_YAFULLPAGERECT = $__DLG_WM_USER + 6
GLOBAL CONST $PD_ALLPAGES = 0
GLOBAL CONST $PD_COLLATE = 16
GLOBAL CONST $PD_CURRENTPAGE = 4194304
GLOBAL CONST $PD_DISABLEPRINTTOFILE = 524288
GLOBAL CONST $PD_ENABLEPRINTHOOK = 4096
GLOBAL CONST $PD_ENABLEPRINTTEMPLATE = 16384
GLOBAL CONST $PD_ENABLEPRINTTEMPLATEHANDLE = 65536
GLOBAL CONST $PD_ENABLESETUPHOOK = 8192
GLOBAL CONST $PD_ENABLESETUPTEMPLATE = 32768
GLOBAL CONST $PD_ENABLESETUPTEMPLATEHANDLE = 131072
GLOBAL CONST $PD_EXCLUSIONFLAGS = 16777216
GLOBAL CONST $PD_HIDEPRINTTOFILE = 1048576
GLOBAL CONST $PD_NOCURRENTPAGE = 8388608
GLOBAL CONST $PD_NONETWORKBUTTON = 2097152
GLOBAL CONST $PD_NOPAGENUMS = 8
GLOBAL CONST $PD_NOSELECTION = 4
GLOBAL CONST $PD_NOWARNING = 128
GLOBAL CONST $PD_PAGENUMS = 2
GLOBAL CONST $PD_PRINTSETUP = 64
GLOBAL CONST $PD_PRINTTOFILE = 32
GLOBAL CONST $PD_RETURNDC = 256
GLOBAL CONST $PD_RETURNDEFAULT = 1024
GLOBAL CONST $PD_RETURNIC = 512
GLOBAL CONST $PD_SELECTION = 1
GLOBAL CONST $PD_SHOWHELP = 2048
GLOBAL CONST $PD_USEDEVMODECOPIES = 262144
GLOBAL CONST $PD_USEDEVMODECOPIESANDCOLLATE = $PD_USEDEVMODECOPIES
GLOBAL CONST $PD_USELARGETEMPLATE = 268435456
GLOBAL CONST $PD_RESULT_APPLY = 2
GLOBAL CONST $PD_RESULT_CANCEL = 0
GLOBAL CONST $PD_RESULT_PRINT = 1
GLOBAL CONST $EWX_LOGOFF = 0
GLOBAL CONST $EWX_POWEROFF = 8
GLOBAL CONST $EWX_REBOOT = 2
GLOBAL CONST $EWX_SHUTDOWN = 1
GLOBAL CONST $EWX_FORCE = 4
GLOBAL CONST $EWX_FORCEIFHUNG = 16
GLOBAL CONST $OAIF_ALLOW_REGISTRATION = 1
GLOBAL CONST $OAIF_REGISTER_EXT = 2
GLOBAL CONST $OAIF_EXEC = 4
GLOBAL CONST $OAIF_FORCE_REGISTRATION = 8
GLOBAL CONST $OAIF_HIDE_REGISTRATION = 32
GLOBAL CONST $OAIF_URL_PROTOCOL = 64
GLOBAL CONST $CREDUI_FLAGS_ALWAYS_SHOW_UI = 128
GLOBAL CONST $CREDUI_FLAGS_COMPLETE_USERNAME = 2048
GLOBAL CONST $CREDUI_FLAGS_DO_NOT_PERSIST = 2
GLOBAL CONST $CREDUI_FLAGS_EXCLUDE_CERTIFICATES = 8
GLOBAL CONST $CREDUI_FLAGS_EXPECT_CONFIRMATION = 131072
GLOBAL CONST $CREDUI_FLAGS_GENERIC_CREDENTIALS = 262144
GLOBAL CONST $CREDUI_FLAGS_INCORRECT_PASSWORD = 1
GLOBAL CONST $CREDUI_FLAGS_KEEP_USERNAME = 1048576
GLOBAL CONST $CREDUI_FLAGS_PASSWORD_ONLY_OK = 512
GLOBAL CONST $CREDUI_FLAGS_PERSIST = 4096
GLOBAL CONST $CREDUI_FLAGS_REQUEST_ADMINISTRATOR = 4
GLOBAL CONST $CREDUI_FLAGS_REQUIRE_CERTIFICATE = 16
GLOBAL CONST $CREDUI_FLAGS_REQUIRE_SMARTCARD = 256
GLOBAL CONST $CREDUI_FLAGS_SERVER_CREDENTIAL = 16384
GLOBAL CONST $CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX = 64
GLOBAL CONST $CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS = 524288
GLOBAL CONST $CREDUI_FLAGS_VALIDATE_USERNAME = 1024
GLOBAL CONST $CREDUIWIN_AUTHPACKAGE_ONLY = 16
GLOBAL CONST $CREDUIWIN_CHECKBOX = 2
GLOBAL CONST $CREDUIWIN_ENUMERATE_ADMINS = 256
GLOBAL CONST $CREDUIWIN_ENUMERATE_CURRENT_USER = 512
GLOBAL CONST $CREDUIWIN_GENERIC = 1
GLOBAL CONST $CREDUIWIN_IN_CRED_ONLY = 32
GLOBAL CONST $CREDUIWIN_SECURE_PROMPT = 4096
GLOBAL CONST $CREDUIWIN_PACK_32_WOW = 268435456
GLOBAL CONST $CREDUIWIN_PREPROMPTING = 8192
GLOBAL CONST $COINIT_APARTMENTTHREADED = 2
GLOBAL CONST $COINIT_DISABLE_OLE1DDE = 4
GLOBAL CONST $COINIT_MULTITHREADED = 0
GLOBAL CONST $COINIT_SPEED_OVER_MEMORY = 8
#Region Global Variables and Constants
	GLOBAL CONST $__TAGWINAPICOM_GUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CLSIDFROMPROGID($SPROGID)
		LOCAL $TGUID = DLLSTRUCTCREATE($__TAGWINAPICOM_GUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "long", "CLSIDFromProgID", "wstr", $SPROGID, "struct*", $TGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		$ACALL = DLLCALL("ole32.dll", "int", "StringFromGUID2", "struct*", $TGUID, "wstr", "", "int", 39)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_COINITIALIZE($IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("ole32.dll", "long", "CoInitializeEx", "ptr", 0, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_COTASKMEMALLOC($ISIZE)
		LOCAL $ACALL = DLLCALL("ole32.dll", "ptr", "CoTaskMemAlloc", "uint_ptr", $ISIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COTASKMEMFREE($PMEMORY)
		DLLCALL("ole32.dll", "none", "CoTaskMemFree", "ptr", $PMEMORY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_COTASKMEMREALLOC($PMEMORY, $ISIZE)
		LOCAL $ACALL = DLLCALL("ole32.dll", "ptr", "CoTaskMemRealloc", "ptr", $PMEMORY, "ulong_ptr", $ISIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COUNINITIALIZE()
		DLLCALL("ole32.dll", "none", "CoUninitialize")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_CREATEGUID()
		LOCAL $TGUID = DLLSTRUCTCREATE($__TAGWINAPICOM_GUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "long", "CoCreateGuid", "struct*", $TGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		$ACALL = DLLCALL("ole32.dll", "int", "StringFromGUID2", "struct*", $TGUID, "wstr", "", "int", 65536)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_CREATESTREAMONHGLOBAL($HGLOBAL = 0, $BDELETEONRELEASE = TRUE)
		LOCAL $ACALL = DLLCALL("ole32.dll", "long", "CreateStreamOnHGlobal", "handle", $HGLOBAL, "bool", $BDELETEONRELEASE, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_GETHGLOBALFROMSTREAM($PSTREAM)
		LOCAL $ACALL = DLLCALL("ole32.dll", "uint", "GetHGlobalFromStream", "ptr", $PSTREAM, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_PROGIDFROMCLSID($SCLSID)
		LOCAL $TGUID = DLLSTRUCTCREATE($__TAGWINAPICOM_GUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "uint", "CLSIDFromString", "wstr", $SCLSID, "struct*", $TGUID)
		IF @ERROR OR $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$ACALL = DLLCALL("ole32.dll", "uint", "ProgIDFromCLSID", "struct*", $TGUID, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		LOCAL $SID = _WINAPI_GETSTRING($ACALL[2])
		_WINAPI_COTASKMEMFREE($ACALL[2])
		RETURN $SID
	ENDFUNC
	FUNC _WINAPI_RELEASESTREAM($PSTREAM)
		LOCAL $ACALL = DLLCALL("oleaut32.dll", "long", "DispCallFunc", "ptr", $PSTREAM, "ulong_ptr", 8 * (1 + @AUTOITX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
	GLOBAL $__G_HHEAP = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CREATEBUFFER($ILENGTH, $PBUFFER = 0, $BABORT = TRUE)
		$PBUFFER = __HEAPREALLOC($PBUFFER, $ILENGTH, 0, $BABORT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $PBUFFER
	ENDFUNC
	FUNC _WINAPI_CREATEBUFFERFROMSTRUCT($TSTRUCT, $PBUFFER = 0, $BABORT = TRUE)
		IF NOT ISDLLSTRUCT($TSTRUCT) THEN RETURN SETERROR(1, 0, 0)
		$PBUFFER = __HEAPREALLOC($PBUFFER, DLLSTRUCTGETSIZE($TSTRUCT), 0, $BABORT)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 100, @EXTENDED, 0)
		_WINAPI_MOVEMEMORY($PBUFFER, $TSTRUCT, DLLSTRUCTGETSIZE($TSTRUCT))
		RETURN $PBUFFER
	ENDFUNC
	FUNC _WINAPI_CREATESTRING($SSTRING, $PSTRING = 0, $ILENGTH = -1, $BUNICODE = TRUE, $BABORT = TRUE)
		$ILENGTH = NUMBER($ILENGTH)
		IF $ILENGTH >= 0 THEN
			$SSTRING = STRINGLEFT($SSTRING, $ILENGTH)
		ELSE
			$ILENGTH = STRINGLEN($SSTRING)
		ENDIF
		LOCAL $ISIZE = $ILENGTH + 1
		IF $BUNICODE THEN
			$ISIZE *= 2
		ENDIF
		$PSTRING = __HEAPREALLOC($PSTRING, $ISIZE, 0, $BABORT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		DLLSTRUCTSETDATA(DLLSTRUCTCREATE(($BUNICODE ? "wchar" : "char") & "[" & ($ILENGTH + 1) & "]", $PSTRING), 1, $SSTRING)
		RETURN SETEXTENDED($ILENGTH, $PSTRING)
	ENDFUNC
	FUNC _WINAPI_EQUALMEMORY($PSOURCE1, $PSOURCE2, $ILENGTH)
		IF _WINAPI_ISBADREADPTR($PSOURCE1, $ILENGTH) THEN RETURN SETERROR(11, @EXTENDED, 0)
		IF _WINAPI_ISBADREADPTR($PSOURCE2, $ILENGTH) THEN RETURN SETERROR(12, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("ntdll.dll", "ulong_ptr", "RtlCompareMemory", "struct*", $PSOURCE1, "struct*", $PSOURCE2, "ulong_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN NUMBER($ACALL[0] = $ILENGTH)
	ENDFUNC
	FUNC _WINAPI_FILLMEMORY($PMEMORY, $ILENGTH, $IVALUE = 0)
		IF _WINAPI_ISBADWRITEPTR($PMEMORY, $ILENGTH) THEN RETURN SETERROR(11, @EXTENDED, 0)
		DLLCALL("ntdll.dll", "none", "RtlFillMemory", "struct*", $PMEMORY, "ulong_ptr", $ILENGTH, "byte", $IVALUE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_FREEMEMORY($PMEMORY)
		IF NOT __HEAPFREE($PMEMORY, 1) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_GETMEMORYSIZE($PMEMORY)
		LOCAL $IRESULT = __HEAPSIZE($PMEMORY, 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $IRESULT
	ENDFUNC
	FUNC _WINAPI_GLOBALMEMORYSTATUS()
		LOCAL CONST $TAGMEMORYSTATUSEX = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
		LOCAL $TMEM = DLLSTRUCTCREATE($TAGMEMORYSTATUSEX)
		DLLSTRUCTSETDATA($TMEM, 1, DLLSTRUCTGETSIZE($TMEM))
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $TMEM)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $AMEM[7]
		$AMEM[0] = DLLSTRUCTGETDATA($TMEM, 2)
		$AMEM[1] = DLLSTRUCTGETDATA($TMEM, 3)
		$AMEM[2] = DLLSTRUCTGETDATA($TMEM, 4)
		$AMEM[3] = DLLSTRUCTGETDATA($TMEM, 5)
		$AMEM[4] = DLLSTRUCTGETDATA($TMEM, 6)
		$AMEM[5] = DLLSTRUCTGETDATA($TMEM, 7)
		$AMEM[6] = DLLSTRUCTGETDATA($TMEM, 8)
		RETURN $AMEM
	ENDFUNC
	FUNC _WINAPI_ISBADCODEPTR($PADDRESS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "IsBadCodePtr", "struct*", $PADDRESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISBADREADPTR($PADDRESS, $ILENGTH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "IsBadReadPtr", "struct*", $PADDRESS, "uint_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISBADSTRINGPTR($PADDRESS, $ILENGTH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "IsBadStringPtr", "struct*", $PADDRESS, "uint_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISBADWRITEPTR($PADDRESS, $ILENGTH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "IsBadWritePtr", "struct*", $PADDRESS, "uint_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISMEMORY($PMEMORY)
		LOCAL $BRESULT = __HEAPVALIDATE($PMEMORY)
		RETURN SETERROR(@ERROR, @EXTENDED, $BRESULT)
	ENDFUNC
	FUNC _WINAPI_LOCALFREE($HMEMORY)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $HMEMORY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MOVEMEMORY($PDESTINATION, $PSOURCE, $ILENGTH)
		IF _WINAPI_ISBADREADPTR($PSOURCE, $ILENGTH) THEN RETURN SETERROR(10, @EXTENDED, 0)
		IF _WINAPI_ISBADWRITEPTR($PDESTINATION, $ILENGTH) THEN RETURN SETERROR(11, @EXTENDED, 0)
		DLLCALL("ntdll.dll", "none", "RtlMoveMemory", "struct*", $PDESTINATION, "struct*", $PSOURCE, "ulong_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_READPROCESSMEMORY($HPROCESS, $PBASEADDRESS, $PBUFFER, $ISIZE, BYREF $IREAD)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", $PBASEADDRESS, "struct*", $PBUFFER, "ulong_ptr", $ISIZE, "ulong_ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IREAD = $ACALL[5]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WRITEPROCESSMEMORY($HPROCESS, $PBASEADDRESS, $PBUFFER, $ISIZE, BYREF $IWRITTEN, $SBUFFERTYPE = "ptr")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "WriteProcessMemory", "handle", $HPROCESS, "ptr", $PBASEADDRESS, $SBUFFERTYPE, $PBUFFER, "ulong_ptr", $ISIZE, "ulong_ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IWRITTEN = $ACALL[5]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ZEROMEMORY($PMEMORY, $ILENGTH)
		IF _WINAPI_ISBADWRITEPTR($PMEMORY, $ILENGTH) THEN RETURN SETERROR(11, @EXTENDED, 0)
		DLLCALL("ntdll.dll", "none", "RtlZeroMemory", "struct*", $PMEMORY, "ulong_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __HEAPALLOC($ISIZE, $BABORT = FALSE)
		LOCAL $ACALL
		IF NOT $__G_HHEAP THEN
			$ACALL = DLLCALL("kernel32.dll", "handle", "HeapCreate", "dword", 0, "ulong_ptr", 0, "ulong_ptr", 0)
			IF @ERROR OR NOT $ACALL[0] THEN __FATALEXIT(1, "Error allocating memory.")
			$__G_HHEAP = $ACALL[0]
		ENDIF
		$ACALL = DLLCALL("kernel32.dll", "ptr", "HeapAlloc", "handle", $__G_HHEAP, "dword", 8, "ulong_ptr", $ISIZE)
		IF @ERROR OR NOT $ACALL[0] THEN
			IF $BABORT THEN __FATALEXIT(1, "Error allocating memory.")
			RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC __HEAPFREE(BYREF $PMEMORY, $BCHECK = FALSE, $ICURERR = @ERROR, $ICUREXT = @EXTENDED)
		IF $BCHECK AND(NOT __HEAPVALIDATE($PMEMORY)) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "HeapFree", "handle", $__G_HHEAP, "dword", 0, "ptr", $PMEMORY)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 40, @EXTENDED, 0)
		$PMEMORY = 0
		RETURN SETERROR($ICURERR, $ICUREXT, 1)
	ENDFUNC
	FUNC __HEAPREALLOC($PMEMORY, $ISIZE, $BAMOUNT = FALSE, $BABORT = FALSE)
		LOCAL $PRET
		IF __HEAPVALIDATE($PMEMORY) THEN
			IF $BAMOUNT AND(__HEAPSIZE($PMEMORY) >= $ISIZE) THEN RETURN SETEXTENDED(1, PTR($PMEMORY))
			LOCAL $ACALL = DLLCALL("kernel32.dll", "ptr", "HeapReAlloc", "handle", $__G_HHEAP, "dword", 8, "ptr", $PMEMORY, "ulong_ptr", $ISIZE)
			IF @ERROR OR NOT $ACALL[0] THEN
				IF $BABORT THEN __FATALEXIT(1, "Error allocating memory.")
				RETURN SETERROR(@ERROR + 20, @EXTENDED, PTR($PMEMORY))
			ENDIF
			$PRET = $ACALL[0]
		ELSE
			$PRET = __HEAPALLOC($ISIZE, $BABORT)
			IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		ENDIF
		RETURN $PRET
	ENDFUNC
	FUNC __HEAPSIZE($PMEMORY, $BCHECK = FALSE)
		IF $BCHECK AND(NOT __HEAPVALIDATE($PMEMORY)) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "ulong_ptr", "HeapSize", "handle", $__G_HHEAP, "dword", 0, "ptr", $PMEMORY)
		IF @ERROR OR($ACALL[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR + 50, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC __HEAPVALIDATE($PMEMORY)
		IF(NOT $__G_HHEAP) OR(NOT PTR($PMEMORY)) THEN RETURN SETERROR(9, 0, FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "HeapValidate", "handle", $__G_HHEAP, "dword", 0, "ptr", $PMEMORY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $SND_APPLICATION = 128
GLOBAL CONST $SND_ALIAS = 65536
GLOBAL CONST $SND_ALIAS_ID = 1114112
GLOBAL CONST $SND_ASYNC = 1
GLOBAL CONST $SND_FILENAME = 131072
GLOBAL CONST $SND_LOOP = 8
GLOBAL CONST $SND_MEMORY = 4
GLOBAL CONST $SND_NODEFAULT = 2
GLOBAL CONST $SND_NOSTOP = 16
GLOBAL CONST $SND_NOWAIT = 8192
GLOBAL CONST $SND_PURGE = 64
GLOBAL CONST $SND_RESOURCE = 262148
GLOBAL CONST $SND_SENTRY = 524288
GLOBAL CONST $SND_SYNC = 0
GLOBAL CONST $SND_SYSTEM = 2097152
GLOBAL CONST $SND_SYSTEM_NOSTOP = 2097168
GLOBAL CONST $SND_ALIAS_SYSTEMASTERISK = "SystemAsterisk"
GLOBAL CONST $SND_ALIAS_SYSTEMDEFAULT = "SystemDefault"
GLOBAL CONST $SND_ALIAS_SYSTEMEXCLAMATION = "SystemExclamation"
GLOBAL CONST $SND_ALIAS_SYSTEMEXIT = "SystemExit"
GLOBAL CONST $SND_ALIAS_SYSTEMHAND = "SystemHand"
GLOBAL CONST $SND_ALIAS_SYSTEMQUESTION = "SystemQuestion"
GLOBAL CONST $SND_ALIAS_SYSTEMSTART = "SystemStart"
GLOBAL CONST $SND_ALIAS_SYSTEMWELCOME = "SystemWelcome"
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_ARRAYTOSTRUCT(CONST BYREF $ADATA, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($ADATA, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "wchar[" & (STRINGLEN($ADATA[$I]) + 1) & "];"
		NEXT
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGSTRUCT & "wchar[1]")
		LOCAL $ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			DLLSTRUCTSETDATA($TDATA, $ICOUNT, $ADATA[$I])
			$ICOUNT += 1
		NEXT
		DLLSTRUCTSETDATA($TDATA, $ICOUNT, CHRW(0))
		RETURN $TDATA
	ENDFUNC
	FUNC _WINAPI_CREATEMARGINS($ILEFTWIDTH, $IRIGHTWIDTH, $ITOPHEIGHT, $IBOTTOMHEIGHT)
		LOCAL $TMARGINS = DLLSTRUCTCREATE($TAGMARGINS)
		DLLSTRUCTSETDATA($TMARGINS, 1, $ILEFTWIDTH)
		DLLSTRUCTSETDATA($TMARGINS, 2, $IRIGHTWIDTH)
		DLLSTRUCTSETDATA($TMARGINS, 3, $ITOPHEIGHT)
		DLLSTRUCTSETDATA($TMARGINS, 4, $IBOTTOMHEIGHT)
		RETURN $TMARGINS
	ENDFUNC
	FUNC _WINAPI_CREATEPOINT($IX, $IY)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		DLLSTRUCTSETDATA($TPOINT, 1, $IX)
		DLLSTRUCTSETDATA($TPOINT, 2, $IY)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_CREATERECT($ILEFT, $ITOP, $IRIGHT, $IBOTTOM)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLSTRUCTSETDATA($TRECT, 1, $ILEFT)
		DLLSTRUCTSETDATA($TRECT, 2, $ITOP)
		DLLSTRUCTSETDATA($TRECT, 3, $IRIGHT)
		DLLSTRUCTSETDATA($TRECT, 4, $IBOTTOM)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_CREATERECTEX($IX, $IY, $IWIDTH, $IHEIGHT)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLSTRUCTSETDATA($TRECT, 1, $IX)
		DLLSTRUCTSETDATA($TRECT, 2, $IY)
		DLLSTRUCTSETDATA($TRECT, 3, $IX + $IWIDTH)
		DLLSTRUCTSETDATA($TRECT, 4, $IY + $IHEIGHT)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_CREATESIZE($IWIDTH, $IHEIGHT)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		DLLSTRUCTSETDATA($TSIZE, 1, $IWIDTH)
		DLLSTRUCTSETDATA($TSIZE, 2, $IHEIGHT)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_COPYSTRUCT($TSTRUCT, $SSTRUCT = "")
		LOCAL $ISIZE = DLLSTRUCTGETSIZE($TSTRUCT)
		IF NOT $ISIZE THEN RETURN SETERROR(1, 0, 0)
		LOCAL $TRESULT
		IF NOT STRINGSTRIPWS($SSTRUCT, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) THEN
			$TRESULT = DLLSTRUCTCREATE("byte[" & $ISIZE & "]")
		ELSE
			$TRESULT = DLLSTRUCTCREATE($SSTRUCT)
		ENDIF
		IF DLLSTRUCTGETSIZE($TRESULT) < $ISIZE THEN RETURN SETERROR(2, 0, 0)
		_WINAPI_MOVEMEMORY($TRESULT, $TSTRUCT, $ISIZE)
		RETURN $TRESULT
	ENDFUNC
	FUNC _WINAPI_GETEXTENDED()
		RETURN $__G_VEXT
	ENDFUNC
	FUNC _WINAPI_GETMOUSEPOS($BTOCLIENT = FALSE, $HWND = 0)
		LOCAL $IMODE = OPT("MouseCoordMode", 1)
		LOCAL $APOS = MOUSEGETPOS()
		OPT("MouseCoordMode", $IMODE)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		DLLSTRUCTSETDATA($TPOINT, "X", $APOS[0])
		DLLSTRUCTSETDATA($TPOINT, "Y", $APOS[1])
		IF $BTOCLIENT AND NOT _WINAPI_SCREENTOCLIENT($HWND, $TPOINT) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETMOUSEPOSX($BTOCLIENT = FALSE, $HWND = 0)
		LOCAL $TPOINT = _WINAPI_GETMOUSEPOS($BTOCLIENT, $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TPOINT, "X")
	ENDFUNC
	FUNC _WINAPI_GETMOUSEPOSY($BTOCLIENT = FALSE, $HWND = 0)
		LOCAL $TPOINT = _WINAPI_GETMOUSEPOS($BTOCLIENT, $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TPOINT, "Y")
	ENDFUNC
	FUNC _WINAPI_MULDIV($INUMBER, $INUMERATOR, $IDENOMINATOR)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "MulDiv", "int", $INUMBER, "int", $INUMERATOR, "int", $IDENOMINATOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PLAYSOUND($SSOUND, $IFLAGS = $SND_SYSTEM_NOSTOP, $HINSTANCE = 0)
		LOCAL $STYPEOFSOUND = "ptr"
		IF $SSOUND THEN
			IF ISSTRING($SSOUND) THEN
				$STYPEOFSOUND = "wstr"
			ENDIF
		ELSE
			$SSOUND = 0
			$IFLAGS = 0
		ENDIF
		LOCAL $ACALL = DLLCALL("winmm.dll", "bool", "PlaySoundW", $STYPEOFSOUND, $SSOUND, "handle", $HINSTANCE, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_STRINGLENA(CONST BYREF $TSTRING)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "lstrlenA", "struct*", $TSTRING)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_STRINGLENW(CONST BYREF $TSTRING)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "lstrlenW", "struct*", $TSTRING)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_STRUCTTOARRAY(BYREF $TSTRUCT, $IITEMS = 0)
		LOCAL $ISIZE = 2 * FLOOR(DLLSTRUCTGETSIZE($TSTRUCT) / 2)
		LOCAL $PSTRUCT = DLLSTRUCTGETPTR($TSTRUCT)
		IF NOT $ISIZE OR NOT $PSTRUCT THEN RETURN SETERROR(1, 0, 0)
		LOCAL $TDATA, $ILENGTH, $IOFFSET = 0
		LOCAL $ARET[101] = [0]
		WHILE 1
			$ILENGTH = _WINAPI_STRLEN($PSTRUCT + $IOFFSET)
			IF NOT $ILENGTH THEN
				EXITLOOP
			ENDIF
			IF 2 * (1 + $ILENGTH) + $IOFFSET > $ISIZE THEN RETURN SETERROR(3, 0, 0)
			$TDATA = DLLSTRUCTCREATE("wchar[" & (1 + $ILENGTH) & "]", $PSTRUCT + $IOFFSET)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 10, 0, 0)
			__INC($ARET)
			$ARET[$ARET[0]] = DLLSTRUCTGETDATA($TDATA, 1)
			IF $ARET[0] = $IITEMS THEN
				EXITLOOP
			ENDIF
			$IOFFSET += 2 * (1 + $ILENGTH)
			IF $IOFFSET >= $ISIZE THEN RETURN SETERROR(3, 0, 0)
		WEND
		IF NOT $ARET[0] THEN RETURN SETERROR(2, 0, 0)
		__INC($ARET, -1)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_UNIONSTRUCT($TSTRUCT1, $TSTRUCT2, $SSTRUCT = "")
		LOCAL $ASIZE[2] = [DLLSTRUCTGETSIZE($TSTRUCT1), DLLSTRUCTGETSIZE($TSTRUCT2)]
		IF NOT $ASIZE[0] OR NOT $ASIZE[1] THEN RETURN SETERROR(1, 0, 0)
		LOCAL $TRESULT
		IF NOT STRINGSTRIPWS($SSTRUCT, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) THEN
			$TRESULT = DLLSTRUCTCREATE("byte[" & ($ASIZE[0] + $ASIZE[1]) & "]")
		ELSE
			$TRESULT = DLLSTRUCTCREATE($SSTRUCT)
		ENDIF
		IF DLLSTRUCTGETSIZE($TRESULT) < ($ASIZE[0] + $ASIZE[1]) THEN RETURN SETERROR(2, 0, 0)
		_WINAPI_MOVEMEMORY($TRESULT, $TSTRUCT1, $ASIZE[0])
		_WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($TRESULT) + $ASIZE[0], $TSTRUCT2, $ASIZE[1])
		RETURN $TRESULT
	ENDFUNC
#EndRegion Public Functions
GLOBAL CONST $DLLVER_PLATFORM_WINDOWS = 1
GLOBAL CONST $DLLVER_PLATFORM_NT = 2
GLOBAL CONST $SHCNE_ALLEVENTS = 2147483647
GLOBAL CONST $SHCNE_ASSOCCHANGED = 134217728
GLOBAL CONST $SHCNE_ATTRIBUTES = 2048
GLOBAL CONST $SHCNE_CREATE = 2
GLOBAL CONST $SHCNE_DELETE = 4
GLOBAL CONST $SHCNE_DRIVEADD = 256
GLOBAL CONST $SHCNE_DRIVEADDGUI = 65536
GLOBAL CONST $SHCNE_DRIVEREMOVED = 128
GLOBAL CONST $SHCNE_EXTENDED_EVENT = 67108864
GLOBAL CONST $SHCNE_FREESPACE = 262144
GLOBAL CONST $SHCNE_MEDIAINSERTED = 32
GLOBAL CONST $SHCNE_MEDIAREMOVED = 64
GLOBAL CONST $SHCNE_MKDIR = 8
GLOBAL CONST $SHCNE_NETSHARE = 512
GLOBAL CONST $SHCNE_NETUNSHARE = 1024
GLOBAL CONST $SHCNE_RENAMEFOLDER = 131072
GLOBAL CONST $SHCNE_RENAMEITEM = 1
GLOBAL CONST $SHCNE_RMDIR = 16
GLOBAL CONST $SHCNE_SERVERDISCONNECT = 16384
GLOBAL CONST $SHCNE_UPDATEDIR = 4096
GLOBAL CONST $SHCNE_UPDATEIMAGE = 32768
GLOBAL CONST $SHCNE_UPDATEITEM = 8192
GLOBAL CONST $SHCNE_DISKEVENTS = 145439
GLOBAL CONST $SHCNE_GLOBALEVENTS = 201687520
GLOBAL CONST $SHCNE_INTERRUPT = -2147483648
GLOBAL CONST $SHCNF_DWORD = 3
GLOBAL CONST $SHCNF_IDLIST = 0
GLOBAL CONST $SHCNF_PATH = 1
GLOBAL CONST $SHCNF_PRINTER = 2
GLOBAL CONST $SHCNF_FLUSH = 4096
GLOBAL CONST $SHCNF_FLUSHNOWAIT = 8192
GLOBAL CONST $SHCNF_NOTIFYRECURSIVE = 65536
GLOBAL CONST $SHCNRF_INTERRUPTLEVEL = 1
GLOBAL CONST $SHCNRF_SHELLLEVEL = 2
GLOBAL CONST $SHCNRF_RECURSIVEINTERRUPT = 4096
GLOBAL CONST $SHCNRF_NEWDELIVERY = 32768
GLOBAL CONST $SHERB_NOCONFIRMATION = 1
GLOBAL CONST $SHERB_NOPROGRESSUI = 2
GLOBAL CONST $SHERB_NOSOUND = 4
GLOBAL CONST $SHERB_NO_UI = BITOR($SHERB_NOCONFIRMATION, $SHERB_NOPROGRESSUI, $SHERB_NOSOUND)
GLOBAL CONST $SEE_MASK_DEFAULT = 0
GLOBAL CONST $SEE_MASK_CLASSNAME = 1
GLOBAL CONST $SEE_MASK_CLASSKEY = 3
GLOBAL CONST $SEE_MASK_IDLIST = 4
GLOBAL CONST $SEE_MASK_INVOKEIDLIST = 12
GLOBAL CONST $SEE_MASK_ICON = 16
GLOBAL CONST $SEE_MASK_HOTKEY = 32
GLOBAL CONST $SEE_MASK_NOCLOSEPROCESS = 64
GLOBAL CONST $SEE_MASK_CONNECTNETDRV = 128
GLOBAL CONST $SEE_MASK_NOASYNC = 256
GLOBAL CONST $SEE_MASK_FLAG_DDEWAIT = $SEE_MASK_NOASYNC
GLOBAL CONST $SEE_MASK_DOENVSUBST = 512
GLOBAL CONST $SEE_MASK_FLAG_NO_UI = 1024
GLOBAL CONST $SEE_MASK_UNICODE = 16384
GLOBAL CONST $SEE_MASK_NO_CONSOLE = 32768
GLOBAL CONST $SEE_MASK_ASYNCOK = 1048576
GLOBAL CONST $SEE_MASK_NOQUERYCLASSSTORE = 16777216
GLOBAL CONST $SEE_MASK_HMONITOR = 2097152
GLOBAL CONST $SEE_MASK_NOZONECHECKS = 8388608
GLOBAL CONST $SEE_MASK_WAITFORINPUTIDLE = 33554432
GLOBAL CONST $SEE_MASK_FLAG_LOG_USAGE = 67108864
GLOBAL CONST $SE_ERR_ACCESSDENIED = 5
GLOBAL CONST $SE_ERR_ASSOCINCOMPLETE = 27
GLOBAL CONST $SE_ERR_DDEBUSY = 30
GLOBAL CONST $SE_ERR_DDEFAIL = 29
GLOBAL CONST $SE_ERR_DDETIMEOUT = 28
GLOBAL CONST $SE_ERR_DLLNOTFOUND = 32
GLOBAL CONST $SE_ERR_FNF = 2
GLOBAL CONST $SE_ERR_NOASSOC = 31
GLOBAL CONST $SE_ERR_OOM = 8
GLOBAL CONST $SE_ERR_PNF = 3
GLOBAL CONST $SE_ERR_SHARE = 26
GLOBAL CONST $FO_COPY = 2
GLOBAL CONST $FO_DELETE = 3
GLOBAL CONST $FO_MOVE = 1
GLOBAL CONST $FO_RENAME = 4
GLOBAL CONST $FOF_ALLOWUNDO = 64
GLOBAL CONST $FOF_CONFIRMMOUSE = 2
GLOBAL CONST $FOF_FILESONLY = 128
GLOBAL CONST $FOF_MULTIDESTFILES = 1
GLOBAL CONST $FOF_NOCONFIRMATION = 16
GLOBAL CONST $FOF_NOCONFIRMMKDIR = 512
GLOBAL CONST $FOF_NO_CONNECTED_ELEMENTS = 8192
GLOBAL CONST $FOF_NOCOPYSECURITYATTRIBS = 2048
GLOBAL CONST $FOF_NOERRORUI = 1024
GLOBAL CONST $FOF_NORECURSEREPARSE = 32768
GLOBAL CONST $FOF_NORECURSION = 4096
GLOBAL CONST $FOF_RENAMEONCOLLISION = 8
GLOBAL CONST $FOF_SILENT = 4
GLOBAL CONST $FOF_SIMPLEPROGRESS = 256
GLOBAL CONST $FOF_WANTMAPPINGHANDLE = 32
GLOBAL CONST $FOF_WANTNUKEWARNING = 16384
GLOBAL CONST $FOF_NO_UI = BITOR($FOF_NOCONFIRMATION, $FOF_NOCONFIRMMKDIR, $FOF_NOERRORUI, $FOF_SILENT)
GLOBAL CONST $SHGFI_ADDOVERLAYS = 32
GLOBAL CONST $SHGFI_ATTR_SPECIFIED = 131072
GLOBAL CONST $SHGFI_ATTRIBUTES = 2048
GLOBAL CONST $SHGFI_DISPLAYNAME = 512
GLOBAL CONST $SHGFI_EXETYPE = 8192
GLOBAL CONST $SHGFI_ICON = 256
GLOBAL CONST $SHGFI_ICONLOCATION = 4096
GLOBAL CONST $SHGFI_LARGEICON = 0
GLOBAL CONST $SHGFI_LINKOVERLAY = 32768
GLOBAL CONST $SHGFI_OPENICON = 2
GLOBAL CONST $SHGFI_OVERLAYINDEX = 64
GLOBAL CONST $SHGFI_PIDL = 8
GLOBAL CONST $SHGFI_SELECTED = 65536
GLOBAL CONST $SHGFI_SHELLICONSIZE = 4
GLOBAL CONST $SHGFI_SMALLICON = 1
GLOBAL CONST $SHGFI_SYSICONINDEX = 16384
GLOBAL CONST $SHGFI_TYPENAME = 1024
GLOBAL CONST $SHGFI_USEFILEATTRIBUTES = 16
GLOBAL CONST $SFGAO_CANCOPY = 1
GLOBAL CONST $SFGAO_CANMOVE = 2
GLOBAL CONST $SFGAO_CANLINK = 4
GLOBAL CONST $SFGAO_STORAGE = 8
GLOBAL CONST $SFGAO_CANRENAME = 16
GLOBAL CONST $SFGAO_CANDELETE = 32
GLOBAL CONST $SFGAO_HASPROPSHEET = 64
GLOBAL CONST $SFGAO_DROPTARGET = 256
GLOBAL CONST $SFGAO_CAPABILITYMASK = BITOR($SFGAO_CANCOPY, $SFGAO_CANMOVE, $SFGAO_CANLINK, $SFGAO_CANRENAME, $SFGAO_CANDELETE, $SFGAO_HASPROPSHEET, $SFGAO_DROPTARGET)
GLOBAL CONST $SFGAO_SYSTEM = 4096
GLOBAL CONST $SFGAO_ENCRYPTED = 8192
GLOBAL CONST $SFGAO_ISSLOW = 16384
GLOBAL CONST $SFGAO_GHOSTED = 32768
GLOBAL CONST $SFGAO_LINK = 65536
GLOBAL CONST $SFGAO_SHARE = 131072
GLOBAL CONST $SFGAO_READONLY = 262144
GLOBAL CONST $SFGAO_HIDDEN = 524288
GLOBAL CONST $SFGAO_DISPLAYATTRMASK = BITOR($SFGAO_ISSLOW, $SFGAO_GHOSTED, $SFGAO_LINK, $SFGAO_SHARE, $SFGAO_READONLY, $SFGAO_HIDDEN)
GLOBAL CONST $SFGAO_NONENUMERATED = 1048576
GLOBAL CONST $SFGAO_NEWCONTENT = 2097152
GLOBAL CONST $SFGAO_STREAM = 4194304
GLOBAL CONST $SFGAO_STORAGEANCESTOR = 8388608
GLOBAL CONST $SFGAO_VALIDATE = 16777216
GLOBAL CONST $SFGAO_REMOVABLE = 33554432
GLOBAL CONST $SFGAO_COMPRESSED = 67108864
GLOBAL CONST $SFGAO_BROWSABLE = 134217728
GLOBAL CONST $SFGAO_FILESYSANCESTOR = 268435456
GLOBAL CONST $SFGAO_FOLDER = 536870912
GLOBAL CONST $SFGAO_FILESYSTEM = 1073741824
GLOBAL CONST $SFGAO_STORAGECAPMASK = BITOR($SFGAO_STORAGE, $SFGAO_LINK, $SFGAO_READONLY, $SFGAO_STREAM, $SFGAO_STORAGEANCESTOR, $SFGAO_FILESYSANCESTOR, $SFGAO_FOLDER, $SFGAO_FILESYSTEM)
GLOBAL CONST $SFGAO_HASSUBFOLDER = -2147483648
GLOBAL CONST $SFGAO_CONTENTSMASK = $SFGAO_HASSUBFOLDER
GLOBAL CONST $SFGAO_PKEYSFGAOMASK = BITOR($SFGAO_ISSLOW, $SFGAO_READONLY, $SFGAO_HASSUBFOLDER, $SFGAO_VALIDATE)
GLOBAL CONST $IDO_SHGIOI_DEFAULT = 268435452
GLOBAL CONST $IDO_SHGIOI_LINK = 268435454
GLOBAL CONST $IDO_SHGIOI_SHARE = 268435455
GLOBAL CONST $IDO_SHGIOI_SLOWFILE = 268435453
GLOBAL CONST $FCSM_VIEWID = 1
GLOBAL CONST $FCSM_WEBVIEWTEMPLATE = 2
GLOBAL CONST $FCSM_INFOTIP = 4
GLOBAL CONST $FCSM_CLSID = 8
GLOBAL CONST $FCSM_ICONFILE = 16
GLOBAL CONST $FCSM_LOGO = 32
GLOBAL CONST $FCSM_FLAGS = 64
GLOBAL CONST $FCS_READ = 1
GLOBAL CONST $FCS_FORCEWRITE = 2
GLOBAL CONST $FCS_WRITE = BITOR($FCS_READ, $FCS_FORCEWRITE)
GLOBAL CONST $SSF_AUTOCHECKSELECT = 8388608
GLOBAL CONST $SSF_DESKTOPHTML = 512
GLOBAL CONST $SSF_DONTPRETTYPATH = 2048
GLOBAL CONST $SSF_DOUBLECLICKINWEBVIEW = 128
GLOBAL CONST $SSF_HIDEICONS = 16384
GLOBAL CONST $SSF_ICONSONLY = 16777216
GLOBAL CONST $SSF_MAPNETDRVBUTTON = 4096
GLOBAL CONST $SSF_NOCONFIRMRECYCLE = 32768
GLOBAL CONST $SSF_NONETCRAWLING = 1048576
GLOBAL CONST $SSF_SEPPROCESS = 524288
GLOBAL CONST $SSF_SHOWALLOBJECTS = 1
GLOBAL CONST $SSF_SHOWCOMPCOLOR = 8
GLOBAL CONST $SSF_SHOWEXTENSIONS = 2
GLOBAL CONST $SSF_SHOWINFOTIP = 8192
GLOBAL CONST $SSF_SHOWSUPERHIDDEN = 262144
GLOBAL CONST $SSF_SHOWSYSFILES = 32
GLOBAL CONST $SSF_SHOWTYPEOVERLAY = 33554432
GLOBAL CONST $SSF_STARTPANELON = 2097152
GLOBAL CONST $SSF_WIN95CLASSIC = 1024
GLOBAL CONST $SSF_WEBVIEW = 131072
GLOBAL CONST $CSIDL_ADMINTOOLS = 48
GLOBAL CONST $CSIDL_ALTSTARTUP = 29
GLOBAL CONST $CSIDL_APPDATA = 26
GLOBAL CONST $CSIDL_BITBUCKET = 10
GLOBAL CONST $CSIDL_CDBURN_AREA = 59
GLOBAL CONST $CSIDL_COMMON_ADMINTOOLS = 47
GLOBAL CONST $CSIDL_COMMON_ALTSTARTUP = 30
GLOBAL CONST $CSIDL_COMMON_APPDATA = 35
GLOBAL CONST $CSIDL_COMMON_DESKTOPDIRECTORY = 25
GLOBAL CONST $CSIDL_COMMON_DOCUMENTS = 46
GLOBAL CONST $CSIDL_COMMON_FAVORITES = 31
GLOBAL CONST $CSIDL_COMMON_MUSIC = 53
GLOBAL CONST $CSIDL_COMMON_PICTURES = 54
GLOBAL CONST $CSIDL_COMMON_PROGRAMS = 23
GLOBAL CONST $CSIDL_COMMON_STARTMENU = 22
GLOBAL CONST $CSIDL_COMMON_STARTUP = 24
GLOBAL CONST $CSIDL_COMMON_TEMPLATES = 45
GLOBAL CONST $CSIDL_COMMON_VIDEO = 55
GLOBAL CONST $CSIDL_COMPUTERSNEARME = 61
GLOBAL CONST $CSIDL_CONNECTIONS = 49
GLOBAL CONST $CSIDL_CONTROLS = 3
GLOBAL CONST $CSIDL_COOKIES = 33
GLOBAL CONST $CSIDL_DESKTOP = 0
GLOBAL CONST $CSIDL_DESKTOPDIRECTORY = 16
GLOBAL CONST $CSIDL_DRIVES = 17
GLOBAL CONST $CSIDL_FAVORITES = 6
GLOBAL CONST $CSIDL_FONTS = 20
GLOBAL CONST $CSIDL_INTERNET_CACHE = 32
GLOBAL CONST $CSIDL_HISTORY = 34
GLOBAL CONST $CSIDL_LOCAL_APPDATA = 28
GLOBAL CONST $CSIDL_MYMUSIC = 13
GLOBAL CONST $CSIDL_MYPICTURES = 39
GLOBAL CONST $CSIDL_MYVIDEO = 14
GLOBAL CONST $CSIDL_NETHOOD = 19
GLOBAL CONST $CSIDL_PERSONAL = 5
GLOBAL CONST $CSIDL_PRINTERS = 4
GLOBAL CONST $CSIDL_PRINTHOOD = 27
GLOBAL CONST $CSIDL_PROFILE = 40
GLOBAL CONST $CSIDL_PROGRAM_FILES = 38
GLOBAL CONST $CSIDL_PROGRAM_FILES_COMMON = 43
GLOBAL CONST $CSIDL_PROGRAM_FILES_COMMONX86 = 44
GLOBAL CONST $CSIDL_PROGRAM_FILESX86 = 42
GLOBAL CONST $CSIDL_PROGRAMS = 2
GLOBAL CONST $CSIDL_RECENT = 8
GLOBAL CONST $CSIDL_SENDTO = 9
GLOBAL CONST $CSIDL_STARTMENU = 11
GLOBAL CONST $CSIDL_STARTUP = 7
GLOBAL CONST $CSIDL_SYSTEM = 37
GLOBAL CONST $CSIDL_SYSTEMX86 = 41
GLOBAL CONST $CSIDL_TEMPLATES = 21
GLOBAL CONST $CSIDL_WINDOWS = 36
GLOBAL CONST $SIID_DOCNOASSOC = 0
GLOBAL CONST $SIID_DOCASSOC = 1
GLOBAL CONST $SIID_APPLICATION = 2
GLOBAL CONST $SIID_FOLDER = 3
GLOBAL CONST $SIID_FOLDEROPEN = 4
GLOBAL CONST $SIID_DRIVE525 = 5
GLOBAL CONST $SIID_DRIVE35 = 6
GLOBAL CONST $SIID_DRIVEREMOVE = 7
GLOBAL CONST $SIID_DRIVEFIXED = 8
GLOBAL CONST $SIID_DRIVENET = 9
GLOBAL CONST $SIID_DRIVENETDISABLED = 10
GLOBAL CONST $SIID_DRIVECD = 11
GLOBAL CONST $SIID_DRIVERAM = 12
GLOBAL CONST $SIID_WORLD = 13
GLOBAL CONST $SIID_SERVER = 15
GLOBAL CONST $SIID_PRINTER = 16
GLOBAL CONST $SIID_MYNETWORK = 17
GLOBAL CONST $SIID_FIND = 22
GLOBAL CONST $SIID_HELP = 23
GLOBAL CONST $SIID_SHARE = 28
GLOBAL CONST $SIID_LINK = 29
GLOBAL CONST $SIID_SLOWFILE = 30
GLOBAL CONST $SIID_RECYCLER = 31
GLOBAL CONST $SIID_RECYCLERFULL = 32
GLOBAL CONST $SIID_MEDIACDAUDIO = 40
GLOBAL CONST $SIID_LOCK = 47
GLOBAL CONST $SIID_AUTOLIST = 49
GLOBAL CONST $SIID_PRINTERNET = 50
GLOBAL CONST $SIID_SERVERSHARE = 51
GLOBAL CONST $SIID_PRINTERFAX = 52
GLOBAL CONST $SIID_PRINTERFAXNET = 53
GLOBAL CONST $SIID_PRINTERFILE = 54
GLOBAL CONST $SIID_STACK = 55
GLOBAL CONST $SIID_MEDIASVCD = 56
GLOBAL CONST $SIID_STUFFEDFOLDER = 57
GLOBAL CONST $SIID_DRIVEUNKNOWN = 58
GLOBAL CONST $SIID_DRIVEDVD = 59
GLOBAL CONST $SIID_MEDIADVD = 60
GLOBAL CONST $SIID_MEDIADVDRAM = 61
GLOBAL CONST $SIID_MEDIADVDRW = 62
GLOBAL CONST $SIID_MEDIADVDR = 63
GLOBAL CONST $SIID_MEDIADVDROM = 64
GLOBAL CONST $SIID_MEDIACDAUDIOPLUS = 65
GLOBAL CONST $SIID_MEDIACDRW = 66
GLOBAL CONST $SIID_MEDIACDR = 67
GLOBAL CONST $SIID_MEDIACDBURN = 68
GLOBAL CONST $SIID_MEDIABLANKCD = 69
GLOBAL CONST $SIID_MEDIACDROM = 70
GLOBAL CONST $SIID_AUDIOFILES = 71
GLOBAL CONST $SIID_IMAGEFILES = 72
GLOBAL CONST $SIID_VIDEOFILES = 73
GLOBAL CONST $SIID_MIXEDFILES = 74
GLOBAL CONST $SIID_FOLDERBACK = 75
GLOBAL CONST $SIID_FOLDERFRONT = 76
GLOBAL CONST $SIID_SHIELD = 77
GLOBAL CONST $SIID_WARNING = 78
GLOBAL CONST $SIID_INFO = 79
GLOBAL CONST $SIID_ERROR = 80
GLOBAL CONST $SIID_KEY = 81
GLOBAL CONST $SIID_SOFTWARE = 82
GLOBAL CONST $SIID_RENAME = 83
GLOBAL CONST $SIID_DELETE = 84
GLOBAL CONST $SIID_MEDIAAUDIODVD = 85
GLOBAL CONST $SIID_MEDIAMOVIEDVD = 86
GLOBAL CONST $SIID_MEDIAENHANCEDCD = 87
GLOBAL CONST $SIID_MEDIAENHANCEDDVD = 88
GLOBAL CONST $SIID_MEDIAHDDVD = 89
GLOBAL CONST $SIID_MEDIABLURAY = 90
GLOBAL CONST $SIID_MEDIAVCD = 91
GLOBAL CONST $SIID_MEDIADVDPLUSR = 92
GLOBAL CONST $SIID_MEDIADVDPLUSRW = 93
GLOBAL CONST $SIID_DESKTOPPC = 94
GLOBAL CONST $SIID_MOBILEPC = 95
GLOBAL CONST $SIID_USERS = 96
GLOBAL CONST $SIID_MEDIASMARTMEDIA = 97
GLOBAL CONST $SIID_MEDIACOMPACTFLASH = 98
GLOBAL CONST $SIID_DEVICECELLPHONE = 99
GLOBAL CONST $SIID_DEVICECAMERA = 100
GLOBAL CONST $SIID_DEVICEVIDEOCAMERA = 101
GLOBAL CONST $SIID_DEVICEAUDIOPLAYER = 102
GLOBAL CONST $SIID_NETWORKCONNECT = 103
GLOBAL CONST $SIID_INTERNET = 104
GLOBAL CONST $SIID_ZIPFILE = 105
GLOBAL CONST $SIID_SETTINGS = 106
GLOBAL CONST $SIID_DRIVEHDDVD = 132
GLOBAL CONST $SIID_DRIVEBD = 133
GLOBAL CONST $SIID_MEDIAHDDVDROM = 134
GLOBAL CONST $SIID_MEDIAHDDVDR = 135
GLOBAL CONST $SIID_MEDIAHDDVDRAM = 136
GLOBAL CONST $SIID_MEDIABDROM = 137
GLOBAL CONST $SIID_MEDIABDR = 138
GLOBAL CONST $SIID_MEDIABDRE = 139
GLOBAL CONST $SIID_CLUSTEREDDRIVE = 140
GLOBAL CONST $SIID_MAX_ICONS = 174
GLOBAL CONST $SHGSI_ICONLOCATION = 0
GLOBAL CONST $SHGSI_ICON = $SHGFI_ICON
GLOBAL CONST $SHGSI_SYSICONINDEX = $SHGFI_SYSICONINDEX
GLOBAL CONST $SHGSI_LINKOVERLAY = $SHGFI_LINKOVERLAY
GLOBAL CONST $SHGSI_SELECTED = $SHGFI_SELECTED
GLOBAL CONST $SHGSI_LARGEICON = $SHGFI_LARGEICON
GLOBAL CONST $SHGSI_SMALLICON = $SHGFI_SMALLICON
GLOBAL CONST $SHGSI_SHELLICONSIZE = $SHGFI_SHELLICONSIZE
GLOBAL CONST $NIM_ADD = 0
GLOBAL CONST $NIM_MODIFY = 1
GLOBAL CONST $NIM_DELETE = 2
GLOBAL CONST $NIM_SETFOCUS = 3
GLOBAL CONST $NIM_SETVERSION = 4
GLOBAL CONST $NIF_MESSAGE = 1
GLOBAL CONST $NIF_ICON = 2
GLOBAL CONST $NIF_TIP = 4
GLOBAL CONST $NIF_STATE = 8
GLOBAL CONST $NIF_INFO = 16
GLOBAL CONST $NIF_GUID = 32
GLOBAL CONST $NIF_REALTIME = 64
GLOBAL CONST $NIF_SHOWTIP = 128
GLOBAL CONST $NIS_HIDDEN = 1
GLOBAL CONST $NIS_SHAREDICON = 2
GLOBAL CONST $NIIF_NONE = 0
GLOBAL CONST $NIIF_INFO = 1
GLOBAL CONST $NIIF_WARNING = 2
GLOBAL CONST $NIIF_ERROR = 3
GLOBAL CONST $NIIF_USER = 4
GLOBAL CONST $NIIF_NOSOUND = 16
GLOBAL CONST $NIIF_LARGE_ICON = 16
GLOBAL CONST $NIIF_RESPECT_QUIET_TIME = 128
GLOBAL CONST $NIIF_ICON_MASK = 15
GLOBAL CONST $SHOP_PRINTERNAME = 1
GLOBAL CONST $SHOP_FILEPATH = 2
GLOBAL CONST $SHOP_VOLUMEGUID = 4
GLOBAL CONST $OFASI_EDIT = 1
GLOBAL CONST $OFASI_OPENDESKTOP = 2
GLOBAL CONST $QUNS_NOT_PRESENT = 1
GLOBAL CONST $QUNS_BUSY = 2
GLOBAL CONST $QUNS_RUNNING_D3D_FULL_SCREEN = 3
GLOBAL CONST $QUNS_PRESENTATION_MODE = 4
GLOBAL CONST $QUNS_ACCEPTS_NOTIFICATIONS = 5
GLOBAL CONST $QUNS_QUIET_TIME = 6
GLOBAL CONST $REST_NORUN = 1
GLOBAL CONST $REST_NOCLOSE = 2
GLOBAL CONST $REST_NOSAVESET = 3
GLOBAL CONST $REST_NOFILEMENU = 4
GLOBAL CONST $REST_NOSETFOLDERS = 5
GLOBAL CONST $REST_NOSETTASKBAR = 6
GLOBAL CONST $REST_NODESKTOP = 7
GLOBAL CONST $REST_NOFIND = 8
GLOBAL CONST $REST_NODRIVES = 9
GLOBAL CONST $REST_NODRIVEAUTORUN = 10
GLOBAL CONST $REST_NODRIVETYPEAUTORUN = 11
GLOBAL CONST $REST_NONETHOOD = 12
GLOBAL CONST $REST_STARTBANNER = 13
GLOBAL CONST $REST_RESTRICTRUN = 14
GLOBAL CONST $REST_NOPRINTERTABS = 15
GLOBAL CONST $REST_NOPRINTERDELETE = 16
GLOBAL CONST $REST_NOPRINTERADD = 17
GLOBAL CONST $REST_NOSTARTMENUSUBFOLDERS = 18
GLOBAL CONST $REST_MYDOCSONNET = 19
GLOBAL CONST $REST_NOEXITTODOS = 20
GLOBAL CONST $REST_ENFORCESHELLEXTSECURITY = 21
GLOBAL CONST $REST_LINKRESOLVEIGNORELINKINFO = 22
GLOBAL CONST $REST_NOCOMMONGROUPS = 23
GLOBAL CONST $REST_SEPARATEDESKTOPPROCESS = 24
GLOBAL CONST $REST_NOWEB = 25
GLOBAL CONST $REST_NOTRAYCONTEXTMENU = 26
GLOBAL CONST $REST_NOVIEWCONTEXTMENU = 27
GLOBAL CONST $REST_NONETCONNECTDISCONNECT = 28
GLOBAL CONST $REST_STARTMENULOGOFF = 29
GLOBAL CONST $REST_NOSETTINGSASSIST = 30
GLOBAL CONST $REST_NOINTERNETICON = 31
GLOBAL CONST $REST_NORECENTDOCSHISTORY = 32
GLOBAL CONST $REST_NORECENTDOCSMENU = 33
GLOBAL CONST $REST_NOACTIVEDESKTOP = 34
GLOBAL CONST $REST_NOACTIVEDESKTOPCHANGES = 35
GLOBAL CONST $REST_NOFAVORITESMENU = 36
GLOBAL CONST $REST_CLEARRECENTDOCSONEXIT = 37
GLOBAL CONST $REST_CLASSICSHELL = 38
GLOBAL CONST $REST_NOCUSTOMIZEWEBVIEW = 39
GLOBAL CONST $REST_NOHTMLWALLPAPER = 40
GLOBAL CONST $REST_NOCHANGINGWALLPAPER = 41
GLOBAL CONST $REST_NODESKCOMP = 42
GLOBAL CONST $REST_NOADDDESKCOMP = 43
GLOBAL CONST $REST_NODELDESKCOMP = 44
GLOBAL CONST $REST_NOCLOSEDESKCOMP = 45
GLOBAL CONST $REST_NOCLOSE_DRAGDROPBAND = 46
GLOBAL CONST $REST_NOMOVINGBAND = 47
GLOBAL CONST $REST_NOEDITDESKCOMP = 48
GLOBAL CONST $REST_NORESOLVESEARCH = 49
GLOBAL CONST $REST_NORESOLVETRACK = 50
GLOBAL CONST $REST_FORCECOPYACLWITHFILE = 51
GLOBAL CONST $REST_NOLOGO3CHANNELNOTIFY = 52
GLOBAL CONST $REST_NOFORGETSOFTWAREUPDATE = 53
GLOBAL CONST $REST_NOSETACTIVEDESKTOP = 54
GLOBAL CONST $REST_NOUPDATEWINDOWS = 55
GLOBAL CONST $REST_NOCHANGESTARMENU = 56
GLOBAL CONST $REST_NOFOLDEROPTIONS = 57
GLOBAL CONST $REST_HASFINDCOMPUTERS = 58
GLOBAL CONST $REST_INTELLIMENUS = 59
GLOBAL CONST $REST_RUNDLGMEMCHECKBOX = 60
GLOBAL CONST $REST_ARP_SHOWPOSTSETUP = 61
GLOBAL CONST $REST_NOCSC = 62
GLOBAL CONST $REST_NOCONTROLPANEL = 63
GLOBAL CONST $REST_ENUMWORKGROUP = 64
GLOBAL CONST $REST_ARP_NOARP = 65
GLOBAL CONST $REST_ARP_NOREMOVEPAGE = 66
GLOBAL CONST $REST_ARP_NOADDPAGE = 67
GLOBAL CONST $REST_ARP_NOWINSETUPPAGE = 68
GLOBAL CONST $REST_GREYMSIADS = 69
GLOBAL CONST $REST_NOCHANGEMAPPEDDRIVELABEL = 70
GLOBAL CONST $REST_NOCHANGEMAPPEDDRIVECOMMENT = 71
GLOBAL CONST $REST_MAXRECENTDOCS = 72
GLOBAL CONST $REST_NONETWORKCONNECTIONS = 73
GLOBAL CONST $REST_FORCESTARTMENULOGOFF = 74
GLOBAL CONST $REST_NOWEBVIEW = 75
GLOBAL CONST $REST_NOCUSTOMIZETHISFOLDER = 76
GLOBAL CONST $REST_NOENCRYPTION = 77
GLOBAL CONST $REST_DONTSHOWSUPERHIDDEN = 78
GLOBAL CONST $REST_NOSHELLSEARCHBUTTON = 79
GLOBAL CONST $REST_NOHARDWARETAB = 80
GLOBAL CONST $REST_NORUNASINSTALLPROMPT = 81
GLOBAL CONST $REST_PROMPTRUNASINSTALLNETPATH = 82
GLOBAL CONST $REST_NOMANAGEMYCOMPUTERVERB = 83
GLOBAL CONST $REST_NORECENTDOCSNETHOOD = 84
GLOBAL CONST $REST_DISALLOWRUN = 85
GLOBAL CONST $REST_NOWELCOMESCREEN = 86
GLOBAL CONST $REST_RESTRICTCPL = 87
GLOBAL CONST $REST_DISALLOWCPL = 88
GLOBAL CONST $REST_NOSMBALLOONTIP = 89
GLOBAL CONST $REST_NOSMHELP = 90
GLOBAL CONST $REST_NOWINKEYS = 91
GLOBAL CONST $REST_NOENCRYPTONMOVE = 92
GLOBAL CONST $REST_NOLOCALMACHINERUN = 93
GLOBAL CONST $REST_NOCURRENTUSERRUN = 94
GLOBAL CONST $REST_NOLOCALMACHINERUNONCE = 95
GLOBAL CONST $REST_NOCURRENTUSERRUNONCE = 96
GLOBAL CONST $REST_FORCEACTIVEDESKTOPON = 97
GLOBAL CONST $REST_NOCOMPUTERSNEARME = 98
GLOBAL CONST $REST_NOVIEWONDRIVE = 99
GLOBAL CONST $REST_NONETCRAWL = 100
GLOBAL CONST $REST_NOSHAREDDOCUMENTS = 101
GLOBAL CONST $REST_NOSMMYDOCS = 102
GLOBAL CONST $REST_NOSMMYPICS = 103
GLOBAL CONST $REST_ALLOWBITBUCKDRIVES = 104
GLOBAL CONST $REST_NONLEGACYSHELLMODE = 105
GLOBAL CONST $REST_NOCONTROLPANELBARRICADE = 106
GLOBAL CONST $REST_NOSTARTPAGE = 107
GLOBAL CONST $REST_NOAUTOTRAYNOTIFY = 108
GLOBAL CONST $REST_NOTASKGROUPING = 109
GLOBAL CONST $REST_NOCDBURNING = 110
GLOBAL CONST $REST_MYCOMPNOPROP = 111
GLOBAL CONST $REST_MYDOCSNOPROP = 112
GLOBAL CONST $REST_NOSTARTPANEL = 113
GLOBAL CONST $REST_NODISPLAYAPPEARANCEPAGE = 114
GLOBAL CONST $REST_NOTHEMESTAB = 115
GLOBAL CONST $REST_NOVISUALSTYLECHOICE = 116
GLOBAL CONST $REST_NOSIZECHOICE = 117
GLOBAL CONST $REST_NOCOLORCHOICE = 118
GLOBAL CONST $REST_SETVISUALSTYLE = 119
GLOBAL CONST $REST_STARTRUNNOHOMEPATH = 120
GLOBAL CONST $REST_NOUSERNAMEINSTARTPANEL = 121
GLOBAL CONST $REST_NOMYCOMPUTERICON = 122
GLOBAL CONST $REST_NOSMNETWORKPLACES = 123
GLOBAL CONST $REST_NOSMPINNEDLIST = 124
GLOBAL CONST $REST_NOSMMYMUSIC = 125
GLOBAL CONST $REST_NOSMEJECTPC = 126
GLOBAL CONST $REST_NOSMMOREPROGRAMS = 127
GLOBAL CONST $REST_NOSMMFUPROGRAMS = 128
GLOBAL CONST $REST_NOTRAYITEMSDISPLAY = 129
GLOBAL CONST $REST_NOTOOLBARSONTASKBAR = 130
GLOBAL CONST $REST_NOSMCONFIGUREPROGRAMS = 131
GLOBAL CONST $REST_HIDECLOCK = 132
GLOBAL CONST $REST_NOLOWDISKSPACECHECKS = 133
GLOBAL CONST $REST_NOENTIRENETWORK = 134
GLOBAL CONST $REST_NODESKTOPCLEANUP = 135
GLOBAL CONST $REST_BITBUCKNUKEONDELETE = 136
GLOBAL CONST $REST_BITBUCKCONFIRMDELETE = 137
GLOBAL CONST $REST_BITBUCKNOPROP = 138
GLOBAL CONST $REST_NODISPBACKGROUND = 139
GLOBAL CONST $REST_NODISPSCREENSAVEPG = 140
GLOBAL CONST $REST_NODISPSETTINGSPG = 141
GLOBAL CONST $REST_NODISPSCREENSAVEPREVIEW = 142
GLOBAL CONST $REST_NODISPLAYCPL = 143
GLOBAL CONST $REST_HIDERUNASVERB = 144
GLOBAL CONST $REST_NOTHUMBNAILCACHE = 145
GLOBAL CONST $REST_NOSTRCMPLOGICAL = 146
GLOBAL CONST $REST_NOPUBLISHWIZARD = 147
GLOBAL CONST $REST_NOONLINEPRINTSWIZARD = 148
GLOBAL CONST $REST_NOWEBSERVICES = 149
GLOBAL CONST $REST_ALLOWUNHASHEDWEBVIEW = 150
GLOBAL CONST $REST_ALLOWLEGACYWEBVIEW = 151
GLOBAL CONST $REST_REVERTWEBVIEWSECURITY = 152
GLOBAL CONST $REST_INHERITCONSOLEHANDLES = 153
GLOBAL CONST $REST_SORTMAXITEMCOUNT = 154
GLOBAL CONST $REST_NOREMOTERECURSIVEEVENTS = 155
GLOBAL CONST $REST_NOREMOTECHANGENOTIFY = 156
GLOBAL CONST $REST_NOSIMPLENETIDLIST = 157
GLOBAL CONST $REST_NOENUMENTIRENETWORK = 158
GLOBAL CONST $REST_NODETAILSTHUMBNAILONNETWORK = 159
GLOBAL CONST $REST_NOINTERNETOPENWITH = 160
GLOBAL CONST $REST_ALLOWLEGACYLMZBEHAVIOR = 161
GLOBAL CONST $REST_DONTRETRYBADNETNAME = 162
GLOBAL CONST $REST_ALLOWFILECLSIDJUNCTIONS = 163
GLOBAL CONST $REST_NOUPNPINSTALL = 164
GLOBAL CONST $REST_ARP_DONTGROUPPATCHES = 165
GLOBAL CONST $REST_ARP_NOCHOOSEPROGRAMSPAGE = 166
GLOBAL CONST $REST_NODISCONNECT = 167
GLOBAL CONST $REST_NOSECURITY = 168
GLOBAL CONST $REST_NOFILEASSOCIATE = 169
GLOBAL CONST $REST_ALLOWCOMMENTTOGGLE = 170
GLOBAL CONST $REST_USEDESKTOPINICACHE = 171
GLOBAL CONST $GIL_DONTCACHE = 16
GLOBAL CONST $GIL_NOTFILENAME = 8
GLOBAL CONST $GIL_PERCLASS = 4
GLOBAL CONST $GIL_PERINSTANCE = 2
GLOBAL CONST $GIL_SIMULATEDOC = 1
GLOBAL CONST $GIL_SHIELD = 512
GLOBAL CONST $GIL_FORCENOSHIELD = 1024
GLOBAL CONST $FOLDERID_ADDNEWPROGRAMS = "{DE61D971-5EBC-4F02-A3A9-6C82895E5C04}"
GLOBAL CONST $FOLDERID_ADMINTOOLS = "{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"
GLOBAL CONST $FOLDERID_APPUPDATES = "{A305CE99-F527-492B-8B1A-7E76FA98D6E4}"
GLOBAL CONST $FOLDERID_CDBURNING = "{9E52AB10-F80D-49DF-ACB8-4330F5687855}"
GLOBAL CONST $FOLDERID_CHANGEREMOVEPROGRAMS = "{DF7266AC-9274-4867-8D55-3BD661DE872D}"
GLOBAL CONST $FOLDERID_COMMONADMINTOOLS = "{D0384E7D-BAC3-4797-8F14-CBA229B392B5}"
GLOBAL CONST $FOLDERID_COMMONOEMLINKS = "{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}"
GLOBAL CONST $FOLDERID_COMMONPROGRAMS = "{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}"
GLOBAL CONST $FOLDERID_COMMONSTARTMENU = "{A4115719-D62E-491D-AA7C-E74B8BE3B067}"
GLOBAL CONST $FOLDERID_COMMONSTARTUP = "{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"
GLOBAL CONST $FOLDERID_COMMONTEMPLATES = "{B94237E7-57AC-4347-9151-B08C6C32D1F7}"
GLOBAL CONST $FOLDERID_COMPUTERFOLDER = "{0AC0837C-BBF8-452A-850D-79D08E667CA7}"
GLOBAL CONST $FOLDERID_CONFLICTFOLDER = "{4BFEFB45-347D-4006-A5BE-AC0CB0567192}"
GLOBAL CONST $FOLDERID_CONNECTIONSFOLDER = "{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}"
GLOBAL CONST $FOLDERID_CONTACTS = "{56784854-C6CB-462B-8169-88E350ACB882}"
GLOBAL CONST $FOLDERID_CONTROLPANELFOLDER = "{82A74AEB-AEB4-465C-A014-D097EE346D63}"
GLOBAL CONST $FOLDERID_COOKIES = "{2B0F765D-C0E9-4171-908E-08A611B84FF6}"
GLOBAL CONST $FOLDERID_DESKTOP = "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}"
GLOBAL CONST $FOLDERID_DEVICEMETADATASTORE = "{5CE4A5E9-E4EB-479D-B89F-130C02886155}"
GLOBAL CONST $FOLDERID_DOCUMENTSLIBRARY = "{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}"
GLOBAL CONST $FOLDERID_DOWNLOADS = "{374DE290-123F-4565-9164-39C4925E467B}"
GLOBAL CONST $FOLDERID_FAVORITES = "{1777F761-68AD-4D8A-87BD-30B759FA33DD}"
GLOBAL CONST $FOLDERID_FONTS = "{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}"
GLOBAL CONST $FOLDERID_GAMES = "{CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434}"
GLOBAL CONST $FOLDERID_GAMETASKS = "{054FAE61-4DD8-4787-80B6-090220C4B700}"
GLOBAL CONST $FOLDERID_HISTORY = "{D9DC8A3B-B784-432E-A781-5A1130A75963}"
GLOBAL CONST $FOLDERID_HOMEGROUP = "{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}"
GLOBAL CONST $FOLDERID_IMPLICITAPPSHORTCUTS = "{BCB5256F-79F6-4CEE-B725-DC34E402FD46}"
GLOBAL CONST $FOLDERID_INTERNETCACHE = "{352481E8-33BE-4251-BA85-6007CAEDCF9D}"
GLOBAL CONST $FOLDERID_INTERNETFOLDER = "{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}"
GLOBAL CONST $FOLDERID_LIBRARIES = "{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}"
GLOBAL CONST $FOLDERID_LINKS = "{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}"
GLOBAL CONST $FOLDERID_LOCALAPPDATA = "{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}"
GLOBAL CONST $FOLDERID_LOCALAPPDATALOW = "{A520A1A4-1780-4FF6-BD18-167343C5AF16}"
GLOBAL CONST $FOLDERID_LOCALIZEDRESOURCESDIR = "{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}"
GLOBAL CONST $FOLDERID_MUSIC = "{4BD8D571-6D19-48D3-BE97-422220080E43}"
GLOBAL CONST $FOLDERID_MUSICLIBRARY = "{2112AB0A-C86A-4FFE-A368-0DE96E47012E}"
GLOBAL CONST $FOLDERID_NETHOOD = "{C5ABBF53-E17F-4121-8900-86626FC2C973}"
GLOBAL CONST $FOLDERID_NETWORKFOLDER = "{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}"
GLOBAL CONST $FOLDERID_ORIGINALIMAGES = "{2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39}"
GLOBAL CONST $FOLDERID_PHOTOALBUMS = "{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}"
GLOBAL CONST $FOLDERID_PICTURESLIBRARY = "{A990AE9F-A03B-4E80-94BC-9912D7504104}"
GLOBAL CONST $FOLDERID_PICTURES = "{33E28130-4E1E-4676-835A-98395C3BC3BB}"
GLOBAL CONST $FOLDERID_PLAYLISTS = "{DE92C1C7-837F-4F69-A3BB-86E631204A23}"
GLOBAL CONST $FOLDERID_PRINTERSFOLDER = "{76FC4E2D-D6AD-4519-A663-37BD56068185}"
GLOBAL CONST $FOLDERID_PRINTHOOD = "{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}"
GLOBAL CONST $FOLDERID_PROFILE = "{5E6C858F-0E22-4760-9AFE-EA3317B67173}"
GLOBAL CONST $FOLDERID_PROGRAMDATA = "{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}"
GLOBAL CONST $FOLDERID_PROGRAMFILES = "{905E63B6-C1BF-494E-B29C-65B732D3D21A}"
GLOBAL CONST $FOLDERID_PROGRAMFILESX64 = "{6D809377-6AF0-444B-8957-A3773F02200E}"
GLOBAL CONST $FOLDERID_PROGRAMFILESX86 = "{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}"
GLOBAL CONST $FOLDERID_PROGRAMFILESCOMMON = "{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}"
GLOBAL CONST $FOLDERID_PROGRAMFILESCOMMONX64 = "{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}"
GLOBAL CONST $FOLDERID_PROGRAMFILESCOMMONX86 = "{DE974D24-D9C6-4D3E-BF91-F4455120B917}"
GLOBAL CONST $FOLDERID_PROGRAMS = "{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}"
GLOBAL CONST $FOLDERID_PUBLIC = "{DFDF76A2-C82A-4D63-906A-5644AC457385}"
GLOBAL CONST $FOLDERID_PUBLICDESKTOP = "{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}"
GLOBAL CONST $FOLDERID_PUBLICDOCUMENTS = "{ED4824AF-DCE4-45A8-81E2-FC7965083634}"
GLOBAL CONST $FOLDERID_PUBLICDOWNLOADS = "{3D644C9B-1FB8-4F30-9B45-F670235F79C0}"
GLOBAL CONST $FOLDERID_PUBLICGAMETASKS = "{DEBF2536-E1A8-4C59-B6A2-414586476AEA}"
GLOBAL CONST $FOLDERID_PUBLICLIBRARIES = "{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}"
GLOBAL CONST $FOLDERID_PUBLICMUSIC = "{3214FAB5-9757-4298-BB61-92A9DEAA44FF}"
GLOBAL CONST $FOLDERID_PUBLICPICTURES = "{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}"
GLOBAL CONST $FOLDERID_PUBLICRINGTONES = "{E555AB60-153B-4D17-9F04-A5FE99FC15EC}"
GLOBAL CONST $FOLDERID_PUBLICVIDEOS = "{2400183A-6185-49FB-A2D8-4A392A602BA3}"
GLOBAL CONST $FOLDERID_QUICKLAUNCH = "{52A4F021-7B75-48A9-9F6B-4B87A210BC8F}"
GLOBAL CONST $FOLDERID_RECENT = "{AE50C081-EBD2-438A-8655-8A092E34987A}"
GLOBAL CONST $FOLDERID_RECORDEDTVLIBRARY = "{1A6FDBA2-F42D-4358-A798-B74D745926C5}"
GLOBAL CONST $FOLDERID_RECYCLEBINFOLDER = "{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}"
GLOBAL CONST $FOLDERID_RESOURCEDIR = "{8AD10C31-2ADB-4296-A8F7-E4701232C972}"
GLOBAL CONST $FOLDERID_RINGTONES = "{C870044B-F49E-4126-A9C3-B52A1FF411E8}"
GLOBAL CONST $FOLDERID_ROAMINGAPPDATA = "{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}"
GLOBAL CONST $FOLDERID_SAMPLEMUSIC = "{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}"
GLOBAL CONST $FOLDERID_SAMPLEPICTURES = "{C4900540-2379-4C75-844B-64E6FAF8716B}"
GLOBAL CONST $FOLDERID_SAMPLEPLAYLISTS = "{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}"
GLOBAL CONST $FOLDERID_SAMPLEVIDEOS = "{859EAD94-2E85-48AD-A71A-0969CB56A6CD}"
GLOBAL CONST $FOLDERID_SAVEDGAMES = "{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}"
GLOBAL CONST $FOLDERID_SAVEDSEARCHES = "{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}"
GLOBAL CONST $FOLDERID_SEARCH_CSC = "{EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E}"
GLOBAL CONST $FOLDERID_SEARCH_MAPI = "{98EC0E18-2098-4D44-8644-66979315A281}"
GLOBAL CONST $FOLDERID_SEARCHHOME = "{190337D1-B8CA-4121-A639-6D472D16972A}"
GLOBAL CONST $FOLDERID_SENDTO = "{8983036C-27C0-404B-8F08-102D10DCFD74}"
GLOBAL CONST $FOLDERID_SIDEBARDEFAULTPARTS = "{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}"
GLOBAL CONST $FOLDERID_SIDEBARPARTS = "{A75D362E-50FC-4FB7-AC2C-A8BEAA314493}"
GLOBAL CONST $FOLDERID_STARTMENU = "{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}"
GLOBAL CONST $FOLDERID_STARTUP = "{B97D20BB-F46A-4C97-BA10-5E3608430854}"
GLOBAL CONST $FOLDERID_SYNCMANAGERFOLDER = "{43668BF8-C14E-49B2-97C9-747784D784B7}"
GLOBAL CONST $FOLDERID_SYNCRESULTSFOLDER = "{289A9A43-BE44-4057-A41B-587A76D7E7F9}"
GLOBAL CONST $FOLDERID_SYNCSETUPFOLDER = "{0F214138-B1D3-4A90-BBA9-27CBC0C5389A}"
GLOBAL CONST $FOLDERID_SYSTEM = "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}"
GLOBAL CONST $FOLDERID_SYSTEMX86 = "{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}"
GLOBAL CONST $FOLDERID_TEMPLATES = "{A63293E8-664E-48DB-A079-DF759E0509F7}"
GLOBAL CONST $FOLDERID_USERPINNED = "{9E3995AB-1F9C-4F13-B827-48B24B6C7174}"
GLOBAL CONST $FOLDERID_USERPROFILES = "{0762D272-C50A-4BB0-A382-697DCD729B80}"
GLOBAL CONST $FOLDERID_USERPROGRAMFILES = "{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}"
GLOBAL CONST $FOLDERID_USERPROGRAMFILESCOMMON = "{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}"
GLOBAL CONST $FOLDERID_USERSFILES = "{F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F}"
GLOBAL CONST $FOLDERID_USERSLIBRARIES = "{A302545D-DEFF-464B-ABE8-61C8648D939B}"
GLOBAL CONST $FOLDERID_VIDEOS = "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}"
GLOBAL CONST $FOLDERID_VIDEOSLIBRARY = "{491E922F-5643-4AF4-A7EB-4E7A138D8174}"
GLOBAL CONST $FOLDERID_WINDOWS = "{F38BF404-1D43-42F2-9305-67DE0B28FC23}"
GLOBAL CONST $KF_FLAG_ALIAS_ONLY = -2147483648
GLOBAL CONST $KF_FLAG_CREATE = 32768
GLOBAL CONST $KF_FLAG_DONT_VERIFY = 16384
GLOBAL CONST $KF_FLAG_DONT_UNEXPAND = 8192
GLOBAL CONST $KF_FLAG_NO_ALIAS = 4096
GLOBAL CONST $KF_FLAG_INIT = 2048
GLOBAL CONST $KF_FLAG_DEFAULT_PATH = 1024
GLOBAL CONST $KF_FLAG_NO_APPCONTAINER_REDIRECTION = 65536
GLOBAL CONST $KF_FLAG_NOT_PARENT_RELATIVE = 512
GLOBAL CONST $KF_FLAG_SIMPLE_IDLIST = 256
GLOBAL CONST $URL_SCHEME_INVALID = -1
GLOBAL CONST $URL_SCHEME_UNKNOWN = 0
GLOBAL CONST $URL_SCHEME_FTP = 1
GLOBAL CONST $URL_SCHEME_HTTP = 2
GLOBAL CONST $URL_SCHEME_GOPHER = 3
GLOBAL CONST $URL_SCHEME_MAILTO = 4
GLOBAL CONST $URL_SCHEME_NEWS = 5
GLOBAL CONST $URL_SCHEME_NNTP = 6
GLOBAL CONST $URL_SCHEME_TELNET = 7
GLOBAL CONST $URL_SCHEME_WAIS = 8
GLOBAL CONST $URL_SCHEME_FILE = 9
GLOBAL CONST $URL_SCHEME_MK = 10
GLOBAL CONST $URL_SCHEME_HTTPS = 11
GLOBAL CONST $URL_SCHEME_SHELL = 12
GLOBAL CONST $URL_SCHEME_SNEWS = 13
GLOBAL CONST $URL_SCHEME_LOCAL = 14
GLOBAL CONST $URL_SCHEME_JAVASCRIPT = 15
GLOBAL CONST $URL_SCHEME_VBSCRIPT = 16
GLOBAL CONST $URL_SCHEME_ABOUT = 17
GLOBAL CONST $URL_SCHEME_RES = 18
GLOBAL CONST $URL_SCHEME_MSSHELLROOTED = 19
GLOBAL CONST $URL_SCHEME_MSSHELLIDLIST = 20
GLOBAL CONST $URL_SCHEME_MSHELP = 21
GLOBAL CONST $URL_SCHEME_MSSHELLDEVICE = 22
GLOBAL CONST $URL_SCHEME_WILDCARD = 23
GLOBAL CONST $URL_SCHEME_SEARCH_MS = 24
GLOBAL CONST $URL_SCHEME_SEARCH = 25
GLOBAL CONST $URL_SCHEME_KNOWNFOLDER = 26
GLOBAL CONST $GCT_INVALID = 0
GLOBAL CONST $GCT_LFNCHAR = 1
GLOBAL CONST $GCT_SEPARATOR = 8
GLOBAL CONST $GCT_SHORTCHAR = 2
GLOBAL CONST $GCT_WILD = 4
GLOBAL CONST $URL_APPLY_DEFAULT = 1
GLOBAL CONST $URL_APPLY_GUESSSCHEME = 2
GLOBAL CONST $URL_APPLY_GUESSFILE = 4
GLOBAL CONST $URL_APPLY_FORCEAPPLY = 8
GLOBAL CONST $URL_DONT_SIMPLIFY = 134217728
GLOBAL CONST $URL_ESCAPE_AS_UTF8 = 262144
GLOBAL CONST $URL_ESCAPE_PERCENT = 4096
GLOBAL CONST $URL_ESCAPE_SPACES_ONLY = 67108864
GLOBAL CONST $URL_ESCAPE_UNSAFE = 536870912
GLOBAL CONST $URL_NO_META = 134217728
GLOBAL CONST $URL_PLUGGABLE_PROTOCOL = 1073741824
GLOBAL CONST $URL_UNESCAPE = 268435456
GLOBAL CONST $URL_PART_HOSTNAME = 2
GLOBAL CONST $URL_PART_PASSWORD = 4
GLOBAL CONST $URL_PART_PORT = 5
GLOBAL CONST $URL_PART_QUERY = 6
GLOBAL CONST $URL_PART_SCHEME = 1
GLOBAL CONST $URL_PART_USERNAME = 3
GLOBAL CONST $URLIS_APPLIABLE = 4
GLOBAL CONST $URLIS_DIRECTORY = 5
GLOBAL CONST $URLIS_FILEURL = 3
GLOBAL CONST $URLIS_HASQUERY = 6
GLOBAL CONST $URLIS_NOHISTORY = 2
GLOBAL CONST $URLIS_OPAQUE = 1
GLOBAL CONST $URLIS_URL = 0
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_COMMANDLINETOARGV($SCMD)
		LOCAL $ARET[1] = [0]
		$SCMD = STRINGSTRIPWS($SCMD, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF NOT $SCMD THEN
			RETURN $ARET
		ENDIF
		LOCAL $ACALL = DLLCALL("shell32.dll", "ptr", "CommandLineToArgvW", "wstr", $SCMD, "int*", 0)
		IF @ERROR OR NOT $ACALL[0] OR(NOT $ACALL[2]) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TPTR = DLLSTRUCTCREATE("ptr[" & $ACALL[2] & "]", $ACALL[0])
		DIM $ARET[$ACALL[2] + 1] = [$ACALL[2]]
		FOR $I = 1 TO $ACALL[2]
			$ARET[$I] = _WINAPI_GETSTRING(DLLSTRUCTGETDATA($TPTR, 1, $I))
		NEXT
		DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $ACALL[0])
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_ISNAMEINEXPRESSION($SSTRING, $SPATTERN, $BCASESENSITIVE = FALSE)
		IF NOT $BCASESENSITIVE THEN $SPATTERN = STRINGUPPER($SPATTERN)
		LOCAL $TUS1 = __US($SPATTERN)
		LOCAL $TUS2 = __US($SSTRING)
		LOCAL $ACALL = DLLCALL("ntdll.dll", "boolean", "RtlIsNameInExpression", "struct*", $TUS1, "struct*", $TUS2, "boolean", NOT $BCASESENSITIVE, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PARSEURL($SURL)
		LOCAL $TAGPARSEDURL = "dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme"
		LOCAL $TPURL = DLLSTRUCTCREATE($TAGPARSEDURL)
		DLLSTRUCTSETDATA($TPURL, 1, DLLSTRUCTGETSIZE($TPURL))
		LOCAL $TURL = DLLSTRUCTCREATE("wchar[4096]")
		DLLSTRUCTSETDATA($TURL, 1, $SURL)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "ParseURLW", "struct*", $TURL, "struct*", $TPURL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		LOCAL $ARET[3]
		$ARET[0] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & DLLSTRUCTGETDATA($TPURL, 3) & "]", DLLSTRUCTGETDATA($TPURL, 2)), 1)
		$ARET[1] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & DLLSTRUCTGETDATA($TPURL, 5) & "]", DLLSTRUCTGETDATA($TPURL, 4)), 1)
		$ARET[2] = DLLSTRUCTGETDATA($TPURL, 6)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_PARSEUSERNAME($SUSER)
		IF NOT __DLL("credui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ACALL = DLLCALL("credui.dll", "dword", "CredUIParseUserNameW", "wstr", $SUSER, "wstr", "", "ulong", 4096, "wstr", "", "ulong", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		SWITCH $ACALL[0]
			CASE 0
			CASE 1315
				IF STRINGSTRIPWS($SUSER, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
					$ACALL[2] = $SUSER
					$ACALL[4] = ""
				ELSE
					CONTINUECASE
				ENDIF
			CASE ELSE
				RETURN SETERROR(10, $ACALL[0], 0)
		ENDSWITCH
		LOCAL $ARET[2]
		$ARET[0] = $ACALL[4]
		$ARET[1] = $ACALL[2]
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_PATHADDBACKSLASH($SFILEPATH)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[260]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "ptr", "PathAddBackslashW", "struct*", $TPATH)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN DLLSTRUCTGETDATA($TPATH, 1)
	ENDFUNC
	FUNC _WINAPI_PATHADDEXTENSION($SFILEPATH, $SEXT = "")
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[260]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		IF NOT STRINGSTRIPWS($SEXT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SEXT = NULL
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathAddExtensionW", "struct*", $TPATH, "wstr", $SEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ACALL[0], DLLSTRUCTGETDATA($TPATH, 1))
	ENDFUNC
	FUNC _WINAPI_PATHAPPEND($SFILEPATH, $SMORE)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[260]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathAppendW", "struct*", $TPATH, "wstr", $SMORE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN DLLSTRUCTGETDATA($TPATH, 1)
	ENDFUNC
	FUNC _WINAPI_PATHBUILDROOT($IDRIVE)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "ptr", "PathBuildRootW", "wstr", "", "int", $IDRIVE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHCANONICALIZE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathCanonicalizeW", "wstr", "", "wstr", $SFILEPATH)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, $SFILEPATH)
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHCOMMONPREFIX($SPATH1, $SPATH2)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "int", "PathCommonPrefixW", "wstr", $SPATH1, "wstr", $SPATH2, "wstr", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ACALL[0], $ACALL[3])
	ENDFUNC
	FUNC _WINAPI_PATHCOMPACTPATH($HWND, $SFILEPATH, $IWIDTH = 0)
		IF $IWIDTH < 1 THEN
			LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
			DLLCALL("user32.dll", "bool", "GetClientRect", "hwnd", $HWND, "struct*", $TRECT)
			$IWIDTH += DLLSTRUCTGETDATA($TRECT, "Right") - DLLSTRUCTGETDATA($TRECT, "Left")
		ENDIF
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HWND)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, $SFILEPATH)
		LOCAL $HDC = $ACALL[0]
		LOCAL CONST $WM_GETFONT = 49
		$ACALL = DLLCALL("user32.dll", "ptr", "SendMessage", "hwnd", $HWND, "uint", $WM_GETFONT, "wparam", 0, "lparam", 0)
		LOCAL $HBACK = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDC, "handle", $ACALL[0])
		LOCAL $IERROR = 0
		$ACALL = DLLCALL("shlwapi.dll", "bool", "PathCompactPathW", "handle", $HDC, "wstr", $SFILEPATH, "int", $IWIDTH)
		IF @ERROR OR NOT $ACALL[0] THEN $IERROR = @ERROR + 10
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDC, "handle", $HBACK[0])
		DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", $HWND, "handle", $HDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, $SFILEPATH)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_PATHCOMPACTPATHEX($SFILEPATH, $IMAX)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathCompactPathExW", "wstr", "", "wstr", $SFILEPATH, "uint", $IMAX + 1, "dword", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, $SFILEPATH)
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHCREATEFROMURL($SURL)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "PathCreateFromUrlW", "wstr", $SURL, "wstr", "", "dword*", 4096, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_PATHFINDEXTENSION($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "wstr", "PathFindExtensionW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHFINDFILENAME($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "wstr", "PathFindFileNameW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $SFILEPATH)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHFINDNEXTCOMPONENT($SFILEPATH)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($SFILEPATH) + 1) & "]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "ptr", "PathFindNextComponentW", "struct*", $TPATH)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN _WINAPI_GETSTRING($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_PATHFINDONPATH(CONST $SFILEPATH, $AEXTRAPATHS = "", CONST $SPATHDELIMITER = @LF)
		LOCAL $IEXTRACOUNT = 0
		IF ISSTRING($AEXTRAPATHS) THEN
			IF STRINGLEN($AEXTRAPATHS) THEN
				$AEXTRAPATHS = STRINGSPLIT($AEXTRAPATHS, $SPATHDELIMITER, $STR_ENTIRESPLIT + $STR_NOCOUNT)
				$IEXTRACOUNT = UBOUND($AEXTRAPATHS, $UBOUND_ROWS)
			ENDIF
		ELSEIF ISARRAY($AEXTRAPATHS) THEN
			$IEXTRACOUNT = UBOUND($AEXTRAPATHS)
		ENDIF
		LOCAL $TPATHS, $TPATHPTRS
		IF $IEXTRACOUNT THEN
			LOCAL $TAGSTRUCT = ""
			FOR $PATH IN $AEXTRAPATHS
				$TAGSTRUCT &= "wchar[" & STRINGLEN($PATH) + 1 & "];"
			NEXT
			$TPATHS = DLLSTRUCTCREATE($TAGSTRUCT)
			$TPATHPTRS = DLLSTRUCTCREATE("ptr[" & $IEXTRACOUNT + 1 & "]")
			FOR $I = 1 TO $IEXTRACOUNT
				DLLSTRUCTSETDATA($TPATHS, $I, $AEXTRAPATHS[$I - 1])
				DLLSTRUCTSETDATA($TPATHPTRS, 1, DLLSTRUCTGETPTR($TPATHS, $I), $I)
			NEXT
			DLLSTRUCTSETDATA($TPATHPTRS, 1, PTR(0), $IEXTRACOUNT + 1)
		ENDIF
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $SFILEPATH, "struct*", $TPATHPTRS)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, $SFILEPATH)
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHGETARGS($SFILEPATH)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($SFILEPATH) + 1) & "]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "ptr", "PathGetArgsW", "struct*", $TPATH)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN _WINAPI_GETSTRING($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_PATHGETCHARTYPE($SCHAR)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "uint", "PathGetCharTypeW", "word", ASCW($SCHAR))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHGETDRIVENUMBER($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "int", "PathGetDriveNumberW", "wstr", $SFILEPATH)
		IF @ERROR OR($ACALL[0] = -1) THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN CHR($ACALL[0] + 65) & ":"
	ENDFUNC
	FUNC _WINAPI_PATHISCONTENTTYPE($SFILEPATH, $STYPE)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsContentTypeW", "wstr", $SFILEPATH, "wstr", $STYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISEXE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shell32.dll", "bool", "PathIsExe", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISFILESPEC($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsFileSpecW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISLFNFILESPEC($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsLFNFileSpecW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISRELATIVE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsRelativeW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISROOT($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsRootW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISSAMEROOT($SPATH1, $SPATH2)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsSameRootW", "wstr", $SPATH1, "wstr", $SPATH2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISSYSTEMFOLDER($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsSystemFolderW", "wstr", $SFILEPATH, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISUNC($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsUNCW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISUNCSERVER($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsUNCServerW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISUNCSERVERSHARE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsUNCServerShareW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHMAKESYSTEMFOLDER($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathMakeSystemFolderW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHMATCHSPEC($SFILEPATH, $SSPEC)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathMatchSpecW", "wstr", $SFILEPATH, "wstr", $SSPEC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHPARSEICONLOCATION($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "int", "PathParseIconLocationW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET[2]
		$ARET[0] = $ACALL[1]
		$ARET[1] = $ACALL[0]
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_PATHRELATIVEPATHTO($SPATHFROM, $BDIRFROM, $SPATHTO, $BDIRTO)
		IF $BDIRFROM THEN
			$BDIRFROM = 16
		ENDIF
		IF $BDIRTO THEN
			$BDIRTO = 16
		ENDIF
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathRelativePathToW", "wstr", "", "wstr", $SPATHFROM, "dword", $BDIRFROM, "wstr", $SPATHTO, "dword", $BDIRTO)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHREMOVEARGS($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "none", "PathRemoveArgsW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHREMOVEBACKSLASH($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "ptr", "PathRemoveBackslashW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHREMOVEEXTENSION($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "none", "PathRemoveExtensionW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHREMOVEFILESPEC($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathRemoveFileSpecW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ACALL[0], $ACALL[1])
	ENDFUNC
	FUNC _WINAPI_PATHRENAMEEXTENSION($SFILEPATH, $SEXT)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[260]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathRenameExtensionW", "struct*", $TPATH, "wstr", $SEXT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN DLLSTRUCTGETDATA($TPATH, 1)
	ENDFUNC
	FUNC _WINAPI_PATHSEARCHANDQUALIFY($SFILEPATH, $BEXISTS = FALSE)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathSearchAndQualifyW", "wstr", $SFILEPATH, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		IF $BEXISTS AND NOT FILEEXISTS($ACALL[2]) THEN RETURN SETERROR(20, 0, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_PATHSKIPROOT($SFILEPATH)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($SFILEPATH) + 1) & "]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "ptr", "PathSkipRootW", "struct*", $TPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF NOT $ACALL[0] THEN RETURN $SFILEPATH
		RETURN _WINAPI_GETSTRING($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_PATHSTRIPPATH($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "none", "PathStripPathW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHSTRIPTOROOT($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathStripToRootW", "wstr", $SFILEPATH)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHUNDECORATE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "none", "PathUndecorateW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHUNEXPANDENVSTRINGS($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathUnExpandEnvStringsW", "wstr", $SFILEPATH, "wstr", "", "uint", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_PATHUNMAKESYSTEMFOLDER($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathUnmakeSystemFolderW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHUNQUOTESPACES($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "none", "PathUnquoteSpacesW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_PATHYETANOTHERMAKEUNIQUENAME($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "PathYetAnotherMakeUniqueName", "wstr", "", "wstr", $SFILEPATH, "ptr", 0, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_SHELLGETIMAGELIST($BSMALL = FALSE)
		LOCAL $PLARGE, $PSMALL, $TPTR = DLLSTRUCTCREATE("ptr")
		IF $BSMALL THEN
			$PLARGE = 0
			$PSMALL = DLLSTRUCTGETPTR($TPTR)
		ELSE
			$PLARGE = DLLSTRUCTGETPTR($TPTR)
			$PSMALL = 0
		ENDIF
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "Shell_GetImageLists", "ptr", $PLARGE, "ptr", $PSMALL)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TPTR, 1)
	ENDFUNC
	FUNC _WINAPI_URLAPPLYSCHEME($SURL, $IFLAGS = 1)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "UrlApplySchemeW", "wstr", $SURL, "wstr", "", "dword*", 4096, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_URLCANONICALIZE($SURL, $IFLAGS)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "UrlCanonicalizeW", "wstr", $SURL, "wstr", "", "dword*", 4096, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_URLCOMBINE($SURL, $SPART, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "UrlCombineW", "wstr", $SURL, "wstr", $SPART, "wstr", "", "dword*", 4096, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_URLCOMPARE($SURL1, $SURL2, $BIGNORESLASH = FALSE)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "int", "UrlCompareW", "wstr", $SURL1, "wstr", $SURL2, "bool", $BIGNORESLASH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_URLCREATEFROMPATH($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "UrlCreateFromPathW", "wstr", $SFILEPATH, "wstr", "", "dword*", 4096, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] < 0 OR $ACALL[0] > 1 THEN
			RETURN SETERROR(10, $ACALL[0], "")
		ENDIF
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_URLFIXUP($SURL)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "UrlFixupW", "wstr", $SURL, "wstr", "", "dword", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_URLGETPART($SURL, $IPART)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "UrlGetPartW", "wstr", $SURL, "wstr", "", "dword*", 4096, "dword", $IPART, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_URLHASH($SURL, $ILENGTH = 32)
		IF $ILENGTH <= 0 OR $ILENGTH > 256 THEN RETURN SETERROR(256, 0, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & $ILENGTH & "]")
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "long", "UrlHashW", "wstr", $SURL, "struct*", $TDATA, "dword", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN DLLSTRUCTGETDATA($TDATA, 1)
	ENDFUNC
	FUNC _WINAPI_URLIS($SURL, $ITYPE = 0)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "UrlIsW", "wstr", $SURL, "uint", $ITYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __US($SSTRING, $ILENGTH = 0)
		IF $ILENGTH THEN
			$SSTRING = STRINGLEFT($SSTRING, $ILENGTH)
		ELSE
			$ILENGTH = STRINGLEN($SSTRING)
		ENDIF
		LOCAL $TUS = DLLSTRUCTCREATE("ushort;ushort;ptr;wchar[" & ($ILENGTH + 1) & "]")
		DLLSTRUCTSETDATA($TUS, 1, 2 * STRINGLEN($SSTRING))
		DLLSTRUCTSETDATA($TUS, 2, 2 * $ILENGTH)
		DLLSTRUCTSETDATA($TUS, 3, DLLSTRUCTGETPTR($TUS, 4))
		DLLSTRUCTSETDATA($TUS, 4, $SSTRING)
		RETURN $TUS
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL CONST $TAGNOTIFYICONDATA = "struct;dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar InfoTitle[64];dword InfoFlags;endstruct"
	GLOBAL CONST $TAGNOTIFYICONDATA_V3 = $TAGNOTIFYICONDATA & ";" & $TAGGUID
	GLOBAL CONST $TAGNOTIFYICONDATA_V4 = $TAGNOTIFYICONDATA_V3 & ";ptr hBalloonIcon;"
	GLOBAL CONST $TAGSHELLEXECUTEINFO = "dword Size;ulong Mask;hwnd hWnd;ptr Verb;ptr File;ptr Parameters;ptr Directory;int Show;ulong_ptr hInstApp;ptr IDList;ptr Class;ulong_ptr hKeyClass;dword HotKey;ptr hMonitor;ptr hProcess"
	GLOBAL CONST $TAGSHFILEINFO = "ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80]"
	GLOBAL CONST $TAGSHFILEOPSTRUCT = "hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle"
	GLOBAL CONST $TAGSHFOLDERCUSTOMSETTINGS = "dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword SizeIF;int IconIndex;ptr Logo;dword SizeL"
	GLOBAL CONST $TAGSHSTOCKICONINFO = "dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_DEFSUBCLASSPROC($HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ACALL = DLLCALL("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DLLGETVERSION($SFILEPATH)
		LOCAL $TVERSION = DLLSTRUCTCREATE("dword[5]")
		DLLSTRUCTSETDATA($TVERSION, 1, DLLSTRUCTGETSIZE($TVERSION), 1)
		LOCAL $ACALL = DLLCALL($SFILEPATH, "uint", "DllGetVersion", "struct*", $TVERSION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		LOCAL $ARET[4]
		FOR $I = 0 TO 3
			$ARET[$I] = DLLSTRUCTGETDATA($TVERSION, 1, $I + 2)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_FINDEXECUTABLE($SFILENAME, $SDIRECTORY = "")
		LOCAL $ACALL = DLLCALL("shell32.dll", "INT", "FindExecutableW", "wstr", $SFILENAME, "wstr", $SDIRECTORY, "wstr", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] <= 32 THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN SETEXTENDED($ACALL[0], $ACALL[3])
	ENDFUNC
	FUNC _WINAPI_GETALLUSERSPROFILEDIRECTORY()
		LOCAL $ACALL = DLLCALL("userenv.dll", "bool", "GetAllUsersProfileDirectoryW", "wstr", "", "dword*", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_GETDEFAULTUSERPROFILEDIRECTORY()
		LOCAL $ACALL = DLLCALL("userenv.dll", "bool", "GetDefaultUserProfileDirectoryW", "wstr", "", "dword*", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWSUBCLASS($HWND, $PSUBCLASSPROC, $IDSUBCLASS)
		LOCAL $ACALL = DLLCALL("comctl32.dll", "bool", "GetWindowSubclass", "hwnd", $HWND, "ptr", $PSUBCLASSPROC, "uint_ptr", $IDSUBCLASS, "dword_ptr*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[4]
	ENDFUNC
	FUNC _WINAPI_REMOVEWINDOWSUBCLASS($HWND, $PSUBCLASSPROC, $IDSUBCLASS)
		LOCAL $ACALL = DLLCALL("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $HWND, "ptr", $PSUBCLASSPROC, "uint_ptr", $IDSUBCLASS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETCURRENTPROCESSEXPLICITAPPUSERMODELID($SAPPID)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SetCurrentProcessExplicitAppUserModelID", "wstr", $SAPPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETWINDOWSUBCLASS($HWND, $PSUBCLASSPROC, $IDSUBCLASS, $PDATA = 0)
		LOCAL $ACALL = DLLCALL("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $HWND, "ptr", $PSUBCLASSPROC, "uint_ptr", $IDSUBCLASS, "dword_ptr", $PDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLADDTORECENTDOCS($SFILEPATH)
		IF STRINGSTRIPWS($SFILEPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$SFILEPATH = _WINAPI_PATHSEARCHANDQUALIFY($SFILEPATH, 1)
			IF NOT $SFILEPATH THEN
				RETURN SETERROR(1, 0, 0)
			ENDIF
		ELSE
			$SFILEPATH = NULL
		ENDIF
		DLLCALL("shell32.dll", "none", "SHAddToRecentDocs", "uint", 3, "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLCHANGENOTIFY($IEVENT, $IFLAGS, $IITEM1 = 0, $IITEM2 = 0)
		LOCAL $STYPEOFITEM1 = "dword_ptr", $STYPEOFITEM2 = "dword_ptr"
		IF ISSTRING($IITEM1) THEN
			$STYPEOFITEM1 = "wstr"
		ENDIF
		IF ISSTRING($IITEM2) THEN
			$STYPEOFITEM2 = "wstr"
		ENDIF
		DLLCALL("shell32.dll", "none", "SHChangeNotify", "long", $IEVENT, "uint", $IFLAGS, $STYPEOFITEM1, $IITEM1, $STYPEOFITEM2, $IITEM2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLCHANGENOTIFYDEREGISTER($IID)
		LOCAL $ACALL = DLLCALL("shell32.dll", "bool", "SHChangeNotifyDeregister", "ulong", $IID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLCHANGENOTIFYREGISTER($HWND, $IMSG, $IEVENTS, $ISOURCES, $APATHS, $BRECURSIVE = FALSE)
		LOCAL $IPATH = $APATHS, $TAGSTRUCT = ""
		IF ISARRAY($APATHS) THEN
			IF UBOUND($APATHS, $UBOUND_COLUMNS) THEN RETURN SETERROR(1, 0, 0)
		ELSE
			DIM $APATHS[1] = [$IPATH]
		ENDIF
		FOR $I = 0 TO UBOUND($APATHS) - 1
			IF NOT _WINAPI_PATHISDIRECTORY($APATHS[$I]) THEN RETURN SETERROR(2, 0, 0)
		NEXT
		FOR $I = 0 TO UBOUND($APATHS) - 1
			$TAGSTRUCT &= "ptr;int;"
		NEXT
		LOCAL $TENTRY = DLLSTRUCTCREATE($TAGSTRUCT)
		FOR $I = 0 TO UBOUND($APATHS) - 1
			$APATHS[$I] = _WINAPI_SHELLILCREATEFROMPATH(_WINAPI_PATHSEARCHANDQUALIFY($APATHS[$I]))
			DLLSTRUCTSETDATA($TENTRY, 2 * $I + 1, $APATHS[$I])
			DLLSTRUCTSETDATA($TENTRY, 2 * $I + 2, $BRECURSIVE)
		NEXT
		LOCAL $IERROR = 0
		LOCAL $ACALL = DLLCALL("shell32.dll", "ulong", "SHChangeNotifyRegister", "hwnd", $HWND, "int", $ISOURCES, "long", $IEVENTS, "uint", $IMSG, "int", UBOUND($APATHS), "struct*", $TENTRY)
		IF @ERROR OR NOT $ACALL[0] THEN $IERROR = @ERROR + 10
		FOR $I = 0 TO UBOUND($APATHS) - 1
			_WINAPI_COTASKMEMFREE($APATHS[$I])
		NEXT
		RETURN SETERROR($IERROR, 0, $ACALL[0])
	ENDFUNC
	FUNC _WINAPI_SHELLCREATEDIRECTORY($SFILEPATH, $HPARENT = 0, $TSECURITY = 0)
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "SHCreateDirectoryExW", "hwnd", $HPARENT, "wstr", $SFILEPATH, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLEMPTYRECYCLEBIN($SROOT = "", $IFLAGS = 0, $HPARENT = 0)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHEmptyRecycleBinW", "hwnd", $HPARENT, "wstr", $SROOT, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLEXECUTE($SFILEPATH, $SARGS = "", $SDIR = "", $SVERB = "", $ISHOW = 1, $HPARENT = 0)
		IF NOT STRINGSTRIPWS($SARGS, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SARGS = NULL
		IF NOT STRINGSTRIPWS($SDIR, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SDIR = NULL
		IF NOT STRINGSTRIPWS($SVERB, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SVERB = NULL
		LOCAL $ACALL = DLLCALL("shell32.dll", "ULONG_PTR", "ShellExecuteW", "hwnd", $HPARENT, "wstr", $SVERB, "wstr", $SFILEPATH, "wstr", $SARGS, "wstr", $SDIR, "int", $ISHOW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF $ACALL[0] <= 32 THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLEXECUTEEX(BYREF $TSHEXINFO)
		LOCAL $ACALL = DLLCALL("shell32.dll", "bool", "ShellExecuteExW", "struct*", $TSHEXINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLEXTRACTASSOCIATEDICON($SFILEPATH, $BSMALL = FALSE)
		LOCAL $IFLAGS = 256
		IF NOT _WINAPI_PATHISDIRECTORY($SFILEPATH) THEN
			$IFLAGS = BITOR($IFLAGS, 16)
		ENDIF
		IF $BSMALL THEN
			$IFLAGS = BITOR($IFLAGS, 1)
		ENDIF
		LOCAL $TSHFILEINFO = DLLSTRUCTCREATE($TAGSHFILEINFO)
		IF NOT _WINAPI_SHELLGETFILEINFO($SFILEPATH, $IFLAGS, 0, $TSHFILEINFO) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TSHFILEINFO, "hIcon")
	ENDFUNC
	FUNC _WINAPI_SHELLEXTRACTICON($SICON, $IINDEX, $IWIDTH, $IHEIGHT)
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "SHExtractIconsW", "wstr", $SICON, "int", $IINDEX, "int", $IWIDTH, "int", $IHEIGHT, "ptr*", 0, "ptr*", 0, "int", 1, "int", 0)
		IF @ERROR OR NOT $ACALL[0] OR NOT $ACALL[5] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[5]
	ENDFUNC
	FUNC _WINAPI_SHELLFILEOPERATION($SFROM, $STO, $IFUNC, $IFLAGS, $STITLE = "", $HPARENT = 0)
		LOCAL $IDATA
		IF NOT ISARRAY($SFROM) THEN
			$IDATA = $SFROM
			DIM $SFROM[1] = [$IDATA]
		ENDIF
		LOCAL $TFROM = _WINAPI_ARRAYTOSTRUCT($SFROM)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		IF NOT ISARRAY($STO) THEN
			$IDATA = $STO
			DIM $STO[1] = [$IDATA]
		ENDIF
		LOCAL $TTO = _WINAPI_ARRAYTOSTRUCT($STO)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		LOCAL $TSHFILEOPSTRUCT = DLLSTRUCTCREATE($TAGSHFILEOPSTRUCT)
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "hWnd", $HPARENT)
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "Func", $IFUNC)
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "From", DLLSTRUCTGETPTR($TFROM))
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "To", DLLSTRUCTGETPTR($TTO))
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "Flags", $IFLAGS)
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "ProgressTitle", $STITLE)
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "SHFileOperationW", "struct*", $TSHFILEOPSTRUCT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $TSHFILEOPSTRUCT
	ENDFUNC
	FUNC _WINAPI_SHELLFLUSHSFCACHE()
		DLLCALL("shell32.dll", "none", "SHFlushSFCache")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLGETFILEINFO($SFILEPATH, $IFLAGS, $IATTRIBUTES, BYREF $TSHFILEINFO)
		LOCAL $ACALL = DLLCALL("shell32.dll", "dword_ptr", "SHGetFileInfoW", "wstr", $SFILEPATH, "dword", $IATTRIBUTES, "struct*", $TSHFILEINFO, "uint", DLLSTRUCTGETSIZE($TSHFILEINFO), "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLGETICONOVERLAYINDEX($SICON, $IINDEX)
		IF NOT STRINGSTRIPWS($SICON, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SICON = NULL
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "SHGetIconOverlayIndexW", "wstr", $SICON, "int", $IINDEX)
		IF @ERROR OR($ACALL[0] = -1) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLGETKNOWNFOLDERIDLIST($SGUID, $IFLAGS = 0, $HTOKEN = 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "uint", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR OR $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		$ACALL = DLLCALL("shell32.dll", "uint", "SHGetKnownFolderIDList", "struct*", $TGUID, "dword", $IFLAGS, "handle", $HTOKEN, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[4]
	ENDFUNC
	FUNC _WINAPI_SHELLGETKNOWNFOLDERPATH($SGUID, $IFLAGS = 0, $HTOKEN = 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR OR $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$ACALL = DLLCALL("shell32.dll", "long", "SHGetKnownFolderPath", "struct*", $TGUID, "dword", $IFLAGS, "handle", $HTOKEN, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		LOCAL $SPATH = _WINAPI_GETSTRING($ACALL[4])
		_WINAPI_COTASKMEMFREE($ACALL[4])
		RETURN $SPATH
	ENDFUNC
	FUNC _WINAPI_SHELLGETLOCALIZEDNAME($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHGetLocalizedName", "wstr", $SFILEPATH, "wstr", "", "uint*", 0, "int*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		LOCAL $ARET[2]
		LOCAL $ACALL1 = DLLCALL("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $ACALL[2], "wstr", "", "dword", 4096)
		$ARET[0] = $ACALL1[2]
		$ARET[1] = $ACALL[4]
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_SHELLGETPATHFROMIDLIST($PPIDL)
		LOCAL $ACALL = DLLCALL("shell32.dll", "bool", "SHGetPathFromIDListW", "struct*", $PPIDL, "wstr", "")
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_SHELLGETSETFOLDERCUSTOMSETTINGS($SFILEPATH, $IFLAG, BYREF $TSHFCS)
		LOCAL $SPROC = "SHGetSetFolderCustomSettings"
		IF _WINAPI_GETVERSION() < 6 THEN $SPROC &= "W"
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", $SPROC, "struct*", $TSHFCS, "wstr", $SFILEPATH, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLGETSETTINGS($IFLAGS)
		LOCAL $TSHELLSTATE = DLLSTRUCTCREATE("uint[8]")
		DLLCALL("shell32.dll", "none", "SHGetSetSettings", "struct*", $TSHELLSTATE, "dword", $IFLAGS, "bool", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $IVAL1 = DLLSTRUCTGETDATA($TSHELLSTATE, 1, 1)
		LOCAL $IVAL2 = DLLSTRUCTGETDATA($TSHELLSTATE, 1, 8)
		LOCAL $IRESULT = 0
		LOCAL $AOPT[20][2] = [[1, 1], [2, 2], [4, 32768], [8, 32], [16, 8], [32, 128], [64, 512], [128, 1024], [256, 2048], [1024, 4096], [2048, 8192], [4096, 16384], [8192, 131072], [32768, 262144], [65536, 1048576], [1, 524288], [2, 2097152], [8, 8388608], [16, 16777216], [32, 33554432]]
		FOR $I = 0 TO 14
			IF BITAND($IVAL1, $AOPT[$I][0]) THEN
				$IRESULT += $AOPT[$I][1]
			ENDIF
		NEXT
		FOR $I = 15 TO 19
			IF BITAND($IVAL2, $AOPT[$I][0]) THEN
				$IRESULT += $AOPT[$I][1]
			ENDIF
		NEXT
		RETURN $IRESULT
	ENDFUNC
	FUNC _WINAPI_SHELLGETSPECIALFOLDERLOCATION($ICSIDL)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHGetSpecialFolderLocation", "hwnd", 0, "int", $ICSIDL, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_SHELLGETSPECIALFOLDERPATH($ICSIDL, $BCREATE = FALSE)
		LOCAL $ACALL = DLLCALL("shell32.dll", "bool", "SHGetSpecialFolderPathW", "hwnd", 0, "wstr", "", "int", $ICSIDL, "bool", $BCREATE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_SHELLGETSTOCKICONINFO($ISIID, $IFLAGS)
		LOCAL $TSHSTOCKICONINFO = DLLSTRUCTCREATE($TAGSHSTOCKICONINFO)
		DLLSTRUCTSETDATA($TSHSTOCKICONINFO, "Size", DLLSTRUCTGETSIZE($TSHSTOCKICONINFO))
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHGetStockIconInfo", "int", $ISIID, "uint", $IFLAGS, "struct*", $TSHSTOCKICONINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $TSHSTOCKICONINFO
	ENDFUNC
	FUNC _WINAPI_SHELLILCREATEFROMPATH($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHILCreateFromPath", "wstr", $SFILEPATH, "ptr*", 0, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_SHELLNOTIFYICON($IMESSAGE, BYREF $TNOTIFYICONDATA)
		LOCAL $ACALL = DLLCALL("shell32.dll", "bool", "Shell_NotifyIconW", "dword", $IMESSAGE, "struct*", $TNOTIFYICONDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLNOTIFYICONGETRECT($HWND, $IID, $TGUID = 0)
		LOCAL $TNII = DLLSTRUCTCREATE("dword;hwnd;uint;" & $TAGGUID)
		DLLSTRUCTSETDATA($TNII, 1, DLLSTRUCTGETSIZE($TNII))
		DLLSTRUCTSETDATA($TNII, 2, $HWND)
		DLLSTRUCTSETDATA($TNII, 3, $IID)
		IF ISDLLSTRUCT($TGUID) THEN
			IF NOT _WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($TNII, 4), $TGUID, 16) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		ENDIF
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "Shell_NotifyIconGetRect", "struct*", $TNII, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_SHELLOBJECTPROPERTIES($SFILEPATH, $ITYPE = 2, $SPROPERTY = "", $HPARENT = 0)
		IF NOT STRINGSTRIPWS($SPROPERTY, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SPROPERTY = NULL
		LOCAL $ACALL = DLLCALL("shell32.dll", "bool", "SHObjectProperties", "hwnd", $HPARENT, "dword", $ITYPE, "wstr", $SFILEPATH, "wstr", $SPROPERTY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLOPENFOLDERANDSELECTITEMS($SFILEPATH, $ANAMES = 0, $ISTART = 0, $IEND = -1, $IFLAGS = 0)
		LOCAL $PPIDL, $ACALL, $TPTR = 0, $ICOUNT = 0, $IOBJ = 0, $IERROR = 0
		$SFILEPATH = _WINAPI_PATHREMOVEBACKSLASH(_WINAPI_PATHSEARCHANDQUALIFY($SFILEPATH))
		IF ISARRAY($ANAMES) THEN
			IF $SFILEPATH AND NOT _WINAPI_PATHISDIRECTORY($SFILEPATH) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		ENDIF
		$PPIDL = _WINAPI_SHELLILCREATEFROMPATH($SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		IF NOT __CHECKERRORARRAYBOUNDS($ANAMES, $ISTART, $IEND) THEN
			$TPTR = DLLSTRUCTCREATE("ptr[" & ($IEND - $ISTART + 1) & "]")
			FOR $I = $ISTART TO $IEND
				$ICOUNT += 1
				IF $ANAMES[$I] THEN
					DLLSTRUCTSETDATA($TPTR, 1, _WINAPI_SHELLILCREATEFROMPATH($SFILEPATH & "\" & $ANAMES[$I]), $ICOUNT)
				ELSE
					DLLSTRUCTSETDATA($TPTR, 1, 0, $ICOUNT)
				ENDIF
			NEXT
		ENDIF
		IF _WINAPI_COINITIALIZE() THEN $IOBJ = 1
		$ACALL = DLLCALL("shell32.dll", "long", "SHOpenFolderAndSelectItems", "ptr", $PPIDL, "uint", $ICOUNT, "struct*", $TPTR, "dword", $IFLAGS)
		IF @ERROR THEN
			$IERROR = @ERROR + 10
		ELSE
			IF $ACALL[0] THEN $IERROR = 10
		ENDIF
		IF $IOBJ THEN _WINAPI_COUNINITIALIZE()
		_WINAPI_COTASKMEMFREE($PPIDL)
		FOR $I = 1 TO $ICOUNT
			$PPIDL = DLLSTRUCTGETDATA($TPTR, $I)
			IF $PPIDL THEN
				_WINAPI_COTASKMEMFREE($PPIDL)
			ENDIF
		NEXT
		IF $IERROR = 10 THEN RETURN SETERROR(10, $ACALL[0], 0)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLQUERYRECYCLEBIN($SROOT = "")
		LOCAL $TAGSHQUERYRBINFO = (@AUTOITX64 ? "" : "align 1;") & "dword cbSize;int64 Size;int64 nbFiles"
		LOCAL $TSHQRBI = DLLSTRUCTCREATE($TAGSHQUERYRBINFO)
		DLLSTRUCTSETDATA($TSHQRBI, 1, DLLSTRUCTGETSIZE($TSHQRBI))
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHQueryRecycleBinW", "wstr", $SROOT, "struct*", $TSHQRBI)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		LOCAL $ARET[2]
		$ARET[0] = DLLSTRUCTGETDATA($TSHQRBI, 2)
		$ARET[1] = DLLSTRUCTGETDATA($TSHQRBI, 3)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_SHELLQUERYUSERNOTIFICATIONSTATE()
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHQueryUserNotificationState", "uint*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_SHELLREMOVELOCALIZEDNAME($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHRemoveLocalizedName", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLRESTRICTED($IRESTRICTION)
		LOCAL $ACALL = DLLCALL("shell32.dll", "dword", "SHRestricted", "uint", $IRESTRICTION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLSETKNOWNFOLDERPATH($SGUID, $SFILEPATH, $IFLAGS = 0, $HTOKEN = 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR OR $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		$ACALL = DLLCALL("shell32.dll", "long", "SHSetKnownFolderPath", "struct*", $TGUID, "dword", $IFLAGS, "handle", $HTOKEN, "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLSETLOCALIZEDNAME($SFILEPATH, $SMODULE, $IRESID)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHSetLocalizedName", "wstr", $SFILEPATH, "wstr", $SMODULE, "int", $IRESID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLSETSETTINGS($IFLAGS, $BSET)
		LOCAL $IVAL1 = 0, $IVAL2 = 0
		LOCAL $AOPT[20][2] = [[1, 1], [2, 2], [4, 32768], [8, 32], [16, 8], [32, 128], [64, 512], [128, 1024], [256, 2048], [1024, 4096], [2048, 8192], [4096, 16384], [8192, 131072], [32768, 262144], [65536, 1048576], [1, 524288], [2, 2097152], [8, 8388608], [16, 16777216], [32, 33554432]]
		IF $BSET THEN
			FOR $I = 0 TO 14
				IF BITAND($IFLAGS, $AOPT[$I][1]) THEN
					$IVAL1 += $AOPT[$I][0]
				ENDIF
			NEXT
			FOR $I = 15 TO 19
				IF BITAND($IFLAGS, $AOPT[$I][1]) THEN
					$IVAL2 += $AOPT[$I][0]
				ENDIF
			NEXT
		ENDIF
		LOCAL $TSHELLSTATE = DLLSTRUCTCREATE("uint[8]")
		DLLSTRUCTSETDATA($TSHELLSTATE, 1, $IVAL1, 1)
		DLLSTRUCTSETDATA($TSHELLSTATE, 1, $IVAL2, 8)
		DLLCALL("shell32.dll", "none", "SHGetSetSettings", "struct*", $TSHELLSTATE, "dword", $IFLAGS, "bool", 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLUPDATEIMAGE($SICON, $IINDEX, $IIMAGE, $IFLAGS = 0)
		DLLCALL("shell32.dll", "none", "SHUpdateImageW", "wstr", $SICON, "int", $IINDEX, "uint", $IFLAGS, "int", $IIMAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
	GLOBAL $__G_PFRBUFFER = 0, $__G_IFRBUFFERSIZE = 16385
	GLOBAL CONST $TAGDEVNAMES = "ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default"
	GLOBAL CONST $TAGFINDREPLACE = "dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName"
	GLOBAL CONST $TAGMSGBOXPARAMS = "uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId"
	GLOBAL CONST $TAGPAGESETUPDLG = "dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long MarginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemplateName;ptr hPageSetupTemplate"
	GLOBAL CONST $TAGPRINTDLG = (@AUTOITX64 ? "" : "align 1;") & "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;word FromPage;word ToPage;word MinPage;word MaxPage;word Copies;handle hInstance;lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;handle hPrintTemplate;handle hSetupTemplate"
	GLOBAL CONST $TAGPRINTDLGEX = "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr PageRanges;dword MinPage;dword MaxPage;dword Copies;handle hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;dword ResultAction"
	GLOBAL CONST $TAGPRINTPAGERANGE = "dword FromPage;dword ToPage"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BROWSEFORFOLDERDLG($SROOT = "", $STEXT = "", $IFLAGS = 0, $PBROWSEPROC = 0, $LPARAM = 0, $HPARENT = 0)
		LOCAL CONST $TAGBROWSEINFO = "hwnd hwndOwner;ptr pidlRoot;ptr pszDisplayName; ptr lpszTitle;uint ulFlags;ptr lpfn;lparam lParam;int iImage"
		LOCAL $TBROWSEINFO = DLLSTRUCTCREATE($TAGBROWSEINFO & ";wchar[" & (STRINGLEN($STEXT) + 1) & "];wchar[260]")
		LOCAL $PPIDL = 0, $SRESULT = ""
		IF STRINGSTRIPWS($SROOT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			LOCAL $SPATH = _WINAPI_PATHSEARCHANDQUALIFY($SROOT, 1)
			IF @ERROR THEN
				$SPATH = $SROOT
			ENDIF
			$PPIDL = _WINAPI_SHELLILCREATEFROMPATH($SPATH)
			IF @ERROR THEN
			ENDIF
		ENDIF
		DLLSTRUCTSETDATA($TBROWSEINFO, 1, $HPARENT)
		DLLSTRUCTSETDATA($TBROWSEINFO, 2, $PPIDL)
		DLLSTRUCTSETDATA($TBROWSEINFO, 3, DLLSTRUCTGETPTR($TBROWSEINFO, 10))
		DLLSTRUCTSETDATA($TBROWSEINFO, 4, DLLSTRUCTGETPTR($TBROWSEINFO, 9))
		DLLSTRUCTSETDATA($TBROWSEINFO, 5, $IFLAGS)
		DLLSTRUCTSETDATA($TBROWSEINFO, 6, $PBROWSEPROC)
		DLLSTRUCTSETDATA($TBROWSEINFO, 7, $LPARAM)
		DLLSTRUCTSETDATA($TBROWSEINFO, 8, 0)
		DLLSTRUCTSETDATA($TBROWSEINFO, 9, $STEXT)
		LOCAL $ACALL = DLLCALL("shell32.dll", "ptr", "SHBrowseForFolderW", "struct*", $TBROWSEINFO)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		$SRESULT = _WINAPI_SHELLGETPATHFROMIDLIST($ACALL[0])
		_WINAPI_COTASKMEMFREE($ACALL[0])
		IF $PPIDL THEN
			_WINAPI_COTASKMEMFREE($PPIDL)
		ENDIF
		IF NOT $SRESULT THEN RETURN SETERROR(10, 0, "")
		RETURN $SRESULT
	ENDFUNC
	FUNC _WINAPI_COMMDLGEXTENDEDERROR()
		LOCAL CONST $CDERR_DIALOGFAILURE = 65535
		LOCAL CONST $CDERR_FINDRESFAILURE = 6
		LOCAL CONST $CDERR_INITIALIZATION = 2
		LOCAL CONST $CDERR_LOADRESFAILURE = 7
		LOCAL CONST $CDERR_LOADSTRFAILURE = 5
		LOCAL CONST $CDERR_LOCKRESFAILURE = 8
		LOCAL CONST $CDERR_MEMALLOCFAILURE = 9
		LOCAL CONST $CDERR_MEMLOCKFAILURE = 10
		LOCAL CONST $CDERR_NOHINSTANCE = 4
		LOCAL CONST $CDERR_NOHOOK = 11
		LOCAL CONST $CDERR_NOTEMPLATE = 3
		LOCAL CONST $CDERR_REGISTERMSGFAIL = 12
		LOCAL CONST $CDERR_STRUCTSIZE = 1
		LOCAL CONST $FNERR_BUFFERTOOSMALL = 12291
		LOCAL CONST $FNERR_INVALIDFILENAME = 12290
		LOCAL CONST $FNERR_SUBCLASSFAILURE = 12289
		LOCAL $ACALL = DLLCALL("comdlg32.dll", "dword", "CommDlgExtendedError")
		IF NOT @ERROR THEN
			SWITCH $ACALL[0]
				CASE $CDERR_DIALOGFAILURE
					RETURN SETERROR($ACALL[0], 0, "The dialog box could not be created." & @LF & "The common dialog box function's call to the DialogBox function failed." & @LF & "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
				CASE $CDERR_FINDRESFAILURE
					RETURN SETERROR($ACALL[0], 0, "The common dialog box function failed to find a specified resource.")
				CASE $CDERR_INITIALIZATION
					RETURN SETERROR($ACALL[0], 0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
				CASE $CDERR_LOADRESFAILURE
					RETURN SETERROR($ACALL[0], 0, "The common dialog box function failed to load a specified resource.")
				CASE $CDERR_LOADSTRFAILURE
					RETURN SETERROR($ACALL[0], 0, "The common dialog box function failed to load a specified string.")
				CASE $CDERR_LOCKRESFAILURE
					RETURN SETERROR($ACALL[0], 0, "The common dialog box function failed to lock a specified resource.")
				CASE $CDERR_MEMALLOCFAILURE
					RETURN SETERROR($ACALL[0], 0, "The common dialog box function was unable to allocate memory for internal structures.")
				CASE $CDERR_MEMLOCKFAILURE
					RETURN SETERROR($ACALL[0], 0, "The common dialog box function was unable to lock the memory associated with a handle.")
				CASE $CDERR_NOHINSTANCE
					RETURN SETERROR($ACALL[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding instance handle.")
				CASE $CDERR_NOHOOK
					RETURN SETERROR($ACALL[0], 0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a pointer to a corresponding hook procedure.")
				CASE $CDERR_NOTEMPLATE
					RETURN SETERROR($ACALL[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding template.")
				CASE $CDERR_REGISTERMSGFAIL
					RETURN SETERROR($ACALL[0], 0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
				CASE $CDERR_STRUCTSIZE
					RETURN SETERROR($ACALL[0], 0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
				CASE $FNERR_BUFFERTOOSMALL
					RETURN SETERROR($ACALL[0], 0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF & "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
				CASE $FNERR_INVALIDFILENAME
					RETURN SETERROR($ACALL[0], 0, "A file name is invalid.")
				CASE $FNERR_SUBCLASSFAILURE
					RETURN SETERROR($ACALL[0], 0, "An attempt to subclass a list box failed because sufficient memory was not available.")
			ENDSWITCH
		ENDIF
		RETURN SETERROR(@ERROR, @EXTENDED, "0x" & HEX($ACALL[0]))
	ENDFUNC
	FUNC _WINAPI_COMMDLGEXTENDEDERROREX()
		LOCAL $ACALL = DLLCALL("comdlg32.dll", "dword", "CommDlgExtendedError")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CONFIRMCREDENTIALS($STARGET, $BCONFIRM)
		IF NOT __DLL("credui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ACALL = DLLCALL("credui.dll", "dword", "CredUIConfirmCredentialsW", "wstr", $STARGET, "bool", $BCONFIRM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_FINDTEXTDLG($HOWNER, $SFINDWHAT = "", $IFLAGS = 0, $PFINDPROC = 0, $LPARAM = 0)
		$__G_PFRBUFFER = __HEAPREALLOC($__G_PFRBUFFER, 2 * $__G_IFRBUFFERSIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		DLLSTRUCTSETDATA(DLLSTRUCTCREATE("wchar[" & $__G_IFRBUFFERSIZE & "]", $__G_PFRBUFFER), 1, STRINGLEFT($SFINDWHAT, $__G_IFRBUFFERSIZE - 1))
		LOCAL $TFR = DLLSTRUCTCREATE($TAGFINDREPLACE)
		DLLSTRUCTSETDATA($TFR, "Size", DLLSTRUCTGETSIZE($TFR))
		DLLSTRUCTSETDATA($TFR, "hOwner", $HOWNER)
		DLLSTRUCTSETDATA($TFR, "hInstance", 0)
		DLLSTRUCTSETDATA($TFR, "Flags", $IFLAGS)
		DLLSTRUCTSETDATA($TFR, "FindWhat", $__G_PFRBUFFER)
		DLLSTRUCTSETDATA($TFR, "ReplaceWith", 0)
		DLLSTRUCTSETDATA($TFR, "FindWhatLen", $__G_IFRBUFFERSIZE * 2)
		DLLSTRUCTSETDATA($TFR, "ReplaceWithLen", 0)
		DLLSTRUCTSETDATA($TFR, "lParam", $LPARAM)
		DLLSTRUCTSETDATA($TFR, "Hook", $PFINDPROC)
		DLLSTRUCTSETDATA($TFR, "TemplateName", 0)
		LOCAL $ACALL = DLLCALL("comdlg32.dll", "hwnd", "FindTextW", "struct*", $TFR)
		IF @ERROR OR NOT $ACALL[0] THEN
			LOCAL $IERROR = @ERROR + 30
			__HEAPFREE($__G_PFRBUFFER)
			IF ISARRAY($ACALL) THEN
				RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), 0)
			ELSE
				RETURN SETERROR($IERROR, @EXTENDED, 0)
			ENDIF
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FLUSHFRBUFFER()
		IF NOT __HEAPFREE($__G_PFRBUFFER, 1) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_FORMATDRIVEDLG($SDRIVE, $IOPTION = 0, $HPARENT = 0)
		IF NOT ISSTRING($SDRIVE) THEN RETURN SETERROR(10, 0, 0)
		$SDRIVE = STRINGLEFT(STRINGUPPER(STRINGSTRIPWS($SDRIVE, $STR_STRIPLEADING)), 1)
		IF NOT $SDRIVE THEN RETURN SETERROR(11, 0, 0)
		$SDRIVE = ASC($SDRIVE) - 65
		IF($SDRIVE < 0) OR($SDRIVE > 25) THEN RETURN SETERROR(12, 0, 0)
		LOCAL $ACALL = DLLCALL("shell32.dll", "dword", "SHFormatDrive", "hwnd", $HPARENT, "uint", $SDRIVE, "uint", 65535, "uint", $IOPTION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] < 0 THEN RETURN SETERROR($ACALL[0], 0, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCONNECTEDDLG($IDLG, $IFLAGS = 0, $HPARENT = 0)
		IF NOT __DLL("connect.dll") THEN RETURN SETERROR(103, 0, 0)
		SWITCH $IDLG
			CASE 0
				$IDLG = "GetNetworkConnected"
			CASE 1
				$IDLG = "GetInternetConnected"
			CASE 2
				$IDLG = "GetVPNConnected"
			CASE ELSE
				RETURN SETERROR(1, 0, 0)
		ENDSWITCH
		LOCAL $SSTR = ""
		IF BITAND($IFLAGS, 1) THEN
			$SSTR &= "-SkipInternetDetection "
		ENDIF
		IF BITAND($IFLAGS, 2) THEN
			$SSTR &= "-SkipExistingConnections "
		ENDIF
		IF BITAND($IFLAGS, 4) THEN
			$SSTR &= "-HideFinishPage "
		ENDIF
		LOCAL $ACALL = DLLCALL("connect.dll", "long", $IDLG, "hwnd", $HPARENT, "dword", 0, "dword", 0, "dword", 0, "handle", 0, "wstr", STRINGSTRIPWS($SSTR, $STR_STRIPTRAILING))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT($ACALL[0] = 0 OR $ACALL[0] = 1) THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN NUMBER(NOT $ACALL[0])
	ENDFUNC
	FUNC _WINAPI_GETFRBUFFER()
		RETURN $__G_IFRBUFFERSIZE - 1
	ENDFUNC
	FUNC _WINAPI_GETOPENFILENAME($STITLE = "", $SFILTER = "All files (*.*)", $SINITALDIR = ".", $SDEFAULTFILE = "", $SDEFAULTEXT = "", $IFILTERINDEX = 1, $IFLAGS = 0, $IFLAGSEX = 0, $HWNDOWNER = 0)
		LOCAL $VRESULT = __OFNDLG(0, $STITLE, $SINITALDIR, $SFILTER, $IFILTERINDEX, $SDEFAULTFILE, $SDEFAULTEXT, $IFLAGS, $IFLAGSEX, 0, 0, $HWNDOWNER)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $VRESULT)
		IF BITAND($IFLAGS, $OFN_ALLOWMULTISELECT) THEN
			RETURN __WINAPI_PARSEMULTISELECTFILEDIALOGPATH($VRESULT)
		ELSE
			RETURN __WINAPI_PARSEFILEDIALOGPATH($VRESULT)
		ENDIF
	ENDFUNC
	FUNC _WINAPI_GETSAVEFILENAME($STITLE = "", $SFILTER = "All files (*.*)", $SINITALDIR = ".", $SDEFAULTFILE = "", $SDEFAULTEXT = "", $IFILTERINDEX = 1, $IFLAGS = 0, $IFLAGSEX = 0, $HWNDOWNER = 0)
		LOCAL $VRETURN = __OFNDLG(1, $STITLE, $SINITALDIR, $SFILTER, $IFILTERINDEX, $SDEFAULTFILE, $SDEFAULTEXT, $IFLAGS, $IFLAGSEX, 0, 0, $HWNDOWNER)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $VRETURN)
		RETURN __WINAPI_PARSEFILEDIALOGPATH($VRETURN)
	ENDFUNC
	FUNC _WINAPI_MESSAGEBOXCHECK($ITYPE, $STITLE, $STEXT, $SREGVAL, $IDEFAULT = -1, $HPARENT = 0)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "int", "SHMessageBoxCheckW", "hwnd", $HPARENT, "wstr", $STEXT, "wstr", $STITLE, "uint", $ITYPE, "int", $IDEFAULT, "wstr", $SREGVAL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MESSAGEBOXINDIRECT($TMSGBOXPARAMS)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "MessageBoxIndirectW", "struct*", $TMSGBOXPARAMS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OPENFILEDLG($STITLE = "", $SINITDIR = "", $SFILTERS = "", $IDEFAULTFILTER = 0, $SDEFAULTFILEPATH = "", $SDEFAULTEXT = "", $IFLAGS = 0, $IFLAGSEX = 0, $POFNPROC = 0, $PDATA = 0, $HPARENT = 0)
		LOCAL $VRESULT = __OFNDLG(0, $STITLE, $SINITDIR, $SFILTERS, $IDEFAULTFILTER, $SDEFAULTFILEPATH, $SDEFAULTEXT, $IFLAGS, $IFLAGSEX, $POFNPROC, $PDATA, $HPARENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $VRESULT)
		RETURN $VRESULT
	ENDFUNC
	FUNC _WINAPI_PAGESETUPDLG(BYREF $TPAGESETUPDLG)
		LOCAL $ACALL = DLLCALL("comdlg32.dll", "int", "PageSetupDlgW", "struct*", $TPAGESETUPDLG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PICKICONDLG($SICON = "", $IINDEX = 0, $HPARENT = 0)
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "PickIconDlg", "hwnd", $HPARENT, "wstr", $SICON, "int", 4096, "int*", $IINDEX)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[2]
		LOCAL $ARES = DLLCALL("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $ACALL[2], "wstr", "", "dword", 4096)
		$ARET[0] = $ARES[2]
		$ARET[1] = $ACALL[4]
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_PRINTDLG(BYREF $TPRINTDLG)
		LOCAL $ACALL = DLLCALL("comdlg32.dll", "long", "PrintDlgW", "struct*", $TPRINTDLG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PRINTDLGEX(BYREF $TPRINTDLGEX)
		LOCAL $TPDEX = DLLSTRUCTCREATE($TAGPRINTDLGEX, DLLSTRUCTGETPTR($TPRINTDLGEX))
		LOCAL $ACALL = DLLCALL("comdlg32.dll", "long", "PrintDlgExW", "struct*", $TPDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN SETEXTENDED(DLLSTRUCTGETDATA($TPDEX, "ResultAction"), 1)
	ENDFUNC
	FUNC _WINAPI_REPLACETEXTDLG($HOWNER, $SFINDWHAT = "", $SREPLACEWITH = "", $IFLAGS = 0, $PREPLACEPROC = 0, $LPARAM = 0)
		$__G_PFRBUFFER = __HEAPREALLOC($__G_PFRBUFFER, 4 * $__G_IFRBUFFERSIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 100, @EXTENDED, 0)
		LOCAL $TBUFF = DLLSTRUCTCREATE("wchar[" & $__G_IFRBUFFERSIZE & "];wchar[" & $__G_IFRBUFFERSIZE & "]", $__G_PFRBUFFER)
		DLLSTRUCTSETDATA($TBUFF, 1, STRINGLEFT($SFINDWHAT, $__G_IFRBUFFERSIZE - 1))
		DLLSTRUCTSETDATA($TBUFF, 2, STRINGLEFT($SREPLACEWITH, $__G_IFRBUFFERSIZE - 1))
		LOCAL $TFR = DLLSTRUCTCREATE($TAGFINDREPLACE)
		DLLSTRUCTSETDATA($TFR, "Size", DLLSTRUCTGETSIZE($TFR))
		DLLSTRUCTSETDATA($TFR, "hOwner", $HOWNER)
		DLLSTRUCTSETDATA($TFR, "hInstance", 0)
		DLLSTRUCTSETDATA($TFR, "Flags", $IFLAGS)
		DLLSTRUCTSETDATA($TFR, "FindWhat", DLLSTRUCTGETPTR($TBUFF, 1))
		DLLSTRUCTSETDATA($TFR, "ReplaceWith", DLLSTRUCTGETPTR($TBUFF, 2))
		DLLSTRUCTSETDATA($TFR, "FindWhatLen", $__G_IFRBUFFERSIZE * 2)
		DLLSTRUCTSETDATA($TFR, "ReplaceWithLen", $__G_IFRBUFFERSIZE * 2)
		DLLSTRUCTSETDATA($TFR, "lParam", $LPARAM)
		DLLSTRUCTSETDATA($TFR, "Hook", $PREPLACEPROC)
		DLLSTRUCTSETDATA($TFR, "TemplateName", 0)
		LOCAL $ACALL = DLLCALL("comdlg32.dll", "hwnd", "ReplaceTextW", "struct*", $TFR)
		IF @ERROR OR NOT $ACALL[0] THEN
			LOCAL $IERROR = @ERROR
			__HEAPFREE($__G_PFRBUFFER)
			IF ISARRAY($ACALL) THEN
				RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), 0)
			ELSE
				RETURN SETERROR($IERROR, 0, 0)
			ENDIF
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RESTARTDLG($STEXT = "", $IFLAGS = 2, $HPARENT = 0)
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "RestartDialog", "hwnd", $HPARENT, "wstr", $STEXT, "int", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SAVEFILEDLG($STITLE = "", $SINITDIR = "", $SFILTERS = "", $IDEFAULTFILTER = 0, $SDEFAULTFILEPATH = "", $SDEFAULTEXT = "", $IFLAGS = 0, $IFLAGSEX = 0, $POFNPROC = 0, $PDATA = 0, $HPARENT = 0)
		LOCAL $VRESULT = __OFNDLG(1, $STITLE, $SINITDIR, $SFILTERS, $IDEFAULTFILTER, $SDEFAULTFILEPATH, $SDEFAULTEXT, $IFLAGS, $IFLAGSEX, $POFNPROC, $PDATA, $HPARENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $VRESULT)
		RETURN $VRESULT
	ENDFUNC
	FUNC _WINAPI_SETFRBUFFER($ICHARS)
		$ICHARS = NUMBER($ICHARS)
		IF $ICHARS < 80 THEN
			$ICHARS = 80
		ENDIF
		$__G_IFRBUFFERSIZE = $ICHARS + 1
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLABOUTDLG($STITLE, $SNAME, $STEXT, $HICON = 0, $HPARENT = 0)
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", "ShellAboutW", "hwnd", $HPARENT, "wstr", $STITLE & "#" & $SNAME, "wstr", $STEXT, "handle", $HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHELLOPENWITHDLG($SFILEPATH, $IFLAGS = 0, $HPARENT = 0)
		LOCAL $TOPENASINFO = DLLSTRUCTCREATE("ptr;ptr;dword;wchar[" & (STRINGLEN($SFILEPATH) + 1) & "]")
		DLLSTRUCTSETDATA($TOPENASINFO, 1, DLLSTRUCTGETPTR($TOPENASINFO, 4))
		DLLSTRUCTSETDATA($TOPENASINFO, 2, 0)
		DLLSTRUCTSETDATA($TOPENASINFO, 3, $IFLAGS)
		DLLSTRUCTSETDATA($TOPENASINFO, 4, $SFILEPATH)
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "SHOpenWithDialog", "hwnd", $HPARENT, "struct*", $TOPENASINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLSTARTNETCONNECTIONDLG($SREMOTE = "", $IFLAGS = 0, $HPARENT = 0)
		IF NOT STRINGSTRIPWS($SREMOTE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SREMOTE = NULL
		DLLCALL("shell32.dll", "long", "SHStartNetConnectionDialogW", "hwnd", $HPARENT, "wstr", $SREMOTE, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLUSERAUTHENTICATIONDLG($SCAPTION, $SMESSAGE, $SUSER, $SPASSWORD, $STARGET, $IFLAGS = 0, $IERROR = 0, $BSAVE = FALSE, $HBITMAP = 0, $HPARENT = 0)
		IF NOT __DLL("credui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $TINFO = DLLSTRUCTCREATE("dword;hwnd;ptr;ptr;ptr;wchar[" & (STRINGLEN($SMESSAGE) + 1) & "];wchar[" & (STRINGLEN($SCAPTION) + 1) & "]")
		DLLSTRUCTSETDATA($TINFO, 1, DLLSTRUCTGETPTR($TINFO, 6) - DLLSTRUCTGETPTR($TINFO))
		DLLSTRUCTSETDATA($TINFO, 2, $HPARENT)
		DLLSTRUCTSETDATA($TINFO, 3, DLLSTRUCTGETPTR($TINFO, 6))
		DLLSTRUCTSETDATA($TINFO, 4, DLLSTRUCTGETPTR($TINFO, 7))
		DLLSTRUCTSETDATA($TINFO, 5, $HBITMAP)
		DLLSTRUCTSETDATA($TINFO, 6, $SMESSAGE)
		DLLSTRUCTSETDATA($TINFO, 7, $SCAPTION)
		LOCAL $ACALL = DLLCALL("credui.dll", "dword", "CredUIPromptForCredentialsW", "struct*", $TINFO, "wstr", $STARGET, "ptr", 0, "dword", $IERROR, "wstr", $SUSER, "ulong", 4096, "wstr", $SPASSWORD, "ulong", 4096, "bool*", $BSAVE, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		LOCAL $ARET[3]
		$ARET[0] = $ACALL[5]
		$ARET[1] = $ACALL[7]
		$ARET[2] = $ACALL[9]
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_SHELLUSERAUTHENTICATIONDLGEX($SCAPTION, $SMESSAGE, $SUSER, $SPASSWORD, $IFLAGS = 0, $IAUTHERROR = 0, $BSAVE = FALSE, $IPACKAGE = 0, $HPARENT = 0)
		IF NOT __DLL("credui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $TBLOB = 0, $ACALL
		IF STRINGLEN($SUSER) THEN
			$ACALL = DLLCALL("credui.dll", "bool", "CredPackAuthenticationBufferW", "dword", 1, "wstr", $SUSER, "wstr", $SPASSWORD, "ptr", 0, "dword*", 0)
			IF @ERROR OR NOT $ACALL[5] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$TBLOB = DLLSTRUCTCREATE("byte[" & $ACALL[5] & "]")
			$ACALL = DLLCALL("credui.dll", "bool", "CredPackAuthenticationBufferW", "dword", 1, "wstr", $SUSER, "wstr", $SPASSWORD, "struct*", $TBLOB, "dword*", $ACALL[5])
			IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		ENDIF
		LOCAL $TINFO = DLLSTRUCTCREATE("dword;hwnd;ptr;ptr;ptr;wchar[" & (STRINGLEN($SMESSAGE) + 1) & "];wchar[" & (STRINGLEN($SCAPTION) + 1) & "]")
		DLLSTRUCTSETDATA($TINFO, 1, DLLSTRUCTGETPTR($TINFO, 6) - DLLSTRUCTGETPTR($TINFO))
		DLLSTRUCTSETDATA($TINFO, 2, $HPARENT)
		DLLSTRUCTSETDATA($TINFO, 3, DLLSTRUCTGETPTR($TINFO, 6))
		DLLSTRUCTSETDATA($TINFO, 4, DLLSTRUCTGETPTR($TINFO, 7))
		DLLSTRUCTSETDATA($TINFO, 5, 0)
		DLLSTRUCTSETDATA($TINFO, 6, $SMESSAGE)
		DLLSTRUCTSETDATA($TINFO, 7, $SCAPTION)
		$ACALL = DLLCALL("credui.dll", "dword", "CredUIPromptForWindowsCredentialsW", "struct*", $TINFO, "dword", $IAUTHERROR, "ulong*", $IPACKAGE, "struct*", $TBLOB, "ulong", DLLSTRUCTGETSIZE($TBLOB), "ptr*", 0, "ulong*", 0, "bool*", $BSAVE, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(30, $ACALL[0], 0)
		LOCAL $ARET[4], $IERROR = 0
		$ARET[2] = $ACALL[8]
		$ARET[3] = $ACALL[3]
		LOCAL $PBLOB = $ACALL[6]
		LOCAL $ISIZE = $ACALL[7]
		$ACALL = DLLCALL("credui.dll", "bool", "CredUnPackAuthenticationBufferW", "dword", 1, "ptr", $PBLOB, "dword", $ISIZE, "wstr", "", "dword*", 4096, "wstr", "", "dword*", 4096, "wstr", "", "dword*", 4096)
		IF NOT @ERROR AND $ACALL[0] THEN
			$ARET[0] = $ACALL[4]
			$ARET[1] = $ACALL[8]
		ELSE
			$IERROR = @ERROR + 40
		ENDIF
		IF NOT _WINAPI_ZEROMEMORY($PBLOB, $ISIZE) THEN
		ENDIF
		_WINAPI_COTASKMEMFREE($PBLOB)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARET
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __OFNDLG($IDLG, $STITLE, $SINITDIR, $SFILTERS, $IDEFFILTER, $SDEFFILE, $SDEFEXT, $IFLAGS, $IFLAGSEX, $POFNPROC, $PDATA, $HPARENT)
		LOCAL $VERROR[1] = [0]
		IF BITAND($IFLAGS, $OFN_ALLOWMULTISELECT) = 0 THEN $VERROR = ""
		LOCAL $TBUFFER = DLLSTRUCTCREATE("wchar[32768]")
		LOCAL $TFILTERS = 0, $TDEFEXT = 0, $TINITDIR = 0, $TTITLE = 0
		LOCAL $TOFN = DLLSTRUCTCREATE($TAGOPENFILENAME)
		DLLSTRUCTSETDATA($TOFN, "StructSize", DLLSTRUCTGETSIZE($TOFN))
		DLLSTRUCTSETDATA($TOFN, "hwndOwner", $HPARENT)
		DLLSTRUCTSETDATA($TOFN, 3, 0)
		LOCAL $ADATA = STRINGSPLIT($SFILTERS, "|")
		LOCAL $AFILTERS[$ADATA[0] * 2]
		LOCAL $ICOUNT = 0
		FOR $I = 1 TO $ADATA[0]
			$AFILTERS[$ICOUNT + 0] = STRINGSTRIPWS($ADATA[$I], $STR_STRIPLEADING + $STR_STRIPTRAILING)
			$AFILTERS[$ICOUNT + 1] = STRINGSTRIPWS(STRINGREGEXPREPLACE($ADATA[$I], ".*\((.*)\)", "\1"), $STR_STRIPALL)
			IF $AFILTERS[$ICOUNT + 1] THEN
				$ICOUNT += 2
			ENDIF
		NEXT
		IF $ICOUNT THEN
			$TFILTERS = _WINAPI_ARRAYTOSTRUCT($AFILTERS, 0, $ICOUNT - 1)
			IF @ERROR THEN
			ENDIF
		ENDIF
		DLLSTRUCTSETDATA($TOFN, "lpstrFilter", DLLSTRUCTGETPTR($TFILTERS))
		DLLSTRUCTSETDATA($TOFN, 5, 0)
		DLLSTRUCTSETDATA($TOFN, 6, 0)
		DLLSTRUCTSETDATA($TOFN, "nFilterIndex", $IDEFFILTER)
		$SDEFFILE = STRINGSTRIPWS($SDEFFILE, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF $SDEFFILE THEN
			DLLSTRUCTSETDATA($TBUFFER, 1, $SDEFFILE)
		ENDIF
		DLLSTRUCTSETDATA($TOFN, "lpstrFile", DLLSTRUCTGETPTR($TBUFFER))
		DLLSTRUCTSETDATA($TOFN, "nMaxFile", 32768)
		DLLSTRUCTSETDATA($TOFN, 10, 0)
		DLLSTRUCTSETDATA($TOFN, 11, 0)
		$SINITDIR = STRINGSTRIPWS($SINITDIR, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF $SINITDIR THEN
			$TINITDIR = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($SINITDIR) + 1) & "]")
		ENDIF
		DLLSTRUCTSETDATA($TINITDIR, 1, $SINITDIR)
		DLLSTRUCTSETDATA($TOFN, "lpstrInitialDir", DLLSTRUCTGETPTR($TINITDIR))
		$STITLE = STRINGSTRIPWS($STITLE, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF $STITLE THEN
			$TTITLE = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($STITLE) + 1) & "]")
		ENDIF
		DLLSTRUCTSETDATA($TTITLE, 1, $STITLE)
		DLLSTRUCTSETDATA($TOFN, "lpstrTitle", DLLSTRUCTGETPTR($TTITLE))
		DLLSTRUCTSETDATA($TOFN, "Flags", $IFLAGS)
		DLLSTRUCTSETDATA($TOFN, 15, 0)
		DLLSTRUCTSETDATA($TOFN, 16, 0)
		$SDEFEXT = STRINGSTRIPWS($SDEFEXT, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF $SDEFEXT THEN
			$TDEFEXT = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($TDEFEXT) + 1) & "]")
		ENDIF
		DLLSTRUCTSETDATA($TDEFEXT, 1, STRINGREPLACE($SDEFEXT, ".", ""))
		DLLSTRUCTSETDATA($TOFN, "lpstrDefExt", DLLSTRUCTGETPTR($TDEFEXT))
		DLLSTRUCTSETDATA($TOFN, "lCustData", $PDATA)
		DLLSTRUCTSETDATA($TOFN, "lpfnHook", $POFNPROC)
		DLLSTRUCTSETDATA($TOFN, 20, 0)
		DLLSTRUCTSETDATA($TOFN, 21, 0)
		DLLSTRUCTSETDATA($TOFN, 22, 0)
		DLLSTRUCTSETDATA($TOFN, "FlagsEx", $IFLAGSEX)
		LOCAL $ACALL
		SWITCH $IDLG
			CASE 0
				$ACALL = DLLCALL("comdlg32.dll", "bool", "GetOpenFileNameW", "struct*", $TOFN)
			CASE 1
				$ACALL = DLLCALL("comdlg32.dll", "bool", "GetSaveFileNameW", "struct*", $TOFN)
			CASE ELSE
		ENDSWITCH
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, _WINAPI_COMMDLGEXTENDEDERROREX(), $VERROR)
		IF BITAND($IFLAGS, $OFN_ALLOWMULTISELECT) THEN
			IF BITAND($IFLAGS, $OFN_EXPLORER) THEN
				$ADATA = _WINAPI_STRUCTTOARRAY($TBUFFER)
				IF @ERROR THEN
					RETURN SETERROR(11, 0, $VERROR)
				ENDIF
			ELSE
				$ADATA = STRINGSPLIT(DLLSTRUCTGETDATA($TBUFFER, 1), " ")
			ENDIF
			SWITCH $ADATA[0]
				CASE 0
					RETURN SETERROR(12, 0, $VERROR)
				CASE 1
				CASE ELSE
					LOCAL $SPATH = $ADATA[1]
					FOR $I = 2 TO $ADATA[0]
						$ADATA[$I - 1] = _WINAPI_PATHAPPEND($SPATH, $ADATA[$I])
					NEXT
					REDIM $ADATA[$ADATA[0]]
					$ADATA[0] -= 1
			ENDSWITCH
		ELSE
			$ADATA = DLLSTRUCTGETDATA($TBUFFER, 1)
		ENDIF
		$__G_VEXT = $TOFN
		RETURN $ADATA
	ENDFUNC
	FUNC __WINAPI_PARSEMULTISELECTFILEDIALOGPATH($APATH)
		LOCAL $AFILES[UBOUND($APATH) + 1]
		$AFILES[0] = UBOUND($APATH)
		$AFILES[1] = STRINGMID($APATH[1], 1, STRINGINSTR($APATH[1], "\", $STR_NOCASESENSEBASIC, -1) - 1)
		FOR $I = 1 TO UBOUND($APATH) - 1
			$AFILES[$I + 1] = STRINGMID($APATH[$I], STRINGINSTR($APATH[$I], "\", $STR_NOCASESENSEBASIC, -1) + 1)
		NEXT
		RETURN $AFILES
	ENDFUNC
	FUNC __WINAPI_PARSEFILEDIALOGPATH($SPATH)
		LOCAL $AFILES[3]
		$AFILES[0] = 2
		$AFILES[1] = STRINGMID($SPATH, 1, STRINGINSTR($SPATH, "\", $STR_NOCASESENSEBASIC, -1) - 1)
		$AFILES[2] = STRINGMID($SPATH, STRINGINSTR($SPATH, "\", $STR_NOCASESENSEBASIC, -1) + 1)
		RETURN $AFILES
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $BACKUP_ALTERNATE_DATA = 4
GLOBAL CONST $BACKUP_DATA = 1
GLOBAL CONST $BACKUP_EA_DATA = 2
GLOBAL CONST $BACKUP_LINK = 5
GLOBAL CONST $BACKUP_OBJECT_ID = 7
GLOBAL CONST $BACKUP_PROPERTY_DATA = 6
GLOBAL CONST $BACKUP_REPARSE_DATA = 8
GLOBAL CONST $BACKUP_SECURITY_DATA = 3
GLOBAL CONST $BACKUP_SPARSE_BLOCK = 9
GLOBAL CONST $BACKUP_TXFS_DATA = 10
GLOBAL CONST $COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 8
GLOBAL CONST $COPY_FILE_COPY_SYMLINK = 2048
GLOBAL CONST $COPY_FILE_FAIL_IF_EXISTS = 1
GLOBAL CONST $COPY_FILE_NO_BUFFERING = 4096
GLOBAL CONST $COPY_FILE_OPEN_SOURCE_FOR_WRITE = 4
GLOBAL CONST $COPY_FILE_RESTARTABLE = 2
GLOBAL CONST $MOVE_FILE_COPY_ALLOWED = 2
GLOBAL CONST $MOVE_FILE_CREATE_HARDLINK = 16
GLOBAL CONST $MOVE_FILE_DELAY_UNTIL_REBOOT = 4
GLOBAL CONST $MOVE_FILE_FAIL_IF_NOT_TRACKABLE = 32
GLOBAL CONST $MOVE_FILE_REPLACE_EXISTING = 1
GLOBAL CONST $MOVE_FILE_WRITE_THROUGH = 8
GLOBAL CONST $PROGRESS_CONTINUE = 0
GLOBAL CONST $PROGRESS_CANCEL = 1
GLOBAL CONST $PROGRESS_STOP = 2
GLOBAL CONST $PROGRESS_QUIET = 3
GLOBAL CONST $FILE_APPEND_DATA = 4
GLOBAL CONST $FILE_DELETE_CHILD = 64
GLOBAL CONST $FILE_EXECUTE = 32
GLOBAL CONST $FILE_READ_ATTRIBUTES = 128
GLOBAL CONST $FILE_READ_DATA = 1
GLOBAL CONST $FILE_READ_EA = 8
GLOBAL CONST $FILE_WRITE_ATTRIBUTES = 256
GLOBAL CONST $FILE_WRITE_DATA = 2
GLOBAL CONST $FILE_WRITE_EA = 16
GLOBAL CONST $FILE_ADD_FILE = $FILE_WRITE_DATA
GLOBAL CONST $FILE_ADD_SUBDIRECTORY = $FILE_APPEND_DATA
GLOBAL CONST $FILE_CREATE_PIPE_INSTANCE = $FILE_APPEND_DATA
GLOBAL CONST $FILE_LIST_DIRECTORY = $FILE_READ_DATA
GLOBAL CONST $FILE_TRAVERSE = $FILE_EXECUTE
GLOBAL CONST $FILE_ALL_ACCESS = 2032127
GLOBAL CONST $FILE_FLAG_BACKUP_SEMANTICS = 33554432
GLOBAL CONST $FILE_FLAG_DELETE_ON_CLOSE = 67108864
GLOBAL CONST $FILE_FLAG_NO_BUFFERING = 536870912
GLOBAL CONST $FILE_FLAG_OPEN_NO_RECALL = 1048576
GLOBAL CONST $FILE_FLAG_OPEN_REPARSE_POINT = 2097152
GLOBAL CONST $FILE_FLAG_OVERLAPPED = 1073741824
GLOBAL CONST $FILE_FLAG_POSIX_SEMANTICS = 1048576
GLOBAL CONST $FILE_FLAG_RANDOM_ACCESS = 268435456
GLOBAL CONST $FILE_FLAG_SEQUENTIAL_SCAN = 134217728
GLOBAL CONST $FILE_FLAG_WRITE_THROUGH = -2147483648
GLOBAL CONST $SECURITY_ANONYMOUS = 0
GLOBAL CONST $SECURITY_CONTEXT_TRACKING = 262144
GLOBAL CONST $SECURITY_DELEGATION = 196608
GLOBAL CONST $SECURITY_EFFECTIVE_ONLY = 524288
GLOBAL CONST $SECURITY_IDENTIFICATION = 65536
GLOBAL CONST $SECURITY_IMPERSONATION = 131072
GLOBAL CONST $SEC_COMMIT = 134217728
GLOBAL CONST $SEC_IMAGE = 16777216
GLOBAL CONST $SEC_LARGE_PAGES = -2147483648
GLOBAL CONST $SEC_NOCACHE = 268435456
GLOBAL CONST $SEC_RESERVE = 67108864
GLOBAL CONST $SEC_WRITECOMBINE = 1073741824
GLOBAL CONST $SECTION_EXTEND_SIZE = 16
GLOBAL CONST $SECTION_MAP_EXECUTE = 8
GLOBAL CONST $SECTION_MAP_READ = 4
GLOBAL CONST $SECTION_MAP_WRITE = 2
GLOBAL CONST $SECTION_QUERY = 1
GLOBAL CONST $SECTION_ALL_ACCESS = 2031647
GLOBAL CONST $FILE_MAP_COPY = 1
GLOBAL CONST $FILE_MAP_EXECUTE = 32
GLOBAL CONST $FILE_MAP_READ = 4
GLOBAL CONST $FILE_MAP_WRITE = 2
GLOBAL CONST $FILE_MAP_ALL_ACCESS = $SECTION_ALL_ACCESS
GLOBAL CONST $DDD_EXACT_MATCH_ON_REMOVE = 4
GLOBAL CONST $DDD_NO_BROADCAST_SYSTEM = 8
GLOBAL CONST $DDD_RAW_TARGET_PATH = 1
GLOBAL CONST $DDD_REMOVE_DEFINITION = 2
GLOBAL CONST $FSCTL_ALLOW_EXTENDED_DASD_IO = 589955
GLOBAL CONST $FSCTL_CREATE_OR_GET_OBJECT_ID = 590016
GLOBAL CONST $FSCTL_CREATE_USN_JOURNAL = 590055
GLOBAL CONST $FSCTL_DELETE_OBJECT_ID = 589984
GLOBAL CONST $FSCTL_DELETE_REPARSE_POINT = 589996
GLOBAL CONST $FSCTL_DELETE_USN_JOURNAL = 590072
GLOBAL CONST $FSCTL_DISMOUNT_VOLUME = 589856
GLOBAL CONST $FSCTL_DUMP_PROPERTY_DATA = 589975
GLOBAL CONST $FSCTL_ENABLE_UPGRADE = 622800
GLOBAL CONST $FSCTL_ENCRYPTION_FSCTL_IO = 590043
GLOBAL CONST $FSCTL_ENUM_USN_DATA = 590003
GLOBAL CONST $FSCTL_EXTEND_VOLUME = 590064
GLOBAL CONST $FSCTL_FILESYSTEM_GET_STATISTICS = 589920
GLOBAL CONST $FSCTL_FIND_FILES_BY_SID = 589967
GLOBAL CONST $FSCTL_GET_COMPRESSION = 589884
GLOBAL CONST $FSCTL_GET_NTFS_FILE_RECORD = 589928
GLOBAL CONST $FSCTL_GET_NTFS_VOLUME_DATA = 589924
GLOBAL CONST $FSCTL_GET_OBJECT_ID = 589980
GLOBAL CONST $FSCTL_GET_REPARSE_POINT = 589992
GLOBAL CONST $FSCTL_GET_RETRIEVAL_POINTERS = 589939
GLOBAL CONST $FSCTL_GET_VOLUME_BITMAP = 589935
GLOBAL CONST $FSCTL_HSM_DATA = 639251
GLOBAL CONST $FSCTL_HSM_MSG = 639240
GLOBAL CONST $FSCTL_INVALIDATE_VOLUMES = 589908
GLOBAL CONST $FSCTL_IS_PATHNAME_VALID = 589868
GLOBAL CONST $FSCTL_IS_VOLUME_DIRTY = 589944
GLOBAL CONST $FSCTL_IS_VOLUME_MOUNTED = 589864
GLOBAL CONST $FSCTL_LOCK_VOLUME = 589848
GLOBAL CONST $FSCTL_MARK_AS_SYSTEM_HIVE = 589903
GLOBAL CONST $FSCTL_MARK_HANDLE = 590076
GLOBAL CONST $FSCTL_MARK_VOLUME_DIRTY = 589872
GLOBAL CONST $FSCTL_MOVE_FILE = 589940
GLOBAL CONST $FSCTL_OPBATCH_ACK_CLOSE_PENDING = 589840
GLOBAL CONST $FSCTL_OPLOCK_BREAK_ACK_NO_2 = 589904
GLOBAL CONST $FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = 589836
GLOBAL CONST $FSCTL_OPLOCK_BREAK_NOTIFY = 589844
GLOBAL CONST $FSCTL_QUERY_ALLOCATED_RANGES = 606415
GLOBAL CONST $FSCTL_QUERY_FAT_BPB = 589912
GLOBAL CONST $FSCTL_QUERY_RETRIEVAL_POINTERS = 589883
GLOBAL CONST $FSCTL_QUERY_USN_JOURNAL = 590068
GLOBAL CONST $FSCTL_READ_FILE_USN_DATA = 590059
GLOBAL CONST $FSCTL_READ_PROPERTY_DATA = 589959
GLOBAL CONST $FSCTL_READ_RAW_ENCRYPTED = 590051
GLOBAL CONST $FSCTL_READ_USN_JOURNAL = 590011
GLOBAL CONST $FSCTL_RECALL_FILE = 590103
GLOBAL CONST $FSCTL_REQUEST_BATCH_OPLOCK = 589832
GLOBAL CONST $FSCTL_REQUEST_FILTER_OPLOCK = 589916
GLOBAL CONST $FSCTL_REQUEST_OPLOCK_LEVEL_1 = 589824
GLOBAL CONST $FSCTL_REQUEST_OPLOCK_LEVEL_2 = 589828
GLOBAL CONST $FSCTL_SECURITY_ID_CHECK = 606391
GLOBAL CONST $FSCTL_SET_COMPRESSION = 639040
GLOBAL CONST $FSCTL_SET_ENCRYPTION = 590039
GLOBAL CONST $FSCTL_SET_OBJECT_ID = 589976
GLOBAL CONST $FSCTL_SET_OBJECT_ID_EXTENDED = 590012
GLOBAL CONST $FSCTL_SET_REPARSE_POINT = 589988
GLOBAL CONST $FSCTL_SET_SPARSE = 590020
GLOBAL CONST $FSCTL_SET_ZERO_DATA = 622792
GLOBAL CONST $FSCTL_SIS_COPYFILE = 590080
GLOBAL CONST $FSCTL_SIS_LINK_FILES = 639236
GLOBAL CONST $FSCTL_UNLOCK_VOLUME = 589852
GLOBAL CONST $FSCTL_WRITE_PROPERTY_DATA = 589963
GLOBAL CONST $FSCTL_WRITE_RAW_ENCRYPTED = 590047
GLOBAL CONST $FSCTL_WRITE_USN_CLOSE_RECORD = 590063
GLOBAL CONST $IOCTL_AACS_END_SESSION = 3363020
GLOBAL CONST $IOCTL_AACS_GENERATE_BINDING_NONCE = 3395824
GLOBAL CONST $IOCTL_AACS_GET_CERTIFICATE = 3363028
GLOBAL CONST $IOCTL_AACS_GET_CHALLENGE_KEY = 3363032
GLOBAL CONST $IOCTL_AACS_READ_BINDING_NONCE = 3363052
GLOBAL CONST $IOCTL_AACS_READ_MEDIA_ID = 3363048
GLOBAL CONST $IOCTL_AACS_READ_MEDIA_KEY_BLOCK = 3363012
GLOBAL CONST $IOCTL_AACS_READ_MEDIA_KEY_BLOCK_SIZE = 3363008
GLOBAL CONST $IOCTL_AACS_READ_SERIAL_NUMBER = 3363044
GLOBAL CONST $IOCTL_AACS_READ_VOLUME_ID = 3363040
GLOBAL CONST $IOCTL_AACS_SEND_CERTIFICATE = 3363024
GLOBAL CONST $IOCTL_AACS_SEND_CHALLENGE_KEY = 3363036
GLOBAL CONST $IOCTL_AACS_START_SESSION = 3363016
GLOBAL CONST $IOCTL_ATA_PASS_THROUGH = 315436
GLOBAL CONST $IOCTL_ATA_PASS_THROUGH_DIRECT = 315440
GLOBAL CONST $IOCTL_CDROM_CHECK_VERIFY = 149504
GLOBAL CONST $IOCTL_CDROM_DISK_TYPE = 131136
GLOBAL CONST $IOCTL_CDROM_EJECT_MEDIA = 149512
GLOBAL CONST $IOCTL_CDROM_FIND_NEW_DEVICES = 149528
GLOBAL CONST $IOCTL_CDROM_GET_CONFIGURATION = 147544
GLOBAL CONST $IOCTL_CDROM_GET_CONTROL = 147508
GLOBAL CONST $IOCTL_CDROM_GET_DRIVE_GEOMETRY = 147532
GLOBAL CONST $IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX = 147536
GLOBAL CONST $IOCTL_CDROM_GET_LAST_SESSION = 147512
GLOBAL CONST $IOCTL_CDROM_GET_VOLUME = 147476
GLOBAL CONST $IOCTL_CDROM_LOAD_MEDIA = 149516
GLOBAL CONST $IOCTL_CDROM_MEDIA_REMOVAL = 149508
GLOBAL CONST $IOCTL_CDROM_PAUSE_AUDIO = 147468
GLOBAL CONST $IOCTL_CDROM_PLAY_AUDIO_MSF = 147480
GLOBAL CONST $IOCTL_CDROM_RAW_READ = 147518
GLOBAL CONST $IOCTL_CDROM_READ_Q_CHANNEL = 147500
GLOBAL CONST $IOCTL_CDROM_READ_TOC = 147456
GLOBAL CONST $IOCTL_CDROM_READ_TOC_EX = 147540
GLOBAL CONST $IOCTL_CDROM_RELEASE = 149524
GLOBAL CONST $IOCTL_CDROM_RESERVE = 149520
GLOBAL CONST $IOCTL_CDROM_RESUME_AUDIO = 147472
GLOBAL CONST $IOCTL_CDROM_SEEK_AUDIO_MSF = 147460
GLOBAL CONST $IOCTL_CDROM_SET_VOLUME = 147496
GLOBAL CONST $IOCTL_CDROM_STOP_AUDIO = 147464
GLOBAL CONST $IOCTL_CDROM_UNLOAD_DRIVER = 151560
GLOBAL CONST $IOCTL_DISK_CHECK_VERIFY = 477184
GLOBAL CONST $IOCTL_DISK_CONTROLLER_NUMBER = 458820
GLOBAL CONST $IOCTL_DISK_CREATE_DISK = 507992
GLOBAL CONST $IOCTL_DISK_DELETE_DRIVE_LAYOUT = 508160
GLOBAL CONST $IOCTL_DISK_EJECT_MEDIA = 477192
GLOBAL CONST $IOCTL_DISK_FIND_NEW_DEVICES = 477208
GLOBAL CONST $IOCTL_DISK_FORMAT_TRACKS = 507928
GLOBAL CONST $IOCTL_DISK_FORMAT_TRACKS_EX = 507948
GLOBAL CONST $IOCTL_DISK_GET_CACHE_INFORMATION = 475348
GLOBAL CONST $IOCTL_DISK_GET_DRIVE_GEOMETRY = 458752
GLOBAL CONST $IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 458912
GLOBAL CONST $IOCTL_DISK_GET_DRIVE_LAYOUT = 475148
GLOBAL CONST $IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 458832
GLOBAL CONST $IOCTL_DISK_GET_LENGTH_INFO = 475228
GLOBAL CONST $IOCTL_DISK_GET_MEDIA_TYPES = 461824
GLOBAL CONST $IOCTL_DISK_GET_PARTITION_INFO = 475140
GLOBAL CONST $IOCTL_DISK_GET_PARTITION_INFO_EX = 458824
GLOBAL CONST $IOCTL_DISK_GET_WRITE_CACHE_STATE = 475356
GLOBAL CONST $IOCTL_DISK_GROW_PARTITION = 508112
GLOBAL CONST $IOCTL_DISK_HISTOGRAM_DATA = 458804
GLOBAL CONST $IOCTL_DISK_HISTOGRAM_RESET = 458808
GLOBAL CONST $IOCTL_DISK_HISTOGRAM_STRUCTURE = 458800
GLOBAL CONST $IOCTL_DISK_INTERNAL_CLEAR_VERIFY = 459783
GLOBAL CONST $IOCTL_DISK_INTERNAL_SET_NOTIFY = 459784
GLOBAL CONST $IOCTL_DISK_INTERNAL_SET_VERIFY = 459779
GLOBAL CONST $IOCTL_DISK_IS_WRITABLE = 458788
GLOBAL CONST $IOCTL_DISK_LOAD_MEDIA = 477196
GLOBAL CONST $IOCTL_DISK_LOGGING = 458792
GLOBAL CONST $IOCTL_DISK_MEDIA_REMOVAL = 477188
GLOBAL CONST $IOCTL_DISK_PERFORMANCE = 458784
GLOBAL CONST $IOCTL_DISK_PERFORMANCE_OFF = 458848
GLOBAL CONST $IOCTL_DISK_REASSIGN_BLOCKS = 507932
GLOBAL CONST $IOCTL_DISK_RELEASE = 477204
GLOBAL CONST $IOCTL_DISK_REQUEST_DATA = 458816
GLOBAL CONST $IOCTL_DISK_REQUEST_STRUCTURE = 458812
GLOBAL CONST $IOCTL_DISK_RESERVE = 477200
GLOBAL CONST $IOCTL_DISK_SET_CACHE_INFORMATION = 508120
GLOBAL CONST $IOCTL_DISK_SET_DRIVE_LAYOUT = 507920
GLOBAL CONST $IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 507988
GLOBAL CONST $IOCTL_DISK_SET_PARTITION_INFO = 507912
GLOBAL CONST $IOCTL_DISK_SET_PARTITION_INFO_EX = 507980
GLOBAL CONST $IOCTL_DISK_UPDATE_DRIVE_SIZE = 508104
GLOBAL CONST $IOCTL_DISK_UPDATE_PROPERTIES = 459072
GLOBAL CONST $IOCTL_DISK_VERIFY = 458772
GLOBAL CONST $IOCTL_DVD_END_SESSION = 3362828
GLOBAL CONST $IOCTL_DVD_GET_REGION = 3362836
GLOBAL CONST $IOCTL_DVD_READ_KEY = 3362820
GLOBAL CONST $IOCTL_DVD_READ_STRUCTURE = 3363136
GLOBAL CONST $IOCTL_DVD_SEND_KEY = 3362824
GLOBAL CONST $IOCTL_DVD_SEND_KEY2 = 3395608
GLOBAL CONST $IOCTL_DVD_SET_READ_AHEAD = 3362832
GLOBAL CONST $IOCTL_DVD_START_SESSION = 3362816
GLOBAL CONST $IOCTL_MOUNTDEV_LINK_CREATED = 5046288
GLOBAL CONST $IOCTL_MOUNTDEV_LINK_DELETED = 5046292
GLOBAL CONST $IOCTL_MOUNTDEV_QUERY_STABLE_GUID = 5046296
GLOBAL CONST $IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME = 5046284
GLOBAL CONST $IOCTL_MOUNTDEV_QUERY_UNIQUE_ID = 5046272
GLOBAL CONST $IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY = 5046276
GLOBAL CONST $IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS = 7192596
GLOBAL CONST $IOCTL_MOUNTMGR_CHANGE_NOTIFY = 7159840
GLOBAL CONST $IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES = 7159848
GLOBAL CONST $IOCTL_MOUNTMGR_CREATE_POINT = 7192576
GLOBAL CONST $IOCTL_MOUNTMGR_DELETE_POINTS = 7192580
GLOBAL CONST $IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY = 7192588
GLOBAL CONST $IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE = 7192612
GLOBAL CONST $IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER = 7192592
GLOBAL CONST $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH = 7143472
GLOBAL CONST $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS = 7143476
GLOBAL CONST $IOCTL_MOUNTMGR_QUERY_POINTS = 7143432
GLOBAL CONST $IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION = 7159852
GLOBAL CONST $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED = 7192600
GLOBAL CONST $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED = 7192604
GLOBAL CONST $IOCTL_SCSI_GET_INQUIRY_DATA = 266252
GLOBAL CONST $IOCTL_SCSI_GET_CAPABILITIES = 266256
GLOBAL CONST $IOCTL_SCSI_GET_ADDRESS = 266264
GLOBAL CONST $IOCTL_SCSI_MINIPORT = 315400
GLOBAL CONST $IOCTL_SCSI_PASS_THROUGH = 315396
GLOBAL CONST $IOCTL_SCSI_PASS_THROUGH_DIRECT = 315412
GLOBAL CONST $IOCTL_SCSI_RESCAN_BUS = 266268
GLOBAL CONST $IOCTL_STORAGE_BREAK_RESERVATION = 2969620
GLOBAL CONST $IOCTL_STORAGE_CHECK_VERIFY = 2967552
GLOBAL CONST $IOCTL_STORAGE_CHECK_VERIFY2 = 2951168
GLOBAL CONST $IOCTL_STORAGE_EJECT_MEDIA = 2967560
GLOBAL CONST $IOCTL_STORAGE_EJECTION_CONTROL = 2951488
GLOBAL CONST $IOCTL_STORAGE_FIND_NEW_DEVICES = 2967576
GLOBAL CONST $IOCTL_STORAGE_GET_DEVICE_NUMBER = 2953344
GLOBAL CONST $IOCTL_STORAGE_GET_HOTPLUG_INFO = 2952212
GLOBAL CONST $IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = 2952208
GLOBAL CONST $IOCTL_STORAGE_GET_MEDIA_TYPES = 2952192
GLOBAL CONST $IOCTL_STORAGE_GET_MEDIA_TYPES_EX = 2952196
GLOBAL CONST $IOCTL_STORAGE_LOAD_MEDIA = 2967564
GLOBAL CONST $IOCTL_STORAGE_LOAD_MEDIA2 = 2951180
GLOBAL CONST $IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = 2987012
GLOBAL CONST $IOCTL_STORAGE_MCN_CONTROL = 2951492
GLOBAL CONST $IOCTL_STORAGE_MEDIA_REMOVAL = 2967556
GLOBAL CONST $IOCTL_STORAGE_PERSISTENT_RESERVE_IN = 2969624
GLOBAL CONST $IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = 2969628
GLOBAL CONST $IOCTL_STORAGE_PREDICT_FAILURE = 2953472
GLOBAL CONST $IOCTL_STORAGE_QUERY_PROPERTY = 2954240
GLOBAL CONST $IOCTL_STORAGE_RELEASE = 2967572
GLOBAL CONST $IOCTL_STORAGE_RESERVE = 2967568
GLOBAL CONST $IOCTL_STORAGE_RESET_BUS = 2969600
GLOBAL CONST $IOCTL_STORAGE_RESET_DEVICE = 2969604
GLOBAL CONST $IOCTL_STORAGE_SET_HOTPLUG_INFO = 3001368
GLOBAL CONST $IOCTL_STORAGE_SET_READ_AHEAD = 2966528
GLOBAL CONST $IOCTL_VOLUME_GET_GPT_ATTRIBUTES = 5636152
GLOBAL CONST $IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 5636096
GLOBAL CONST $IOCTL_VOLUME_IS_CLUSTERED = 5636144
GLOBAL CONST $IOCTL_VOLUME_IS_IO_CAPABLE = 5636116
GLOBAL CONST $IOCTL_VOLUME_IS_OFFLINE = 5636112
GLOBAL CONST $IOCTL_VOLUME_IS_PARTITION = 5636136
GLOBAL CONST $IOCTL_VOLUME_LOGICAL_TO_PHYSICAL = 5636128
GLOBAL CONST $IOCTL_VOLUME_OFFLINE = 5685260
GLOBAL CONST $IOCTL_VOLUME_ONLINE = 5685256
GLOBAL CONST $IOCTL_VOLUME_PHYSICAL_TO_LOGICAL = 5636132
GLOBAL CONST $IOCTL_VOLUME_QUERY_FAILOVER_SET = 5636120
GLOBAL CONST $IOCTL_VOLUME_QUERY_VOLUME_NUMBER = 5636124
GLOBAL CONST $IOCTL_VOLUME_READ_PLEX = 5652526
GLOBAL CONST $IOCTL_VOLUME_SET_GPT_ATTRIBUTES = 5636148
GLOBAL CONST $IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE = 5636100
GLOBAL CONST $SMART_GET_VERSION = 475264
GLOBAL CONST $SMART_RCV_DRIVE_DATA = 508040
GLOBAL CONST $SMART_SEND_DRIVE_COMMAND = 508036
GLOBAL CONST $FILE_ENCRYPTABLE = 0
GLOBAL CONST $FILE_IS_ENCRYPTED = 1
GLOBAL CONST $FILE_READ_ONLY = 8
GLOBAL CONST $FILE_ROOT_DIR = 3
GLOBAL CONST $FILE_SYSTEM_ATTR = 2
GLOBAL CONST $FILE_SYSTEM_DIR = 4
GLOBAL CONST $FILE_SYSTEM_NOT_SUPPORT = 6
GLOBAL CONST $FILE_UNKNOWN = 5
GLOBAL CONST $FILE_USER_DISALLOWED = 7
GLOBAL CONST $SCS_32BIT_BINARY = 0
GLOBAL CONST $SCS_64BIT_BINARY = 6
GLOBAL CONST $SCS_DOS_BINARY = 1
GLOBAL CONST $SCS_OS216_BINARY = 5
GLOBAL CONST $SCS_PIF_BINARY = 3
GLOBAL CONST $SCS_POSIX_BINARY = 4
GLOBAL CONST $SCS_WOW_BINARY = 2
GLOBAL CONST $DRIVE_BUS_TYPE_UNKNOWN = 0
GLOBAL CONST $DRIVE_BUS_TYPE_SCSI = 1
GLOBAL CONST $DRIVE_BUS_TYPE_ATAPI = 2
GLOBAL CONST $DRIVE_BUS_TYPE_ATA = 3
GLOBAL CONST $DRIVE_BUS_TYPE_1394 = 4
GLOBAL CONST $DRIVE_BUS_TYPE_SSA = 5
GLOBAL CONST $DRIVE_BUS_TYPE_FIBRE = 6
GLOBAL CONST $DRIVE_BUS_TYPE_USB = 7
GLOBAL CONST $DRIVE_BUS_TYPE_RAID = 8
GLOBAL CONST $DRIVE_BUS_TYPE_ISCSI = 9
GLOBAL CONST $DRIVE_BUS_TYPE_SAS = 10
GLOBAL CONST $DRIVE_BUS_TYPE_SATA = 11
GLOBAL CONST $DRIVE_BUS_TYPE_SD = 12
GLOBAL CONST $DRIVE_BUS_TYPE_MMC = 13
GLOBAL CONST $DRIVE_UNKNOWN = 0
GLOBAL CONST $DRIVE_NO_ROOT_DIR = 1
GLOBAL CONST $DRIVE_REMOVABLE = 2
GLOBAL CONST $DRIVE_FIXED = 3
GLOBAL CONST $DRIVE_REMOTE = 4
GLOBAL CONST $DRIVE_CDROM = 5
GLOBAL CONST $DRIVE_RAMDISK = 6
GLOBAL CONST $FILE_TYPE_CHAR = 2
GLOBAL CONST $FILE_TYPE_DISK = 1
GLOBAL CONST $FILE_TYPE_PIPE = 3
GLOBAL CONST $FILE_TYPE_REMOTE = 32768
GLOBAL CONST $FILE_TYPE_UNKNOWN = 0
GLOBAL CONST $FILE_NAME_NORMALIZED = 0
GLOBAL CONST $FILE_NAME_OPENED = 8
GLOBAL CONST $VOLUME_NAME_DOS = 0
GLOBAL CONST $VOLUME_NAME_GUID = 1
GLOBAL CONST $VOLUME_NAME_NONE = 4
GLOBAL CONST $VOLUME_NAME_NT = 2
GLOBAL CONST $IMAGE_FILE_MACHINE_UNKNOWN = 0
GLOBAL CONST $IMAGE_FILE_MACHINE_AM33 = 467
GLOBAL CONST $IMAGE_FILE_MACHINE_AMD64 = 34404
GLOBAL CONST $IMAGE_FILE_MACHINE_ARM = 448
GLOBAL CONST $IMAGE_FILE_MACHINE_EBC = 3772
GLOBAL CONST $IMAGE_FILE_MACHINE_I386 = 332
GLOBAL CONST $IMAGE_FILE_MACHINE_IA64 = 512
GLOBAL CONST $IMAGE_FILE_MACHINE_M32R = 36929
GLOBAL CONST $IMAGE_FILE_MACHINE_MIPS16 = 614
GLOBAL CONST $IMAGE_FILE_MACHINE_MIPSFPU = 870
GLOBAL CONST $IMAGE_FILE_MACHINE_MIPSFPU16 = 1126
GLOBAL CONST $IMAGE_FILE_MACHINE_POWERPC = 496
GLOBAL CONST $IMAGE_FILE_MACHINE_POWERPCFP = 497
GLOBAL CONST $IMAGE_FILE_MACHINE_R4000 = 358
GLOBAL CONST $IMAGE_FILE_MACHINE_SH3 = 418
GLOBAL CONST $IMAGE_FILE_MACHINE_SH3DSP = 419
GLOBAL CONST $IMAGE_FILE_MACHINE_SH4 = 422
GLOBAL CONST $IMAGE_FILE_MACHINE_SH5 = 424
GLOBAL CONST $IMAGE_FILE_MACHINE_THUMB = 450
GLOBAL CONST $IMAGE_FILE_MACHINE_WCEMIPSV2 = 361
GLOBAL CONST $FILE_CASE_PRESERVED_NAMES = 2
GLOBAL CONST $FILE_CASE_SENSITIVE_SEARCH = 1
GLOBAL CONST $FILE_FILE_COMPRESSION = 16
GLOBAL CONST $FILE_NAMED_STREAMS = 262144
GLOBAL CONST $FILE_PERSISTENT_ACLS = 8
GLOBAL CONST $FILE_READ_ONLY_VOLUME = 524288
GLOBAL CONST $FILE_SEQUENTIAL_WRITE_ONCE = 1048576
GLOBAL CONST $FILE_SUPPORTS_ENCRYPTION = 131072
GLOBAL CONST $FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 8388608
GLOBAL CONST $FILE_SUPPORTS_HARD_LINKS = 4194304
GLOBAL CONST $FILE_SUPPORTS_OBJECT_IDS = 65536
GLOBAL CONST $FILE_SUPPORTS_OPEN_BY_FILE_ID = 16777216
GLOBAL CONST $FILE_SUPPORTS_REPARSE_POINTS = 128
GLOBAL CONST $FILE_SUPPORTS_SPARSE_FILES = 64
GLOBAL CONST $FILE_SUPPORTS_TRANSACTIONS = 2097152
GLOBAL CONST $FILE_SUPPORTS_USN_JOURNAL = 33554432
GLOBAL CONST $FILE_UNICODE_ON_DISK = 4
GLOBAL CONST $FILE_VOLUME_IS_COMPRESSED = 32768
GLOBAL CONST $FILE_VOLUME_QUOTAS = 32
GLOBAL CONST $FILE_DEVICE_8042_PORT = 39
GLOBAL CONST $FILE_DEVICE_ACPI = 50
GLOBAL CONST $FILE_DEVICE_BATTERY = 41
GLOBAL CONST $FILE_DEVICE_BEEP = 1
GLOBAL CONST $FILE_DEVICE_BUS_EXTENDER = 42
GLOBAL CONST $FILE_DEVICE_CD_ROM = 2
GLOBAL CONST $FILE_DEVICE_CD_ROM_FILE_SYSTEM = 3
GLOBAL CONST $FILE_DEVICE_CHANGER = 48
GLOBAL CONST $FILE_DEVICE_CONTROLLER = 4
GLOBAL CONST $FILE_DEVICE_DATALINK = 5
GLOBAL CONST $FILE_DEVICE_DFS = 6
GLOBAL CONST $FILE_DEVICE_DFS_FILE_SYSTEM = 53
GLOBAL CONST $FILE_DEVICE_DFS_VOLUME = 54
GLOBAL CONST $FILE_DEVICE_DISK = 7
GLOBAL CONST $FILE_DEVICE_DISK_FILE_SYSTEM = 8
GLOBAL CONST $FILE_DEVICE_DVD = 51
GLOBAL CONST $FILE_DEVICE_FILE_SYSTEM = 9
GLOBAL CONST $FILE_DEVICE_FIPS = 58
GLOBAL CONST $FILE_DEVICE_FULLSCREEN_VIDEO = 52
GLOBAL CONST $FILE_DEVICE_INPORT_PORT = 10
GLOBAL CONST $FILE_DEVICE_KEYBOARD = 11
GLOBAL CONST $FILE_DEVICE_KS = 47
GLOBAL CONST $FILE_DEVICE_KSEC = 57
GLOBAL CONST $FILE_DEVICE_MAILSLOT = 12
GLOBAL CONST $FILE_DEVICE_MASS_STORAGE = 45
GLOBAL CONST $FILE_DEVICE_MIDI_IN = 13
GLOBAL CONST $FILE_DEVICE_MIDI_OUT = 14
GLOBAL CONST $FILE_DEVICE_MODEM = 43
GLOBAL CONST $FILE_DEVICE_MOUSE = 15
GLOBAL CONST $FILE_DEVICE_MULTI_UNC_PROVIDER = 16
GLOBAL CONST $FILE_DEVICE_NAMED_PIPE = 17
GLOBAL CONST $FILE_DEVICE_NETWORK = 18
GLOBAL CONST $FILE_DEVICE_NETWORK_BROWSER = 19
GLOBAL CONST $FILE_DEVICE_NETWORK_FILE_SYSTEM = 20
GLOBAL CONST $FILE_DEVICE_NETWORK_REDIRECTOR = 40
GLOBAL CONST $FILE_DEVICE_NULL = 21
GLOBAL CONST $FILE_DEVICE_PARALLEL_PORT = 22
GLOBAL CONST $FILE_DEVICE_PHYSICAL_NETCARD = 23
GLOBAL CONST $FILE_DEVICE_PRINTER = 24
GLOBAL CONST $FILE_DEVICE_SCANNER = 25
GLOBAL CONST $FILE_DEVICE_SCREEN = 28
GLOBAL CONST $FILE_DEVICE_SERENUM = 55
GLOBAL CONST $FILE_DEVICE_SERIAL_MOUSE_PORT = 26
GLOBAL CONST $FILE_DEVICE_SERIAL_PORT = 27
GLOBAL CONST $FILE_DEVICE_SMARTCARD = 49
GLOBAL CONST $FILE_DEVICE_SMB = 46
GLOBAL CONST $FILE_DEVICE_SOUND = 29
GLOBAL CONST $FILE_DEVICE_STREAMS = 30
GLOBAL CONST $FILE_DEVICE_TAPE = 31
GLOBAL CONST $FILE_DEVICE_TAPE_FILE_SYSTEM = 32
GLOBAL CONST $FILE_DEVICE_TERMSRV = 56
GLOBAL CONST $FILE_DEVICE_TRANSPORT = 33
GLOBAL CONST $FILE_DEVICE_UNKNOWN = 34
GLOBAL CONST $FILE_DEVICE_VDM = 44
GLOBAL CONST $FILE_DEVICE_VIDEO = 35
GLOBAL CONST $FILE_DEVICE_VIRTUAL_DISK = 36
GLOBAL CONST $FILE_DEVICE_WAVE_IN = 37
GLOBAL CONST $FILE_DEVICE_WAVE_OUT = 38
GLOBAL CONST $FILE_ANY_ACCESS = 0
GLOBAL CONST $FILE_SPECIAL_ACCESS = $FILE_ANY_ACCESS
GLOBAL CONST $FILE_READ_ACCESS = 1
GLOBAL CONST $FILE_WRITE_ACCESS = 2
GLOBAL CONST $METHOD_BUFFERED = 0
GLOBAL CONST $METHOD_IN_DIRECT = 1
GLOBAL CONST $METHOD_OUT_DIRECT = 2
GLOBAL CONST $METHOD_NEITHER = 3
GLOBAL CONST $FILE_NOTIFY_CHANGE_FILE_NAME = 1
GLOBAL CONST $FILE_NOTIFY_CHANGE_DIR_NAME = 2
GLOBAL CONST $FILE_NOTIFY_CHANGE_ATTRIBUTES = 4
GLOBAL CONST $FILE_NOTIFY_CHANGE_SIZE = 8
GLOBAL CONST $FILE_NOTIFY_CHANGE_LAST_WRITE = 16
GLOBAL CONST $FILE_NOTIFY_CHANGE_LAST_ACCESS = 32
GLOBAL CONST $FILE_NOTIFY_CHANGE_CREATION = 64
GLOBAL CONST $FILE_NOTIFY_CHANGE_SECURITY = 256
GLOBAL CONST $FILE_ACTION_ADDED = 1
GLOBAL CONST $FILE_ACTION_REMOVED = 2
GLOBAL CONST $FILE_ACTION_MODIFIED = 3
GLOBAL CONST $FILE_ACTION_RENAMED_OLD_NAME = 4
GLOBAL CONST $FILE_ACTION_RENAMED_NEW_NAME = 5
GLOBAL CONST $REPLACEFILE_WRITE_THROUGH = 1
GLOBAL CONST $REPLACEFILE_IGNORE_MERGE_ERRORS = 2
GLOBAL CONST $REPLACEFILE_IGNORE_ACL_ERRORS = 4
GLOBAL CONST $BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 1
GLOBAL CONST $BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 65536
GLOBAL CONST $BASE_SEARCH_PATH_PERMANENT = 32768
GLOBAL CONST $GMEM_FIXED = 0
GLOBAL CONST $GMEM_MOVEABLE = 2
GLOBAL CONST $GMEM_NOCOMPACT = 16
GLOBAL CONST $GMEM_NODISCARD = 32
GLOBAL CONST $GMEM_ZEROINIT = 64
GLOBAL CONST $GMEM_MODIFY = 128
GLOBAL CONST $GMEM_DISCARDABLE = 256
GLOBAL CONST $GMEM_NOT_BANKED = 4096
GLOBAL CONST $GMEM_SHARE = 8192
GLOBAL CONST $GMEM_DDESHARE = 8192
GLOBAL CONST $GMEM_NOTIFY = 16384
GLOBAL CONST $GMEM_LOWER = 4096
GLOBAL CONST $GMEM_VALID_FLAGS = 32626
GLOBAL CONST $GMEM_INVALID_HANDLE = 32768
GLOBAL CONST $GPTR = BITOR($GMEM_FIXED, $GMEM_ZEROINIT)
GLOBAL CONST $GHND = BITOR($GMEM_MOVEABLE, $GMEM_ZEROINIT)
GLOBAL CONST $MEM_COMMIT = 4096
GLOBAL CONST $MEM_RESERVE = 8192
GLOBAL CONST $MEM_TOP_DOWN = 1048576
GLOBAL CONST $MEM_SHARED = 134217728
GLOBAL CONST $PAGE_NOACCESS = 1
GLOBAL CONST $PAGE_READONLY = 2
GLOBAL CONST $PAGE_READWRITE = 4
GLOBAL CONST $PAGE_EXECUTE = 16
GLOBAL CONST $PAGE_EXECUTE_READ = 32
GLOBAL CONST $PAGE_EXECUTE_READWRITE = 64
GLOBAL CONST $PAGE_EXECUTE_WRITECOPY = 128
GLOBAL CONST $PAGE_GUARD = 256
GLOBAL CONST $PAGE_NOCACHE = 512
GLOBAL CONST $PAGE_WRITECOMBINE = 1024
GLOBAL CONST $PAGE_WRITECOPY = 8
GLOBAL CONST $MEM_DECOMMIT = 16384
GLOBAL CONST $MEM_RELEASE = 32768
GLOBAL ENUM $MEM_LOAD, $MEM_TOTALPHYSRAM, $MEM_AVAILPHYSRAM, $MEM_TOTALPAGEFILE, $MEM_AVAILPAGEFILE, $MEM_TOTALVIRTUAL, $MEM_AVAILVIRTUAL
#Region Global Variables and Constants
	GLOBAL $__G_IHEAPSIZE = 8388608
	GLOBAL CONST $TAGFILEINFO = "uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes"
	GLOBAL CONST $TAGFILE_ID_DESCRIPTOR = "dword Size;uint Type;" & $TAGGUID
	GLOBAL CONST $TAGWIN32_FIND_STREAM_DATA = "int64 StreamSize;wchar StreamName[296]"
	GLOBAL CONST $TAGWIN32_STREAM_ID = "dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;wchar StreamName[1]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BACKUPREAD($HFILE, $PBUFFER, $ILENGTH, BYREF $IBYTES, BYREF $PCONTEXT, $BSECURITY = FALSE)
		$IBYTES = 0
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "BackupRead", "handle", $HFILE, "struct*", $PBUFFER, "dword", $ILENGTH, "dword*", 0, "bool", 0, "bool", $BSECURITY, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IBYTES = $ACALL[4]
		$PCONTEXT = $ACALL[7]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BACKUPREADABORT(BYREF $PCONTEXT)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "BackupRead", "handle", 0, "ptr", 0, "dword", 0, "dword*", 0, "bool", 1, "bool", 0, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$PCONTEXT = $ACALL[7]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BACKUPSEEK($HFILE, $ISEEK, BYREF $IBYTES, BYREF $PCONTEXT)
		$IBYTES = 0
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "BackupSeek", "handle", $HFILE, "dword", _WINAPI_LODWORD($ISEEK), "dword", _WINAPI_HIDWORD($ISEEK), "dword*", 0, "dword*", 0, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IBYTES = __WINAPI_MAKEQWORD($ACALL[4], $ACALL[5])
		$PCONTEXT = $ACALL[6]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BACKUPWRITE($HFILE, $PBUFFER, $ILENGTH, BYREF $IBYTES, BYREF $PCONTEXT, $BSECURITY = FALSE)
		$IBYTES = 0
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "BackupWrite", "handle", $HFILE, "struct*", $PBUFFER, "dword", $ILENGTH, "dword*", 0, "bool", 0, "bool", $BSECURITY, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IBYTES = $ACALL[4]
		$PCONTEXT = $ACALL[7]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BACKUPWRITEABORT(BYREF $PCONTEXT)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "BackupWrite", "handle", 0, "ptr", 0, "dword", 0, "dword*", 0, "bool", 1, "bool", 0, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$PCONTEXT = $ACALL[7]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COPYFILEEX($SEXISTINGFILE, $SNEWFILE, $IFLAGS = 0, $PPROGRESSPROC = 0, $PDATA = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "CopyFileExW", "wstr", $SEXISTINGFILE, "wstr", $SNEWFILE, "ptr", $PPROGRESSPROC, "struct*", $PDATA, "bool*", 0, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDIRECTORY($SDIR, $TSECURITY = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "CreateDirectoryW", "wstr", $SDIR, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDIRECTORYEX($SNEWDIR, $STEMPLATEDIR, $TSECURITY = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "CreateDirectoryExW", "wstr", $STEMPLATEDIR, "wstr", $SNEWDIR, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEFILEEX($SFILEPATH, $ICREATION, $IACCESS = 0, $ISHARE = 0, $IFLAGSANDATTRIBUTES = 0, $TSECURITY = 0, $HTEMPLATE = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "CreateFileW", "wstr", $SFILEPATH, "dword", $IACCESS, "dword", $ISHARE, "struct*", $TSECURITY, "dword", $ICREATION, "dword", $IFLAGSANDATTRIBUTES, "handle", $HTEMPLATE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = PTR(-1) THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEFILEMAPPING($HFILE, $ISIZE = 0, $SNAME = "", $IPROTECT = 4, $TSECURITY = 0)
		IF NOT STRINGSTRIPWS($SNAME, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SNAME = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "CreateFileMappingW", "handle", $HFILE, "struct*", $TSECURITY, "dword", $IPROTECT, "dword", _WINAPI_HIDWORD($ISIZE), "dword", _WINAPI_LODWORD($ISIZE), "wstr", $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN SETEXTENDED(_WINAPI_GETLASTERROR(), $ACALL[0])
	ENDFUNC
	FUNC _WINAPI_CREATEHARDLINK($SNEWFILE, $SEXISTINGFILE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "CreateHardLinkW", "wstr", $SNEWFILE, "wstr", $SEXISTINGFILE, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEOBJECTID($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TFOID = DLLSTRUCTCREATE("byte[16];byte[48]")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 590016, "ptr", 0, "dword", 0, "struct*", $TFOID, "dword", DLLSTRUCTGETSIZE($TFOID), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		_WINAPI_MOVEMEMORY($TGUID, $TFOID, 16)
		RETURN $TGUID
	ENDFUNC
	FUNC _WINAPI_CREATESYMBOLICLINK($SSYMLINK, $STARGET, $BDIRECTORY = FALSE)
		IF $BDIRECTORY THEN
			$BDIRECTORY = 1
		ENDIF
		LOCAL $ACALL = DLLCALL("kernel32.dll", "boolean", "CreateSymbolicLinkW", "wstr", $SSYMLINK, "wstr", $STARGET, "dword", $BDIRECTORY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DECRYPTFILE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "DecryptFileW", "wstr", $SFILEPATH, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DEFINEDOSDEVICE($SDEVICE, $IFLAGS, $SFILEPATH = "")
		IF NOT STRINGSTRIPWS($SFILEPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SFILEPATH = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DefineDosDeviceW", "dword", $IFLAGS, "wstr", $SDEVICE, "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DELETEFILE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeleteFileW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DELETEOBJECTID($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_WRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 589984, "ptr", 0, "dword", 0, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DELETEVOLUMEMOUNTPOINT($SMOUNTEDPATH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeleteVolumeMountPointW", "wstr", $SMOUNTEDPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DEVICEIOCONTROL($HDEVICE, $ICONTROLCODE, $PINBUFFER = 0, $IINBUFFERSIZE = 0, $POUTBUFFER = 0, $IOUTBUFFERSIZE = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HDEVICE, "dword", $ICONTROLCODE, "struct*", $PINBUFFER, "dword", $IINBUFFERSIZE, "struct*", $POUTBUFFER, "dword", $IOUTBUFFERSIZE, "dword*", 0, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN SETEXTENDED($ACALL[7], $ACALL[0])
	ENDFUNC
	FUNC _WINAPI_DUPLICATEENCRYPTIONINFOFILE($SSRCFILEPATH, $SDESTFILEPATH, $ICREATION = 2, $IATTRIBUTES = 0, $TSECURITY = 0)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "dword", "DuplicateEncryptionInfoFile", "wstr", $SSRCFILEPATH, "wstr", $SDESTFILEPATH, "dword", $ICREATION, "dword", $IATTRIBUTES, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_EJECTMEDIA($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2967560, "ptr", 0, "dword", 0, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ENCRYPTFILE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "EncryptFileW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENCRYPTIONDISABLE($SDIR, $BDISABLE)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "EncryptionDisable", "wstr", $SDIR, "bool", $BDISABLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENUMFILES($SDIR, $IFLAG = 0, $STEMPLATE = "", $BEXCLUDE = FALSE)
		LOCAL $ACALL, $IERROR = 0
		LOCAL $ADATA[501][7] = [[0]]
		LOCAL $HDIR = _WINAPI_CREATEFILEEX($SDIR, $OPEN_EXISTING, 1, $FILE_SHARE_ANY, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $PBUFFER = __HEAPALLOC($__G_IHEAPSIZE)
		IF @ERROR THEN
			$IERROR = @ERROR
		ELSE
			LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
			$ACALL = DLLCALL("ntdll.dll", "uint", "ZwQueryDirectoryFile", "handle", $HDIR, "ptr", 0, "ptr", 0, "ptr", 0, "struct*", $TIOSB, "struct*", $PBUFFER, "ulong", 8388608, "uint", 1, "boolean", 0, "ptr", 0, "boolean", 1)
			IF @ERROR OR $ACALL[0] THEN
				$IERROR = @ERROR + 40
			ENDIF
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HDIR)
		IF $IERROR THEN
			__HEAPFREE($PBUFFER, 1)
			IF ISARRAY($ACALL) THEN
				RETURN SETERROR(10, $ACALL[0], 0)
			ELSE
				RETURN SETERROR($IERROR, 0, 0)
			ENDIF
		ENDIF
		LOCAL $TFDI, $IATTRIB, $STARGET, $ILENGTH = 0, $IOFFSET = 0
		DO
			$ILENGTH += $IOFFSET
			$TFDI = DLLSTRUCTCREATE("ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[" & (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ulong", $PBUFFER + $ILENGTH + 60), 1) / 2) & "]", $PBUFFER + $ILENGTH)
			$STARGET = DLLSTRUCTGETDATA($TFDI, 11)
			$IATTRIB = DLLSTRUCTGETDATA($TFDI, 9)
			$IOFFSET = DLLSTRUCTGETDATA($TFDI, 1)
			SWITCH $STARGET
				CASE ".", ".."
					CONTINUELOOP
				CASE ELSE
					SWITCH $IFLAG
						CASE 1, 2
							IF BITAND($IATTRIB, 16) THEN
								IF $IFLAG = 1 THEN
									CONTINUELOOP
								ENDIF
							ELSE
								IF $IFLAG = 2 THEN
									CONTINUELOOP
								ENDIF
							ENDIF
					ENDSWITCH
					IF $STEMPLATE THEN
						$ACALL = DLLCALL("shlwapi.dll", "int", "PathMatchSpecW", "wstr", $STARGET, "wstr", $STEMPLATE)
						IF @ERROR OR($ACALL[0] AND $BEXCLUDE) OR(NOT $ACALL[0] AND NOT $BEXCLUDE) THEN
							CONTINUELOOP
						ENDIF
					ENDIF
			ENDSWITCH
			__INC($ADATA, 500)
			$ADATA[$ADATA[0][0]][0] = $STARGET
			$ADATA[$ADATA[0][0]][1] = DLLSTRUCTGETDATA($TFDI, 3)
			$ADATA[$ADATA[0][0]][2] = DLLSTRUCTGETDATA($TFDI, 4)
			$ADATA[$ADATA[0][0]][3] = DLLSTRUCTGETDATA($TFDI, 5)
			$ADATA[$ADATA[0][0]][4] = DLLSTRUCTGETDATA($TFDI, 7)
			$ADATA[$ADATA[0][0]][5] = DLLSTRUCTGETDATA($TFDI, 8)
			$ADATA[$ADATA[0][0]][6] = $IATTRIB
		UNTIL NOT $IOFFSET
		__HEAPFREE($PBUFFER)
		__INC($ADATA, -1)
		RETURN $ADATA
	ENDFUNC
	FUNC _WINAPI_ENUMFILESTREAMS($SFILEPATH)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[32768]")
		LOCAL $PDATA = DLLSTRUCTGETPTR($TDATA)
		LOCAL $ADATA[101][2] = [[0]]
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $IERROR = 0
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "ptr", $PDATA, "ulong", 32768, "uint", 22)
		IF @ERROR THEN $IERROR = @ERROR
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		LOCAL $TFSI, $ILENGTH = 0, $IOFFSET = 0
		DO
			$ILENGTH += $IOFFSET
			$TFSI = DLLSTRUCTCREATE("ulong;ulong;int64;int64;wchar[" & (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ulong", $PDATA + $ILENGTH + 4), 1) / 2) & "]", $PDATA + $ILENGTH)
			__INC($ADATA)
			$ADATA[$ADATA[0][0]][0] = DLLSTRUCTGETDATA($TFSI, 5)
			$ADATA[$ADATA[0][0]][1] = DLLSTRUCTGETDATA($TFSI, 3)
			$IOFFSET = DLLSTRUCTGETDATA($TFSI, 1)
		UNTIL NOT $IOFFSET
		__INC($ADATA, -1)
		RETURN $ADATA
	ENDFUNC
	FUNC _WINAPI_ENUMHARDLINKS($SFILEPATH)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[32768]")
		LOCAL $PDATA = DLLSTRUCTGETPTR($TDATA)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $IERROR = 0
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "ptr", $PDATA, "ulong", 32768, "uint", 46)
		IF @ERROR OR $ACALL[0] THEN
			$IERROR = @ERROR + 10
			DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
			IF $ACALL THEN RETURN SETERROR($IERROR, 0, 0)
			IF $ACALL[0] THEN RETURN SETERROR(10, $IERROR, 0)
		ENDIF
		LOCAL $ICOUNT = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ulong;ulong", $PDATA), 2)
		LOCAL $ADATA[$ICOUNT + 1] = [$ICOUNT]
		LOCAL $TFLEI, $HPATH, $SPATH, $ILENGTH = 8
		FOR $I = 1 TO $ICOUNT
			$TFLEI = DLLSTRUCTCREATE("ulong;int64;ulong;wchar[" & (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ulong", $PDATA + $ILENGTH + 16), 1)) & "]", $PDATA + $ILENGTH)
			$IERROR = 0
			DO
				$HPATH = _WINAPI_OPENFILEBYID($HFILE, DLLSTRUCTGETDATA($TFLEI, 2), 1048704, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
				IF @ERROR THEN
					$IERROR = @ERROR + 100
					EXITLOOP
				ENDIF
				$SPATH = _WINAPI_GETFINALPATHNAMEBYHANDLEEX($HPATH)
				IF @ERROR THEN
					$IERROR = @ERROR + 200
					EXITLOOP
				ENDIF
			UNTIL 1
			IF $HPATH THEN
				DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPATH)
			ENDIF
			IF $IERROR THEN EXITLOOP
			$ADATA[$I] = _WINAPI_PATHAPPEND($SPATH, DLLSTRUCTGETDATA($TFLEI, 4))
			$ILENGTH += DLLSTRUCTGETDATA($TFLEI, 1)
		NEXT
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ADATA
	ENDFUNC
	FUNC _WINAPI_FILEENCRYPTIONSTATUS($SFILEPATH)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "FileEncryptionStatusW", "wstr", $SFILEPATH, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, -1)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_FILEEXISTS($SFILEPATH)
		IF NOT FILEEXISTS($SFILEPATH) THEN RETURN 0
		IF _WINAPI_PATHISDIRECTORY($SFILEPATH) THEN RETURN SETEXTENDED(1, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_FILEINUSE($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_READ)
		IF @ERROR THEN
			IF @EXTENDED = 32 THEN RETURN 1
			RETURN SETERROR(@ERROR, @EXTENDED, 0)
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		RETURN 0
	ENDFUNC
	FUNC _WINAPI_FINDCLOSE($HSEARCH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FindClose", "handle", $HSEARCH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDCLOSECHANGENOTIFICATION($HCHANGE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FindCloseChangeNotification", "handle", $HCHANGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDFIRSTCHANGENOTIFICATION($SDIRECTORY, $IFLAGS, $BSUBTREE = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "FindFirstChangeNotificationW", "wstr", $SDIRECTORY, "bool", $BSUBTREE, "dword", $IFLAGS)
		IF @ERROR OR($ACALL[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDFIRSTFILE($SFILEPATH, $TDATA)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "FindFirstFileW", "wstr", $SFILEPATH, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = PTR(-1) THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDFIRSTFILENAME($SFILEPATH, BYREF $SLINK)
		$SLINK = ""
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "FindFirstFileNameW", "wstr", $SFILEPATH, "dword", 0, "dword*", 4096, "wstr", "")
		IF @ERROR OR($ACALL[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		$SLINK = $ACALL[4]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDFIRSTSTREAM($SFILEPATH, $TDATA)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "FindFirstStreamW", "wstr", $SFILEPATH, "uint", 0, "struct*", $TDATA, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = PTR(-1) THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDNEXTCHANGENOTIFICATION($HCHANGE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FindNextChangeNotification", "handle", $HCHANGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDNEXTFILE($HSEARCH, $TDATA)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FindNextFileW", "handle", $HSEARCH, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDNEXTFILENAME($HSEARCH, BYREF $SLINK)
		$SLINK = ""
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FindNextFileNameW", "handle", $HSEARCH, "dword*", 4096, "wstr", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		$SLINK = $ACALL[3]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDNEXTSTREAM($HSEARCH, $TDATA)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FindNextStreamW", "handle", $HSEARCH, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FLUSHFILEBUFFERS($HFILE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FlushFileBuffers", "handle", $HFILE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FLUSHVIEWOFFILE($PADDRESS, $IBYTES = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FlushViewOfFile", "struct*", $PADDRESS, "dword", $IBYTES)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETBINARYTYPE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "GetBinaryTypeW", "wstr", $SFILEPATH, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ACALL[0] THEN $ACALL[2] = 0
		RETURN SETEXTENDED($ACALL[2], $ACALL[0])
	ENDFUNC
	FUNC _WINAPI_GETCDTYPE($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TAGSCSI_PASS_THROUGH = "struct;ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];endstruct"
		LOCAL $TSPT = DLLSTRUCTCREATE($TAGSCSI_PASS_THROUGH & ";byte Hdr[8]")
		LOCAL $TCDB = DLLSTRUCTCREATE("byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]", DLLSTRUCTGETPTR($TSPT, "Cdb"))
		LOCAL $THDR = DLLSTRUCTCREATE("byte[4];byte;byte;byte[2]", DLLSTRUCTGETPTR($TSPT, "Hdr"))
		LOCAL $ISIZE = DLLSTRUCTGETPTR($TSPT, "Hdr") - DLLSTRUCTGETPTR($TSPT)
		DLLSTRUCTSETDATA($TSPT, "Length", $ISIZE)
		DLLSTRUCTSETDATA($TSPT, "ScsiStatus", 0)
		DLLSTRUCTSETDATA($TSPT, "PathId", 0)
		DLLSTRUCTSETDATA($TSPT, "TargetId", 0)
		DLLSTRUCTSETDATA($TSPT, "Lun", 0)
		DLLSTRUCTSETDATA($TSPT, "CdbLength", 12)
		DLLSTRUCTSETDATA($TSPT, "SenseInfoLength", 0)
		DLLSTRUCTSETDATA($TSPT, "DataIn", 1)
		DLLSTRUCTSETDATA($TSPT, "DataTransferLength", 8)
		DLLSTRUCTSETDATA($TSPT, "TimeOutValue", 86400)
		DLLSTRUCTSETDATA($TSPT, "DataBufferOffset", $ISIZE)
		DLLSTRUCTSETDATA($TSPT, "SenseInfoOffset", 0)
		DLLSTRUCTSETDATA($TCDB, 1, 70)
		DLLSTRUCTSETDATA($TCDB, 2, 0)
		DLLSTRUCTSETDATA($TCDB, 3, 0, 1)
		DLLSTRUCTSETDATA($TCDB, 3, 0, 2)
		DLLSTRUCTSETDATA($TCDB, 5, 0, 1)
		DLLSTRUCTSETDATA($TCDB, 5, 8, 2)
		DLLSTRUCTSETDATA($TCDB, 6, 0)
		DLLSTRUCTSETDATA($TCDB, 7, 0, 1)
		DLLSTRUCTSETDATA($TCDB, 7, 0, 2)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 315396, "struct*", $TSPT, "dword", $ISIZE, "struct*", $TSPT, "dword", DLLSTRUCTGETSIZE($TSPT), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN BITOR(BITSHIFT(DLLSTRUCTGETDATA($THDR, 4, 1), -8), DLLSTRUCTGETDATA($THDR, 4, 2))
	ENDFUNC
	FUNC _WINAPI_GETCOMPRESSEDFILESIZE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetCompressedFileSizeW", "wstr", $SFILEPATH, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = -1 THEN
			LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
			IF $ACALL[2] = 0 THEN RETURN SETERROR(10, $ILASTERROR, 0)
			IF $ILASTERROR THEN RETURN SETERROR(11, $ILASTERROR, 0)
		ENDIF
		RETURN __WINAPI_MAKEQWORD($ACALL[0], $ACALL[2])
	ENDFUNC
	FUNC _WINAPI_GETCOMPRESSION($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 589884, "ptr", 0, "dword", 0, "ushort*", 0, "dword", 2, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[5]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTDIRECTORY()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetCurrentDirectoryW", "dword", 4096, "wstr", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ACALL[0], $ACALL[2])
	ENDFUNC
	FUNC _WINAPI_GETDISKFREESPACEEX($SDRIVE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetDiskFreeSpaceEx", "str", $SDRIVE, "int64*", 0, "int64*", 0, "int64*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[3]
		FOR $I = 0 TO 2
			$ARET[$I] = $ACALL[$I + 2]
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETDRIVEBUSTYPE($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, -1)
		LOCAL $TAGSTORAGE_PROPERTY_QUERY = "ulong PropertyId;ulong QueryType;byte AdditionalParameters[1]"
		LOCAL $TSPQ = DLLSTRUCTCREATE($TAGSTORAGE_PROPERTY_QUERY)
		LOCAL $TSDD = DLLSTRUCTCREATE("ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]")
		DLLSTRUCTSETDATA($TSPQ, "PropertyId", 0)
		DLLSTRUCTSETDATA($TSPQ, "QueryType", 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2954240, "struct*", $TSPQ, "dword", DLLSTRUCTGETSIZE($TSPQ), "struct*", $TSDD, "dword", DLLSTRUCTGETSIZE($TSDD), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN DLLSTRUCTGETDATA($TSDD, "BusType")
	ENDFUNC
	FUNC _WINAPI_GETDRIVEGEOMETRYEX($IDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\PhysicalDrive" & $IDRIVE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TDGEX = DLLSTRUCTCREATE("uint64;dword;dword;dword;dword;uint64")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 458912, "ptr", 0, "dword", 0, "struct*", $TDGEX, "dword", DLLSTRUCTGETSIZE($TDGEX), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET[6]
		FOR $I = 0 TO 5
			$ARET[$I] = DLLSTRUCTGETDATA($TDGEX, $I + 1)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETDRIVENUMBER($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TSDN = DLLSTRUCTCREATE("dword;dword;dword")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2953344, "ptr", 0, "dword", 0, "struct*", $TSDN, "dword", DLLSTRUCTGETSIZE($TSDN), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET[3]
		FOR $I = 0 TO 2
			$ARET[$I] = DLLSTRUCTGETDATA($TSDN, $I + 1)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETDRIVETYPE($SDRIVE = "")
		IF NOT STRINGSTRIPWS($SDRIVE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SDRIVE = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "uint", "GetDriveType", "str", $SDRIVE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETFILEATTRIBUTES($SFILEPATH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetFileAttributesW", "wstr", $SFILEPATH)
		IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETFILEID($HFILE)
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "int64*", 0, "ulong", 8, "uint", 6)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_GETFILEINFORMATIONBYHANDLE($HFILE)
		LOCAL $TBHFI = DLLSTRUCTCREATE("dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetFileInformationByHandle", "handle", $HFILE, "struct*", $TBHFI)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[8]
		$ARET[0] = DLLSTRUCTGETDATA($TBHFI, 1)
		FOR $I = 1 TO 3
			IF DLLSTRUCTGETDATA($TBHFI, $I + 1) THEN
				$ARET[$I] = DLLSTRUCTCREATE($TAGFILETIME)
				_WINAPI_MOVEMEMORY($ARET[$I], DLLSTRUCTGETPTR($TBHFI, $I + 1), 8)
			ELSE
				$ARET[$I] = 0
			ENDIF
		NEXT
		$ARET[4] = DLLSTRUCTGETDATA($TBHFI, 5)
		$ARET[5] = __WINAPI_MAKEQWORD(DLLSTRUCTGETDATA($TBHFI, 7), DLLSTRUCTGETDATA($TBHFI, 6))
		$ARET[6] = DLLSTRUCTGETDATA($TBHFI, 8)
		$ARET[7] = __WINAPI_MAKEQWORD(DLLSTRUCTGETDATA($TBHFI, 9), DLLSTRUCTGETDATA($TBHFI, 10))
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETFILEINFORMATIONBYHANDLEEX($HFILE)
		LOCAL $TFI = DLLSTRUCTCREATE($TAGFILEINFO)
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "struct*", $TFI, "ulong", DLLSTRUCTGETSIZE($TFI), "uint", 4)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $TFI
	ENDFUNC
	FUNC _WINAPI_GETFILEPOINTEREX($HFILE)
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "int64*", 0, "ulong", 8, "uint", 14)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_GETFILESIZEEX($HFILE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetFileSizeEx", "handle", $HFILE, "int64*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETFILESIZEONDISK($SFILEPATH)
		LOCAL $ISIZE = FILEGETSIZE($SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetDiskFreeSpaceW", "wstr", _WINAPI_PATHSTRIPTOROOT(_WINAPI_GETFULLPATHNAME($SFILEPATH)), "dword*", 0, "dword*", 0, "dword*", 0, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN CEILING($ISIZE / ($ACALL[2] * $ACALL[3])) * ($ACALL[2] * $ACALL[3])
	ENDFUNC
	FUNC _WINAPI_GETFILETITLE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("comdlg32.dll", "short", "GetFileTitleW", "wstr", $SFILEPATH, "wstr", "", "word", 4096)
		IF @ERROR OR $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETFILETYPE($HFILE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetFileType", "handle", $HFILE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
		IF NOT $ACALL[0] AND $ILASTERROR THEN RETURN SETERROR(10, $ILASTERROR, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETFINALPATHNAMEBYHANDLE($HFILE)
		LOCAL $TFNI = DLLSTRUCTCREATE("ulong;wchar[4096]")
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "struct*", $TFNI, "ulong", DLLSTRUCTGETSIZE($TFNI), "uint", 9)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		LOCAL $ILENGTH = DLLSTRUCTGETDATA($TFNI, 1)
		IF NOT $ILENGTH THEN RETURN SETERROR(12, 0, "")
		RETURN DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH / 2) & "]", DLLSTRUCTGETPTR($TFNI, 2)), 1)
	ENDFUNC
	FUNC _WINAPI_GETFINALPATHNAMEBYHANDLEEX($HFILE, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetFinalPathNameByHandleW", "handle", $HFILE, "wstr", "", "dword", 4096, "dword", $IFLAGS)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETFULLPATHNAME($SFILEPATH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetFullPathNameW", "wstr", $SFILEPATH, "dword", 4096, "wstr", "", "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_GETLOGICALDRIVES()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetLogicalDrives")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETOBJECTID($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TFOID = DLLSTRUCTCREATE("byte[16];byte[48]")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 589980, "ptr", 0, "dword", 0, "struct*", $TFOID, "dword", DLLSTRUCTGETSIZE($TFOID), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		_WINAPI_MOVEMEMORY($TGUID, $TFOID, 16)
		RETURN $TGUID
	ENDFUNC
	FUNC _WINAPI_GETOVERLAPPEDRESULT($HFILE, $TOVERLAPPED, BYREF $IBYTES, $BWAIT = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetOverlappedResult", "handle", $HFILE, "struct*", $TOVERLAPPED, "dword*", 0, "bool", $BWAIT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IBYTES = $ACALL[3]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETPETYPE($SFILEPATH)
		LOCAL $TDATA = DLLSTRUCTCREATE("ushort[2]")
		LOCAL $TUINT = DLLSTRUCTCREATE("uint", DLLSTRUCTGETPTR($TDATA))
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $IERROR = 0, $IVAL
		DO
			LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $TDATA, "dword", 2, "dword*", 0, "ptr", 0)
			IF @ERROR OR(NOT $ACALL[0]) OR($ACALL[4] <> 2) THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$IVAL = DLLSTRUCTGETDATA($TDATA, 1, 1)
			IF $IVAL <> 23117 THEN
				$IERROR = 3
				EXITLOOP
			ENDIF
			IF NOT _WINAPI_SETFILEPOINTEREX($HFILE, 60) THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $TDATA, "dword", 4, "dword*", 0, "ptr", 0)
			IF @ERROR OR(NOT $ACALL[0]) OR($ACALL[4] <> 4) THEN
				$IERROR = @ERROR + 50
				EXITLOOP
			ENDIF
			IF NOT _WINAPI_SETFILEPOINTEREX($HFILE, DLLSTRUCTGETDATA($TUINT, 1)) THEN
				$IERROR = @ERROR + 60
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $TDATA, "dword", 4, "dword*", 0, "ptr", 0)
			IF @ERROR OR(NOT $ACALL[0]) OR($ACALL[4] <> 4) THEN
				$IERROR = @ERROR + 70
				EXITLOOP
			ENDIF
			$IVAL = DLLSTRUCTGETDATA($TUINT, 1)
			IF $IVAL <> 17744 THEN
				$IERROR = 4
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $TDATA, "dword", 2, "dword*", 0, "ptr", 0)
			IF @ERROR OR(NOT $ACALL[0]) OR($ACALL[4] <> 2) THEN
				$IERROR = @ERROR + 80
				EXITLOOP
			ENDIF
			$IVAL = DLLSTRUCTGETDATA($TDATA, 1, 1)
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $IVAL
	ENDFUNC
	FUNC _WINAPI_GETPROFILESDIRECTORY()
		LOCAL $ACALL = DLLCALL("userenv.dll", "bool", "GetProfilesDirectoryW", "wstr", "", "dword*", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_GETTEMPFILENAME($SFILEPATH, $SPREFIX = "")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "uint", "GetTempFileNameW", "wstr", $SFILEPATH, "wstr", $SPREFIX, "uint", 0, "wstr", "")
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[4]
	ENDFUNC
	FUNC _WINAPI_GETVOLUMEINFORMATION($SROOT = "")
		IF NOT STRINGSTRIPWS($SROOT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SROOT = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetVolumeInformationW", "wstr", $SROOT, "wstr", "", "dword", 4096, "dword*", 0, "dword*", 0, "dword*", 0, "wstr", "", "dword", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[5]
		FOR $I = 0 TO 4
			SWITCH $I
				CASE 0
					$ARET[$I] = $ACALL[2]
				CASE ELSE
					$ARET[$I] = $ACALL[$I + 3]
			ENDSWITCH
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETVOLUMEINFORMATIONBYHANDLE($HFILE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetVolumeInformationByHandleW", "handle", $HFILE, "wstr", "", "dword", 4096, "dword*", 0, "dword*", 0, "dword*", 0, "wstr", "", "dword", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[5]
		FOR $I = 0 TO 4
			SWITCH $I
				CASE 0
					$ARET[$I] = $ACALL[2]
				CASE ELSE
					$ARET[$I] = $ACALL[$I + 3]
			ENDSWITCH
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETVOLUMENAMEFORVOLUMEMOUNTPOINT($SMOUNTEDPATH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetVolumeNameForVolumeMountPointW", "wstr", $SMOUNTEDPATH, "wstr", "", "dword", 80)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_IOCTL($IDEVICETYPE, $IFUNCTION, $IMETHOD, $IACCESS)
		RETURN BITOR(BITSHIFT($IDEVICETYPE, -16), BITSHIFT($IACCESS, -14), BITSHIFT($IFUNCTION, -2), $IMETHOD)
	ENDFUNC
	FUNC _WINAPI_ISDOOROPEN($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $TSPT = DLLSTRUCTCREATE("ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]" & (@AUTOITX64 ? ";byte[4]" : "") & ";byte Hdr[8]")
		LOCAL $TCDB = DLLSTRUCTCREATE("byte;byte;byte[6];byte[2];byte;byte;byte[4]", DLLSTRUCTGETPTR($TSPT, "Cdb"))
		LOCAL $THDR = DLLSTRUCTCREATE("byte;byte;byte[3];byte;byte[2]", DLLSTRUCTGETPTR($TSPT, "Hdr"))
		LOCAL $ISIZE = DLLSTRUCTGETPTR($TSPT, "Hdr") - DLLSTRUCTGETPTR($TSPT)
		DLLSTRUCTSETDATA($TSPT, "Length", $ISIZE)
		DLLSTRUCTSETDATA($TSPT, "ScsiStatus", 0)
		DLLSTRUCTSETDATA($TSPT, "PathId", 0)
		DLLSTRUCTSETDATA($TSPT, "TargetId", 0)
		DLLSTRUCTSETDATA($TSPT, "Lun", 0)
		DLLSTRUCTSETDATA($TSPT, "CdbLength", 12)
		DLLSTRUCTSETDATA($TSPT, "SenseInfoLength", 0)
		DLLSTRUCTSETDATA($TSPT, "DataIn", 1)
		DLLSTRUCTSETDATA($TSPT, "DataTransferLength", 8)
		DLLSTRUCTSETDATA($TSPT, "TimeOutValue", 86400)
		DLLSTRUCTSETDATA($TSPT, "DataBufferOffset", $ISIZE)
		DLLSTRUCTSETDATA($TSPT, "SenseInfoOffset", 0)
		DLLSTRUCTSETDATA($TCDB, 1, 189)
		DLLSTRUCTSETDATA($TCDB, 2, 0)
		DLLSTRUCTSETDATA($TCDB, 4, 0, 1)
		DLLSTRUCTSETDATA($TCDB, 4, 8, 2)
		DLLSTRUCTSETDATA($TCDB, 5, 0)
		DLLSTRUCTSETDATA($TCDB, 6, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 315396, "struct*", $TSPT, "dword", $ISIZE, "struct*", $TSPT, "dword", DLLSTRUCTGETSIZE($TSPT), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN(BITAND(DLLSTRUCTGETDATA($THDR, 2), 16) = 16)
	ENDFUNC
	FUNC _WINAPI_ISPATHSHARED($SFILEPATH)
		IF NOT __DLL("ntshrui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ACALL = DLLCALL("ntshrui.dll", "bool", "IsPathSharedW", "wstr", _WINAPI_PATHREMOVEBACKSLASH($SFILEPATH), "int", 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISWRITABLE($SDRIVE)
		DRIVEGETFILESYSTEM($SDRIVE)
		IF @ERROR THEN RETURN SETERROR(40 + @ERROR, _WINAPI_GETLASTERROR(), 0)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 458788, "ptr", 0, "dword", 0, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		LOCAL CONST $ERROR_WRITE_PROTECT = 19
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE, 1) <> 10 AND @EXTENDED = $ERROR_WRITE_PROTECT THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADMEDIA($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2967564, "ptr", 0, "dword", 0, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOCKDEVICE($SDRIVE, $BLOCK)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2967556, "boolean*", $BLOCK, "dword", 1, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOCKFILE($HFILE, $IOFFSET, $ILENGTH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "LockFile", "handle", $HFILE, "dword", _WINAPI_LODWORD($IOFFSET), "dword", _WINAPI_HIDWORD($IOFFSET), "dword", _WINAPI_LODWORD($ILENGTH), "dword", _WINAPI_HIDWORD($ILENGTH))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MAPVIEWOFFILE($HMAPPING, $IOFFSET = 0, $IBYTES = 0, $IACCESS = 6)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "ptr", "MapViewOfFile", "handle", $HMAPPING, "dword", $IACCESS, "dword", _WINAPI_HIDWORD($IOFFSET), "dword", _WINAPI_LODWORD($IOFFSET), "ulong_ptr", $IBYTES)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MOVEFILEEX($SEXISTINGFILE, $SNEWFILE, $IFLAGS = 0, $PPROGRESSPROC = 0, $PDATA = 0)
		IF NOT STRINGSTRIPWS($SNEWFILE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SNEWFILE = NULL
		IF BITAND($IFLAGS, $MOVE_FILE_DELAY_UNTIL_REBOOT) THEN
			IF $SNEWFILE = 0 THEN $SNEWFILE = NULL
		ENDIF
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "MoveFileWithProgressW", "wstr", $SEXISTINGFILE, "wstr", $SNEWFILE, "ptr", $PPROGRESSPROC, "ptr", $PDATA, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OPENFILEBYID($HFILE, $VID, $IACCESS = 0, $ISHARE = 0, $IFLAGS = 0)
		LOCAL $TFIDD = DLLSTRUCTCREATE("dword;uint;int64;int64")
		LOCAL $HOBJ, $ACALL, $ITYPE, $IERROR = 0
		SELECT
			CASE ISSTRING($VID)
				$ACALL = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $VID, "ptr", DLLSTRUCTGETPTR($TFIDD, 3))
				IF @ERROR OR $ACALL[0] THEN
					RETURN SETERROR(@ERROR + 30, 0, 0)
				ENDIF
				$ITYPE = 1
			CASE ISDLLSTRUCT($VID)
				IF NOT _WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($TFIDD, 3), DLLSTRUCTGETPTR($VID), 16) THEN
					RETURN SETERROR(@ERROR + 40, 0, 0)
				ENDIF
				$ITYPE = 1
			CASE ELSE
				DLLSTRUCTSETDATA($TFIDD, 3, $VID)
				$ITYPE = 0
		ENDSELECT
		DLLSTRUCTSETDATA($TFIDD, 1, DLLSTRUCTGETSIZE($TFIDD))
		DLLSTRUCTSETDATA($TFIDD, 2, $ITYPE)
		IF ISSTRING($HFILE) THEN
			$HOBJ = _WINAPI_CREATEFILEEX($HFILE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		ELSE
			$HOBJ = $HFILE
		ENDIF
		$ACALL = DLLCALL("kernel32.dll", "handle", "OpenFileById", "handle", $HOBJ, "struct*", $TFIDD, "dword", $IACCESS, "dword", $ISHARE, "ptr", 0, "dword", $IFLAGS)
		IF @ERROR OR($ACALL[0] = PTR(-1)) THEN $IERROR = @ERROR + 10
		IF ISSTRING($HFILE) THEN
			DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HOBJ)
		ENDIF
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OPENFILEMAPPING($SNAME, $IACCESS = 6, $BINHERIT = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "OpenFileMappingW", "dword", $IACCESS, "bool", $BINHERIT, "wstr", $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHISDIRECTORYEMPTY($SFILEPATH)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathIsDirectoryEmptyW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_QUERYDOSDEVICE($SDEVICE)
		IF NOT STRINGSTRIPWS($SDEVICE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SDEVICE = NULL
		LOCAL $TDATA = DLLSTRUCTCREATE("wchar[16384]")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "QueryDosDeviceW", "wstr", $SDEVICE, "struct*", $TDATA, "dword", 16384)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		LOCAL $ARET = _WINAPI_STRUCTTOARRAY($TDATA)
		IF ISSTRING($SDEVICE) THEN
			$ARET = $ARET[1]
		ENDIF
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_READDIRECTORYCHANGES($HDIRECTORY, $IFILTER, $PBUFFER, $ILENGTH, $BSUBTREE = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "ReadDirectoryChangesW", "handle", $HDIRECTORY, "struct*", $PBUFFER, "dword", $ILENGTH - MOD($ILENGTH, 4), "bool", $BSUBTREE, "dword", $IFILTER, "dword*", 0, "ptr", 0, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] OR(NOT $ACALL[6]) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		$PBUFFER = $ACALL[2]
		LOCAL $ADATA[101][2] = [[0]]
		LOCAL $TFNI, $IBUFFER = 0, $IOFFSET = 0
		DO
			$IBUFFER += $IOFFSET
			$TFNI = DLLSTRUCTCREATE("dword NextEntryOffset;dword Action;dword FileNameLength;wchar FileName[" & (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("dword FileNameLength", $PBUFFER + $IBUFFER + 8), 1) / 2) & "]", $PBUFFER + $IBUFFER)
			__INC($ADATA)
			$ADATA[$ADATA[0][0]][0] = DLLSTRUCTGETDATA($TFNI, "FileName")
			$ADATA[$ADATA[0][0]][1] = DLLSTRUCTGETDATA($TFNI, "Action")
			$IOFFSET = DLLSTRUCTGETDATA($TFNI, "NextEntryOffset")
		UNTIL NOT $IOFFSET
		__INC($ADATA, -1)
		RETURN $ADATA
	ENDFUNC
	FUNC _WINAPI_REMOVEDIRECTORY($SDIRPATH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "RemoveDirectoryW", "wstr", $SDIRPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REOPENFILE($HFILE, $IACCESS, $ISHARE, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "ReOpenFile", "handle", $HFILE, "dword", $IACCESS, "dword", $ISHARE, "dword", $IFLAGS)
		IF @ERROR OR($ACALL[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REPLACEFILE($SREPLACEDFILE, $SREPLACEMENTFILE, $SBACKUPFILE = "", $IFLAGS = 0)
		IF NOT STRINGSTRIPWS($SBACKUPFILE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SBACKUPFILE = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "ReplaceFileW", "wstr", $SREPLACEDFILE, "wstr", $SREPLACEMENTFILE, "wstr", $SBACKUPFILE, "dword", $IFLAGS, "ptr", 0, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SEARCHPATH($SFILEPATH, $SSEARCHPATH = "")
		IF NOT STRINGSTRIPWS($SSEARCHPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SSEARCHPATH = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "SearchPathW", "wstr", $SSEARCHPATH, "wstr", $SFILEPATH, "ptr", 0, "dword", 4096, "wstr", "", "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[5]
	ENDFUNC
	FUNC _WINAPI_SETCOMPRESSION($SFILEPATH, $ICOMPRESSION)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 639040, "ushort*", $ICOMPRESSION, "dword", 2, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETCURRENTDIRECTORY($SDIR)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "SetCurrentDirectoryW", "wstr", $SDIR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETENDOFFILE($HFILE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetEndOfFile", "handle", $HFILE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETFILEATTRIBUTES($SFILEPATH, $IATTRIBUTES)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "int", "SetFileAttributesW", "wstr", $SFILEPATH, "dword", $IATTRIBUTES)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETFILEINFORMATIONBYHANDLEEX($HFILE, $TFILEINFO)
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwSetInformationFile", "handle", $HFILE, "struct*", $TFILEINFO, "struct*", $TFILEINFO, "ulong", DLLSTRUCTGETSIZE($TFILEINFO), "uint", 4)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETFILEPOINTER($HFILE, $IPOS, $IMETHOD = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "INT", "SetFilePointer", "handle", $HFILE, "long", $IPOS, "ptr", 0, "long", $IMETHOD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETFILEPOINTEREX($HFILE, $IPOS, $IMETHOD = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetFilePointerEx", "handle", $HFILE, "int64", $IPOS, "int64*", 0, "dword", $IMETHOD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETFILESHORTNAME($HFILE, $SSHORTNAME)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetFileShortNameW", "handle", $HFILE, "wstr", $SSHORTNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETFILEVALIDDATA($HFILE, $ILENGTH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetFileValidData", "handle", $HFILE, "int64", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETSEARCHPATHMODE($IFLAGS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetSearchPathMode", "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETVOLUMEMOUNTPOINT($SFILEPATH, $SGUID)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetVolumeMountPointW", "wstr", $SFILEPATH, "wstr", $SGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SFCISFILEPROTECTED($SFILEPATH)
		IF NOT __DLL("sfc.dll") THEN RETURN SETERROR(103, 0, FALSE)
		LOCAL $ACALL = DLLCALL("sfc.dll", "bool", "SfcIsFileProtected", "handle", 0, "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNLOCKFILE($HFILE, $IOFFSET, $ILENGTH)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "UnlockFile", "handle", $HFILE, "dword", _WINAPI_LODWORD($IOFFSET), "dword", _WINAPI_HIDWORD($IOFFSET), "dword", _WINAPI_LODWORD($ILENGTH), "dword", _WINAPI_HIDWORD($ILENGTH))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNMAPVIEWOFFILE($PADDRESS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "UnmapViewOfFile", "ptr", $PADDRESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WOW64ENABLEWOW64FSREDIRECTION($BENABLE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "boolean", "Wow64EnableWow64FsRedirection", "boolean", $BENABLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __WINAPI_MAKEQWORD($ILODWORD, $IHIDWORD)
		LOCAL $TINT64 = DLLSTRUCTCREATE("uint64")
		LOCAL $TDWORDS = DLLSTRUCTCREATE("dword;dword", DLLSTRUCTGETPTR($TINT64))
		DLLSTRUCTSETDATA($TDWORDS, 1, $ILODWORD)
		DLLSTRUCTSETDATA($TDWORDS, 2, $IHIDWORD)
		RETURN DLLSTRUCTGETDATA($TINT64, 1)
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $FR_PRIVATE = 16
GLOBAL CONST $FR_NOT_ENUM = 32
GLOBAL CONST $COMPRESSION_BITMAP_PNG = 0
GLOBAL CONST $COMPRESSION_BITMAP_JPEG = 1
GLOBAL CONST $BS_DIBPATTERN = 5
GLOBAL CONST $BS_DIBPATTERN8X8 = 8
GLOBAL CONST $BS_DIBPATTERNPT = 6
GLOBAL CONST $BS_HATCHED = 2
GLOBAL CONST $BS_HOLLOW = 1
GLOBAL CONST $BS_NULL = 1
GLOBAL CONST $BS_PATTERN = 3
GLOBAL CONST $BS_PATTERN8X8 = 7
GLOBAL CONST $BS_SOLID = 0
GLOBAL CONST $HS_BDIAGONAL = 3
GLOBAL CONST $HS_CROSS = 4
GLOBAL CONST $HS_DIAGCROSS = 5
GLOBAL CONST $HS_FDIAGONAL = 2
GLOBAL CONST $HS_HORIZONTAL = 0
GLOBAL CONST $HS_VERTICAL = 1
GLOBAL CONST $DIB_PAL_COLORS = 1
GLOBAL CONST $DIB_RGB_COLORS = 0
GLOBAL CONST $CA_NEGATIVE = 1
GLOBAL CONST $CA_LOG_FILTER = 2
GLOBAL CONST $ILLUMINANT_DEVICE_DEFAULT = 0
GLOBAL CONST $ILLUMINANT_A = 1
GLOBAL CONST $ILLUMINANT_B = 2
GLOBAL CONST $ILLUMINANT_C = 3
GLOBAL CONST $ILLUMINANT_D50 = 4
GLOBAL CONST $ILLUMINANT_D55 = 5
GLOBAL CONST $ILLUMINANT_D65 = 6
GLOBAL CONST $ILLUMINANT_D75 = 7
GLOBAL CONST $ILLUMINANT_F2 = 8
GLOBAL CONST $ILLUMINANT_TUNGSTEN = $ILLUMINANT_A
GLOBAL CONST $ILLUMINANT_DAYLIGHT = $ILLUMINANT_C
GLOBAL CONST $ILLUMINANT_FLUORESCENT = $ILLUMINANT_F2
GLOBAL CONST $ILLUMINANT_NTSC = $ILLUMINANT_C
GLOBAL CONST $BI_RGB = 0
GLOBAL CONST $BI_RLE8 = 1
GLOBAL CONST $BI_RLE4 = 2
GLOBAL CONST $BI_BITFIELDS = 3
GLOBAL CONST $BI_JPEG = 4
GLOBAL CONST $BI_PNG = 5
GLOBAL CONST $ALTERNATE = 1
GLOBAL CONST $WINDING = 2
GLOBAL CONST $DWMWA_NCRENDERING_ENABLED = 1
GLOBAL CONST $DWMWA_NCRENDERING_POLICY = 2
GLOBAL CONST $DWMWA_TRANSITIONS_FORCEDISABLED = 3
GLOBAL CONST $DWMWA_ALLOW_NCPAINT = 4
GLOBAL CONST $DWMWA_CAPTION_BUTTON_BOUNDS = 5
GLOBAL CONST $DWMWA_NONCLIENT_RTL_LAYOUT = 6
GLOBAL CONST $DWMWA_FORCE_ICONIC_REPRESENTATION = 7
GLOBAL CONST $DWMWA_FLIP3D_POLICY = 8
GLOBAL CONST $DWMWA_EXTENDED_FRAME_BOUNDS = 9
GLOBAL CONST $DWMWA_HAS_ICONIC_BITMAP = 10
GLOBAL CONST $DWMWA_DISALLOW_PEEK = 11
GLOBAL CONST $DWMWA_EXCLUDED_FROM_PEEK = 12
GLOBAL CONST $DWMNCRP_USEWINDOWSTYLE = 0
GLOBAL CONST $DWMNCRP_DISABLED = 1
GLOBAL CONST $DWMNCRP_ENABLED = 2
GLOBAL CONST $DWMFLIP3D_DEFAULT = 0
GLOBAL CONST $DWMFLIP3D_EXCLUDEBELOW = 1
GLOBAL CONST $DWMFLIP3D_EXCLUDEABOVE = 2
GLOBAL CONST $DM_BITSPERPEL = 262144
GLOBAL CONST $DM_COLLATE = 32768
GLOBAL CONST $DM_COLOR = 2048
GLOBAL CONST $DM_COPIES = 256
GLOBAL CONST $DM_DEFAULTSOURCE = 512
GLOBAL CONST $DM_DISPLAYFIXEDOUTPUT = 536870912
GLOBAL CONST $DM_DISPLAYFLAGS = 2097152
GLOBAL CONST $DM_DISPLAYFREQUENCY = 4194304
GLOBAL CONST $DM_DISPLAYORIENTATION = 128
GLOBAL CONST $DM_DITHERTYPE = 67108864
GLOBAL CONST $DM_DUPLEX = 4096
GLOBAL CONST $DM_FORMNAME = 65536
GLOBAL CONST $DM_ICMINTENT = 16777216
GLOBAL CONST $DM_ICMMETHOD = 8388608
GLOBAL CONST $DM_LOGPIXELS = 131072
GLOBAL CONST $DM_MEDIATYPE = 33554432
GLOBAL CONST $DM_NUP = 64
GLOBAL CONST $DM_ORIENTATION = 1
GLOBAL CONST $DM_PANNINGHEIGHT = 268435456
GLOBAL CONST $DM_PANNINGWIDTH = 134217728
GLOBAL CONST $DM_PAPERLENGTH = 4
GLOBAL CONST $DM_PAPERSIZE = 2
GLOBAL CONST $DM_PAPERWIDTH = 8
GLOBAL CONST $DM_PELSHEIGHT = 1048576
GLOBAL CONST $DM_PELSWIDTH = 524288
GLOBAL CONST $DM_POSITION = 32
GLOBAL CONST $DM_PRINTQUALITY = 1024
GLOBAL CONST $DM_SCALE = 16
GLOBAL CONST $DM_TTOPTION = 16384
GLOBAL CONST $DM_YRESOLUTION = 8192
GLOBAL CONST $DMPAPER_LETTER = 1
GLOBAL CONST $DMPAPER_LETTERSMALL = 2
GLOBAL CONST $DMPAPER_TABLOID = 3
GLOBAL CONST $DMPAPER_LEDGER = 4
GLOBAL CONST $DMPAPER_LEGAL = 5
GLOBAL CONST $DMPAPER_STATEMENT = 6
GLOBAL CONST $DMPAPER_EXECUTIVE = 7
GLOBAL CONST $DMPAPER_A3 = 8
GLOBAL CONST $DMPAPER_A4 = 9
GLOBAL CONST $DMPAPER_A4SMALL = 10
GLOBAL CONST $DMPAPER_A5 = 11
GLOBAL CONST $DMPAPER_B4 = 12
GLOBAL CONST $DMPAPER_B5 = 13
GLOBAL CONST $DMPAPER_FOLIO = 14
GLOBAL CONST $DMPAPER_QUARTO = 15
GLOBAL CONST $DMPAPER_10X14 = 16
GLOBAL CONST $DMPAPER_11X17 = 17
GLOBAL CONST $DMPAPER_NOTE = 18
GLOBAL CONST $DMPAPER_ENV_9 = 19
GLOBAL CONST $DMPAPER_ENV_10 = 20
GLOBAL CONST $DMPAPER_ENV_11 = 21
GLOBAL CONST $DMPAPER_ENV_12 = 22
GLOBAL CONST $DMPAPER_ENV_14 = 23
GLOBAL CONST $DMPAPER_CSHEET = 24
GLOBAL CONST $DMPAPER_DSHEET = 25
GLOBAL CONST $DMPAPER_ESHEET = 26
GLOBAL CONST $DMPAPER_ENV_DL = 27
GLOBAL CONST $DMPAPER_ENV_C5 = 28
GLOBAL CONST $DMPAPER_ENV_C3 = 29
GLOBAL CONST $DMPAPER_ENV_C4 = 30
GLOBAL CONST $DMPAPER_ENV_C6 = 31
GLOBAL CONST $DMPAPER_ENV_C65 = 32
GLOBAL CONST $DMPAPER_ENV_B4 = 33
GLOBAL CONST $DMPAPER_ENV_B5 = 34
GLOBAL CONST $DMPAPER_ENV_B6 = 35
GLOBAL CONST $DMPAPER_ENV_ITALY = 36
GLOBAL CONST $DMPAPER_ENV_MONARCH = 37
GLOBAL CONST $DMPAPER_ENV_PERSONAL = 38
GLOBAL CONST $DMPAPER_FANFOLD_US = 39
GLOBAL CONST $DMPAPER_FANFOLD_STD_GERMAN = 40
GLOBAL CONST $DMPAPER_FANFOLD_LGL_GERMAN = 41
GLOBAL CONST $DMPAPER_ISO_B4 = 42
GLOBAL CONST $DMPAPER_JAPANESE_POSTCARD = 43
GLOBAL CONST $DMPAPER_9X11 = 44
GLOBAL CONST $DMPAPER_10X11 = 45
GLOBAL CONST $DMPAPER_15X11 = 46
GLOBAL CONST $DMPAPER_ENV_INVITE = 47
GLOBAL CONST $DMPAPER_RESERVED_48 = 48
GLOBAL CONST $DMPAPER_RESERVED_49 = 49
GLOBAL CONST $DMPAPER_LETTER_EXTRA = 50
GLOBAL CONST $DMPAPER_LEGAL_EXTRA = 51
GLOBAL CONST $DMPAPER_TABLOID_EXTRA = 52
GLOBAL CONST $DMPAPER_A4_EXTRA = 53
GLOBAL CONST $DMPAPER_LETTER_TRANSVERSE = 54
GLOBAL CONST $DMPAPER_A4_TRANSVERSE = 55
GLOBAL CONST $DMPAPER_LETTER_EXTRA_TRANSVERSE = 56
GLOBAL CONST $DMPAPER_A_PLUS = 57
GLOBAL CONST $DMPAPER_B_PLUS = 58
GLOBAL CONST $DMPAPER_LETTER_PLUS = 59
GLOBAL CONST $DMPAPER_A4_PLUS = 60
GLOBAL CONST $DMPAPER_A5_TRANSVERSE = 61
GLOBAL CONST $DMPAPER_B5_TRANSVERSE = 62
GLOBAL CONST $DMPAPER_A3_EXTRA = 63
GLOBAL CONST $DMPAPER_A5_EXTRA = 64
GLOBAL CONST $DMPAPER_B5_EXTRA = 65
GLOBAL CONST $DMPAPER_A2 = 66
GLOBAL CONST $DMPAPER_A3_TRANSVERSE = 67
GLOBAL CONST $DMPAPER_A3_EXTRA_TRANSVERSE = 68
GLOBAL CONST $DMPAPER_DBL_JAPANESE_POSTCARD = 69
GLOBAL CONST $DMPAPER_A6 = 70
GLOBAL CONST $DMPAPER_JENV_KAKU2 = 71
GLOBAL CONST $DMPAPER_JENV_KAKU3 = 72
GLOBAL CONST $DMPAPER_JENV_CHOU3 = 73
GLOBAL CONST $DMPAPER_JENV_CHOU4 = 74
GLOBAL CONST $DMPAPER_LETTER_ROTATED = 75
GLOBAL CONST $DMPAPER_A3_ROTATED = 76
GLOBAL CONST $DMPAPER_A4_ROTATED = 77
GLOBAL CONST $DMPAPER_A5_ROTATED = 78
GLOBAL CONST $DMPAPER_B4_JIS_ROTATED = 79
GLOBAL CONST $DMPAPER_B5_JIS_ROTATED = 80
GLOBAL CONST $DMPAPER_JAPANESE_POSTCARD_ROTATED = 81
GLOBAL CONST $DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82
GLOBAL CONST $DMPAPER_A6_ROTATED = 83
GLOBAL CONST $DMPAPER_JENV_KAKU2_ROTATED = 84
GLOBAL CONST $DMPAPER_JENV_KAKU3_ROTATED = 85
GLOBAL CONST $DMPAPER_JENV_CHOU3_ROTATED = 86
GLOBAL CONST $DMPAPER_JENV_CHOU4_ROTATED = 87
GLOBAL CONST $DMPAPER_B6_JIS = 88
GLOBAL CONST $DMPAPER_B6_JIS_ROTATED = 89
GLOBAL CONST $DMPAPER_12X11 = 90
GLOBAL CONST $DMPAPER_JENV_YOU4 = 91
GLOBAL CONST $DMPAPER_JENV_YOU4_ROTATED = 92
GLOBAL CONST $DMPAPER_P16K = 93
GLOBAL CONST $DMPAPER_P32K = 94
GLOBAL CONST $DMPAPER_P32KBIG = 95
GLOBAL CONST $DMPAPER_PENV_1 = 96
GLOBAL CONST $DMPAPER_PENV_2 = 97
GLOBAL CONST $DMPAPER_PENV_3 = 98
GLOBAL CONST $DMPAPER_PENV_4 = 99
GLOBAL CONST $DMPAPER_PENV_5 = 100
GLOBAL CONST $DMPAPER_PENV_6 = 101
GLOBAL CONST $DMPAPER_PENV_7 = 102
GLOBAL CONST $DMPAPER_PENV_8 = 103
GLOBAL CONST $DMPAPER_PENV_9 = 104
GLOBAL CONST $DMPAPER_PENV_10 = 105
GLOBAL CONST $DMPAPER_P16K_ROTATED = 106
GLOBAL CONST $DMPAPER_P32K_ROTATED = 107
GLOBAL CONST $DMPAPER_P32KBIG_ROTATED = 108
GLOBAL CONST $DMPAPER_PENV_1_ROTATED = 109
GLOBAL CONST $DMPAPER_PENV_2_ROTATED = 110
GLOBAL CONST $DMPAPER_PENV_3_ROTATED = 111
GLOBAL CONST $DMPAPER_PENV_4_ROTATED = 112
GLOBAL CONST $DMPAPER_PENV_5_ROTATED = 113
GLOBAL CONST $DMPAPER_PENV_6_ROTATED = 114
GLOBAL CONST $DMPAPER_PENV_7_ROTATED = 115
GLOBAL CONST $DMPAPER_PENV_8_ROTATED = 116
GLOBAL CONST $DMPAPER_PENV_9_ROTATED = 117
GLOBAL CONST $DMPAPER_PENV_10_ROTATED = 118
GLOBAL CONST $DMPAPER_USER = 256
GLOBAL CONST $DMBIN_UPPER = 1
GLOBAL CONST $DMBIN_LOWER = 2
GLOBAL CONST $DMBIN_MIDDLE = 3
GLOBAL CONST $DMBIN_MANUAL = 4
GLOBAL CONST $DMBIN_ENVELOPE = 5
GLOBAL CONST $DMBIN_ENVMANUAL = 6
GLOBAL CONST $DMBIN_AUTO = 7
GLOBAL CONST $DMBIN_TRACTOR = 8
GLOBAL CONST $DMBIN_SMALLFMT = 9
GLOBAL CONST $DMBIN_LARGEFMT = 10
GLOBAL CONST $DMBIN_LARGECAPACITY = 11
GLOBAL CONST $DMBIN_CASSETTE = 14
GLOBAL CONST $DMBIN_FORMSOURCE = 15
GLOBAL CONST $DMBIN_USER = 256
GLOBAL CONST $DMRES_DRAFT = -1
GLOBAL CONST $DMRES_LOW = -2
GLOBAL CONST $DMRES_MEDIUM = -3
GLOBAL CONST $DMRES_HIGH = -4
GLOBAL CONST $DMDO_DEFAULT = 0
GLOBAL CONST $DMDO_90 = 1
GLOBAL CONST $DMDO_180 = 2
GLOBAL CONST $DMDO_270 = 3
GLOBAL CONST $DMDFO_DEFAULT = 0
GLOBAL CONST $DMDFO_STRETCH = 1
GLOBAL CONST $DMDFO_CENTER = 2
GLOBAL CONST $DMCOLOR_MONOCHROME = 1
GLOBAL CONST $DMCOLOR_COLOR = 2
GLOBAL CONST $DMDUP_SIMPLEX = 1
GLOBAL CONST $DMDUP_VERTICAL = 2
GLOBAL CONST $DMDUP_HORIZONTAL = 3
GLOBAL CONST $DMTT_BITMAP = 1
GLOBAL CONST $DMTT_DOWNLOAD = 2
GLOBAL CONST $DMTT_SUBDEV = 3
GLOBAL CONST $DMTT_DOWNLOAD_OUTLINE = 4
GLOBAL CONST $DMCOLLATE_FALSE = 0
GLOBAL CONST $DMCOLLATE_TRUE = 1
GLOBAL CONST $DM_GRAYSCALE = 1
GLOBAL CONST $DM_INTERLACED = 2
GLOBAL CONST $DMNUP_SYSTEM = 1
GLOBAL CONST $DMNUP_ONEUP = 2
GLOBAL CONST $DMICMMETHOD_NONE = 1
GLOBAL CONST $DMICMMETHOD_SYSTEM = 2
GLOBAL CONST $DMICMMETHOD_DRIVER = 3
GLOBAL CONST $DMICMMETHOD_DEVICE = 4
GLOBAL CONST $DMICMMETHOD_USER = 256
GLOBAL CONST $DMICM_SATURATE = 1
GLOBAL CONST $DMICM_CONTRAST = 2
GLOBAL CONST $DMICM_COLORIMETRIC = 3
GLOBAL CONST $DMICM_ABS_COLORIMETRIC = 4
GLOBAL CONST $DMICM_USER = 256
GLOBAL CONST $DMMEDIA_STANDARD = 1
GLOBAL CONST $DMMEDIA_TRANSPARENCY = 2
GLOBAL CONST $DMMEDIA_GLOSSY = 3
GLOBAL CONST $DMMEDIA_USER = 256
GLOBAL CONST $DMDITHER_NONE = 1
GLOBAL CONST $DMDITHER_COARSE = 2
GLOBAL CONST $DMDITHER_FINE = 3
GLOBAL CONST $DMDITHER_LINEART = 4
GLOBAL CONST $DMDITHER_ERRORDIFFUSION = 5
GLOBAL CONST $DMDITHER_RESERVED6 = 6
GLOBAL CONST $DMDITHER_RESERVED7 = 7
GLOBAL CONST $DMDITHER_RESERVED8 = 8
GLOBAL CONST $DMDITHER_RESERVED9 = 9
GLOBAL CONST $DMDITHER_GRAYSCALE = 10
GLOBAL CONST $DMDITHER_USER = 256
GLOBAL CONST $ENUM_CURRENT_SETTINGS = -1
GLOBAL CONST $ENUM_REGISTRY_SETTINGS = -2
GLOBAL CONST $DEVICE_FONTTYPE = 2
GLOBAL CONST $RASTER_FONTTYPE = 1
GLOBAL CONST $TRUETYPE_FONTTYPE = 4
GLOBAL CONST $NTM_BOLD = 32
GLOBAL CONST $NTM_DSIG = 2097152
GLOBAL CONST $NTM_ITALIC = 1
GLOBAL CONST $NTM_MULTIPLEMASTER = 524288
GLOBAL CONST $NTM_NONNEGATIVE_AC = 65536
GLOBAL CONST $NTM_PS_OPENTYPE = 131072
GLOBAL CONST $NTM_REGULAR = 64
GLOBAL CONST $NTM_TT_OPENTYPE = 262144
GLOBAL CONST $NTM_TYPE1 = 1048576
GLOBAL CONST $FLOODFILLBORDER = 0
GLOBAL CONST $FLOODFILLSURFACE = 1
GLOBAL CONST $AD_COUNTERCLOCKWISE = 1
GLOBAL CONST $AD_CLOCKWISE = 2
GLOBAL CONST $DCB_ACCUMULATE = 2
GLOBAL CONST $DCB_DISABLE = 8
GLOBAL CONST $DCB_ENABLE = 4
GLOBAL CONST $DCB_RESET = 1
GLOBAL CONST $DCB_SET = BITOR($DCB_RESET, $DCB_ACCUMULATE)
GLOBAL CONST $DCX_WINDOW = 1
GLOBAL CONST $DCX_CACHE = 2
GLOBAL CONST $DCX_PARENTCLIP = 32
GLOBAL CONST $DCX_CLIPSIBLINGS = 16
GLOBAL CONST $DCX_CLIPCHILDREN = 8
GLOBAL CONST $DCX_NORESETATTRS = 4
GLOBAL CONST $DCX_LOCKWINDOWUPDATE = 1024
GLOBAL CONST $DCX_EXCLUDERGN = 64
GLOBAL CONST $DCX_INTERSECTRGN = 128
GLOBAL CONST $DCX_INTERSECTUPDATE = 512
GLOBAL CONST $DCX_VALIDATE = 2097152
GLOBAL CONST $GGO_BEZIER = 3
GLOBAL CONST $GGO_BITMAP = 1
GLOBAL CONST $GGO_GLYPH_INDEX = 128
GLOBAL CONST $GGO_GRAY2_BITMAP = 4
GLOBAL CONST $GGO_GRAY4_BITMAP = 5
GLOBAL CONST $GGO_GRAY8_BITMAP = 6
GLOBAL CONST $GGO_METRICS = 0
GLOBAL CONST $GGO_NATIVE = 2
GLOBAL CONST $GGO_UNHINTED = 256
GLOBAL CONST $GM_COMPATIBLE = 1
GLOBAL CONST $GM_ADVANCED = 2
GLOBAL CONST $MM_ANISOTROPIC = 8
GLOBAL CONST $MM_HIENGLISH = 5
GLOBAL CONST $MM_HIMETRIC = 3
GLOBAL CONST $MM_ISOTROPIC = 7
GLOBAL CONST $MM_LOENGLISH = 4
GLOBAL CONST $MM_LOMETRIC = 2
GLOBAL CONST $MM_TEXT = 1
GLOBAL CONST $MM_TWIPS = 6
GLOBAL CONST $R2_BLACK = 1
GLOBAL CONST $R2_COPYPEN = 13
GLOBAL CONST $R2_LAST = 16
GLOBAL CONST $R2_MASKNOTPEN = 3
GLOBAL CONST $R2_MASKPEN = 9
GLOBAL CONST $R2_MASKPENNOT = 5
GLOBAL CONST $R2_MERGENOTPEN = 12
GLOBAL CONST $R2_MERGEPEN = 15
GLOBAL CONST $R2_MERGEPENNOT = 14
GLOBAL CONST $R2_NOP = 11
GLOBAL CONST $R2_NOT = 6
GLOBAL CONST $R2_NOTCOPYPEN = 4
GLOBAL CONST $R2_NOTMASKPEN = 8
GLOBAL CONST $R2_NOTMERGEPEN = 2
GLOBAL CONST $R2_NOTXORPEN = 10
GLOBAL CONST $R2_WHITE = 16
GLOBAL CONST $R2_XORPEN = 7
GLOBAL CONST $BLACKONWHITE = 1
GLOBAL CONST $COLORONCOLOR = 3
GLOBAL CONST $HALFTONE = 4
GLOBAL CONST $WHITEONBLACK = 2
GLOBAL CONST $STRETCH_ANDSCANS = $BLACKONWHITE
GLOBAL CONST $STRETCH_DELETESCANS = $COLORONCOLOR
GLOBAL CONST $STRETCH_HALFTONE = $HALFTONE
GLOBAL CONST $STRETCH_ORSCANS = $WHITEONBLACK
GLOBAL CONST $TA_BASELINE = 24
GLOBAL CONST $TA_BOTTOM = 8
GLOBAL CONST $TA_TOP = 0
GLOBAL CONST $TA_CENTER = 6
GLOBAL CONST $TA_LEFT = 0
GLOBAL CONST $TA_RIGHT = 2
GLOBAL CONST $TA_NOUPDATECP = 0
GLOBAL CONST $TA_RTLREADING = 256
GLOBAL CONST $TA_UPDATECP = 1
GLOBAL CONST $VTA_BASELINE = $TA_BASELINE
GLOBAL CONST $VTA_BOTTOM = $TA_RIGHT
GLOBAL CONST $VTA_TOP = $TA_LEFT
GLOBAL CONST $VTA_CENTER = $TA_CENTER
GLOBAL CONST $VTA_LEFT = $TA_BOTTOM
GLOBAL CONST $VTA_RIGHT = $TA_TOP
GLOBAL CONST $UDF_BGR = 1
GLOBAL CONST $UDF_RGB = 0
GLOBAL CONST $MWT_IDENTITY = 1
GLOBAL CONST $MWT_LEFTMULTIPLY = 2
GLOBAL CONST $MWT_RIGHTMULTIPLY = 3
GLOBAL CONST $MWT_SET = 4
GLOBAL CONST $MONITOR_DEFAULTTONEAREST = 2
GLOBAL CONST $MONITOR_DEFAULTTONULL = 0
GLOBAL CONST $MONITOR_DEFAULTTOPRIMARY = 1
GLOBAL CONST $PT_BEZIERTO = 4
GLOBAL CONST $PT_LINETO = 2
GLOBAL CONST $PT_MOVETO = 6
GLOBAL CONST $PT_CLOSEFIGURE = 1
#Region Global Variables and Constants
	GLOBAL CONST $DUPLICATE_CLOSE_SOURCE = 1
	GLOBAL CONST $DUPLICATE_SAME_ACCESS = 2
	GLOBAL CONST $OBJ_BITMAP = 7
	GLOBAL CONST $OBJ_BRUSH = 2
	GLOBAL CONST $OBJ_COLORSPACE = 14
	GLOBAL CONST $OBJ_DC = 3
	GLOBAL CONST $OBJ_ENHMETADC = 12
	GLOBAL CONST $OBJ_ENHMETAFILE = 13
	GLOBAL CONST $OBJ_EXTPEN = 11
	GLOBAL CONST $OBJ_FONT = 6
	GLOBAL CONST $OBJ_MEMDC = 10
	GLOBAL CONST $OBJ_METADC = 4
	GLOBAL CONST $OBJ_METAFILE = 9
	GLOBAL CONST $OBJ_PAL = 5
	GLOBAL CONST $OBJ_PEN = 1
	GLOBAL CONST $OBJ_REGION = 8
	GLOBAL CONST $NULL_BRUSH = 5
	GLOBAL CONST $NULL_PEN = 8
	GLOBAL CONST $BLACK_BRUSH = 4
	GLOBAL CONST $DKGRAY_BRUSH = 3
	GLOBAL CONST $DC_BRUSH = 18
	GLOBAL CONST $GRAY_BRUSH = 2
	GLOBAL CONST $HOLLOW_BRUSH = $NULL_BRUSH
	GLOBAL CONST $LTGRAY_BRUSH = 1
	GLOBAL CONST $WHITE_BRUSH = 0
	GLOBAL CONST $BLACK_PEN = 7
	GLOBAL CONST $DC_PEN = 19
	GLOBAL CONST $WHITE_PEN = 6
	GLOBAL CONST $ANSI_FIXED_FONT = 11
	GLOBAL CONST $ANSI_VAR_FONT = 12
	GLOBAL CONST $DEVICE_DEFAULT_FONT = 14
	GLOBAL CONST $DEFAULT_GUI_FONT = 17
	GLOBAL CONST $OEM_FIXED_FONT = 10
	GLOBAL CONST $SYSTEM_FONT = 13
	GLOBAL CONST $SYSTEM_FIXED_FONT = 16
	GLOBAL CONST $DEFAULT_PALETTE = 15
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CLOSEHANDLE($HOBJECT)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HOBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DELETEOBJECT($HOBJECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "DeleteObject", "handle", $HOBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DUPLICATEHANDLE($HSOURCEPROCESSHANDLE, $HSOURCEHANDLE, $HTARGETPROCESSHANDLE, $IDESIREDACCESS, $IINHERITHANDLE, $IOPTIONS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "DuplicateHandle", "handle", $HSOURCEPROCESSHANDLE, "handle", $HSOURCEHANDLE, "handle", $HTARGETPROCESSHANDLE, "handle*", 0, "dword", $IDESIREDACCESS, "bool", $IINHERITHANDLE, "dword", $IOPTIONS)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[4]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTOBJECT($HDC, $ITYPE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "GetCurrentObject", "handle", $HDC, "uint", $ITYPE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTPROCESS()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "GetCurrentProcess")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETOBJECT($HOBJECT, $ISIZE, $POBJECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetObjectW", "handle", $HOBJECT, "int", $ISIZE, "struct*", $POBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETOBJECTINFOBYHANDLE($HOBJECT)
		LOCAL $TAGPUBLIC_OBJECT_BASIC_INFORMATION = "ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]"
		LOCAL $TPOBI = DLLSTRUCTCREATE($TAGPUBLIC_OBJECT_BASIC_INFORMATION)
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQueryObject", "handle", $HOBJECT, "uint", 0, "struct*", $TPOBI, "ulong", DLLSTRUCTGETSIZE($TPOBI), "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		LOCAL $ARET[4]
		FOR $I = 0 TO 3
			$ARET[$I] = DLLSTRUCTGETDATA($TPOBI, $I + 1)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETOBJECTNAMEBYHANDLE($HOBJECT)
		LOCAL $TAGUNICODE_STRING = "struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct"
		LOCAL $TAGPUBLIC_OBJECT_TYPE_INFORMATION = "struct;" & $TAGUNICODE_STRING & ";ulong Reserved[22];endstruct"
		LOCAL $TPOTI = DLLSTRUCTCREATE($TAGPUBLIC_OBJECT_TYPE_INFORMATION & ";byte[32]")
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQueryObject", "handle", $HOBJECT, "uint", 2, "struct*", $TPOTI, "ulong", DLLSTRUCTGETSIZE($TPOTI), "ulong*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		LOCAL $PDATA = DLLSTRUCTGETDATA($TPOTI, 3)
		IF NOT $PDATA THEN RETURN SETERROR(11, 0, "")
		RETURN _WINAPI_GETSTRING($PDATA)
	ENDFUNC
	FUNC _WINAPI_GETOBJECTTYPE($HOBJECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "dword", "GetObjectType", "handle", $HOBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETSTDHANDLE($ISTDHANDLE)
		IF $ISTDHANDLE < 0 OR $ISTDHANDLE > 2 THEN RETURN SETERROR(2, 0, -1)
		LOCAL CONST $AHANDLE[3] = [-10, -11, -12]
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "GetStdHandle", "dword", $AHANDLE[$ISTDHANDLE])
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETSTOCKOBJECT($IOBJECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "GetStockObject", "int", $IOBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SELECTOBJECT($HDC, $HGDIOBJ)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDC, "handle", $HGDIOBJ)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETHANDLEINFORMATION($HOBJECT, $IMASK, $IFLAGS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetHandleInformation", "handle", $HOBJECT, "dword", $IMASK, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
	GLOBAL CONST $TAGBITMAP = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
	GLOBAL CONST $TAGBITMAPV5HEADER = "struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct"
	GLOBAL CONST $TAGDIBSECTION = $TAGBITMAP & ";" & $TAGBITMAPINFOHEADER & ";dword dsBitfields[3];ptr dshSection;dword dsOffset"
	GLOBAL CONST $TMPF_FIXED_PITCH = 1
	GLOBAL CONST $TMPF_VECTOR = 2
	GLOBAL CONST $TMPF_TRUETYPE = 4
	GLOBAL CONST $TMPF_DEVICE = 8
	GLOBAL CONST $__WINAPICONSTANT_FW_NORMAL = 400
	GLOBAL CONST $__WINAPICONSTANT_DEFAULT_CHARSET = 1
	GLOBAL CONST $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
	GLOBAL CONST $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
	GLOBAL CONST $__WINAPICONSTANT_DEFAULT_QUALITY = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BITBLT($HDESTDC, $IXDEST, $IYDEST, $IWIDTH, $IHEIGHT, $HSRCDC, $IXSRC, $IYSRC, $IROP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "BitBlt", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTH, "int", $IHEIGHT, "handle", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "dword", $IROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COMBINERGN($HRGNDEST, $HRGNSRC1, $HRGNSRC2, $ICOMBINEMODE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "CombineRgn", "handle", $HRGNDEST, "handle", $HRGNSRC1, "handle", $HRGNSRC2, "int", $ICOMBINEMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COPYBITMAP($HBITMAP)
		$HBITMAP = _WINAPI_COPYIMAGE($HBITMAP, 0, 0, 0, 8192)
		RETURN SETERROR(@ERROR, @EXTENDED, $HBITMAP)
	ENDFUNC
	FUNC _WINAPI_COPYIMAGE($HIMAGE, $ITYPE = 0, $IXDESIREDPIXELS = 0, $IYDESIREDPIXELS = 0, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "CopyImage", "handle", $HIMAGE, "uint", $ITYPE, "int", $IXDESIREDPIXELS, "int", $IYDESIREDPIXELS, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEANDBITMAP($HBITMAP)
		LOCAL $IERROR = 0, $HDIB = 0
		$HBITMAP = _WINAPI_COPYBITMAP($HBITMAP)
		IF NOT $HBITMAP THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		DO
			LOCAL $ATDIB[2]
			$ATDIB[0] = DLLSTRUCTCREATE($TAGDIBSECTION)
			IF(NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($ATDIB[0]), $ATDIB[0])) OR(DLLSTRUCTGETDATA($ATDIB[0], "bmBitsPixel") <> 32) OR(DLLSTRUCTGETDATA($ATDIB[0], "biCompression")) THEN
				$IERROR = 10
				EXITLOOP
			ENDIF
			$ATDIB[1] = DLLSTRUCTCREATE($TAGBITMAP)
			$HDIB = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($ATDIB[0], "bmWidth"), DLLSTRUCTGETDATA($ATDIB[0], "bmHeight"), 1)
			IF NOT _WINAPI_GETOBJECT($HDIB, DLLSTRUCTGETSIZE($ATDIB[1]), $ATDIB[1]) THEN
				$IERROR = 11
				EXITLOOP
			ENDIF
			LOCAL $ACALL = DLLCALL("user32.dll", "lresult", "CallWindowProc", "ptr", __ANDPROC(), "ptr", 0, "uint", 0, "wparam", DLLSTRUCTGETPTR($ATDIB[0]), "lparam", DLLSTRUCTGETPTR($ATDIB[1]))
			IF @ERROR THEN
				$IERROR = @ERROR
				EXITLOOP
			ENDIF
			IF NOT $ACALL[0] THEN
				$IERROR = 12
				EXITLOOP
			ENDIF
			$IERROR = 0
		UNTIL 1
		_WINAPI_DELETEOBJECT($HBITMAP)
		IF $IERROR THEN
			IF $HDIB THEN
				_WINAPI_DELETEOBJECT($HDIB)
			ENDIF
			$HDIB = 0
		ENDIF
		RETURN SETERROR($IERROR, 0, $HDIB)
	ENDFUNC
	FUNC _WINAPI_CREATEBITMAP($IWIDTH, $IHEIGHT, $IPLANES = 1, $IBITSPERPEL = 1, $PBITS = 0)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateBitmap", "int", $IWIDTH, "int", $IHEIGHT, "uint", $IPLANES, "uint", $IBITSPERPEL, "struct*", $PBITS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATECOMPATIBLEBITMAP($HDC, $IWIDTH, $IHEIGHT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $HDC, "int", $IWIDTH, "int", $IHEIGHT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDIB($IWIDTH, $IHEIGHT, $IBITSPERPEL = 32, $TCOLORTABLE = 0, $ICOLORCOUNT = 0)
		LOCAL $ARGBQ[2], $ICOLORS, $TAGRGBQ
		SWITCH $IBITSPERPEL
			CASE 1
				$ICOLORS = 2
			CASE 4
				$ICOLORS = 16
			CASE 8
				$ICOLORS = 256
			CASE ELSE
				$ICOLORS = 0
		ENDSWITCH
		IF $ICOLORS THEN
			IF NOT ISDLLSTRUCT($TCOLORTABLE) THEN
				SWITCH $IBITSPERPEL
					CASE 1
						$ARGBQ[0] = 0
						$ARGBQ[1] = 16777215
						$TCOLORTABLE = _WINAPI_CREATEDIBCOLORTABLE($ARGBQ)
					CASE ELSE
				ENDSWITCH
			ELSE
				IF $ICOLORS > $ICOLORCOUNT THEN
					$ICOLORS = $ICOLORCOUNT
				ENDIF
				IF(NOT $ICOLORS) OR((4 * $ICOLORS) > DLLSTRUCTGETSIZE($TCOLORTABLE)) THEN
					RETURN SETERROR(20, 0, 0)
				ENDIF
			ENDIF
			$TAGRGBQ = ";dword aRGBQuad[" & $ICOLORS & "]"
		ELSE
			$TAGRGBQ = ""
		ENDIF
		LOCAL $TBITMAPINFO = DLLSTRUCTCREATE($TAGBITMAPINFOHEADER & $TAGRGBQ)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biSize", 40)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biWidth", $IWIDTH)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biHeight", $IHEIGHT)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biPlanes", 1)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biBitCount", $IBITSPERPEL)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biCompression", 0)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biSizeImage", 0)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biXPelsPerMeter", 0)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biYPelsPerMeter", 0)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biClrUsed", $ICOLORS)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biClrImportant", 0)
		IF $ICOLORS THEN
			IF ISDLLSTRUCT($TCOLORTABLE) THEN
				_WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($TBITMAPINFO, "aRGBQuad"), $TCOLORTABLE, 4 * $ICOLORS)
			ELSE
				_WINAPI_ZEROMEMORY(DLLSTRUCTGETPTR($TBITMAPINFO, "aRGBQuad"), 4 * $ICOLORS)
			ENDIF
		ENDIF
		LOCAL $HBITMAP = _WINAPI_CREATEDIBSECTION(0, $TBITMAPINFO, 0, $__G_VEXT)
		IF NOT $HBITMAP THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $HBITMAP
	ENDFUNC
	FUNC _WINAPI_CREATEDIBSECTION($HDC, $TBITMAPINFO, $IUSAGE, BYREF $PBITS, $HSECTION = 0, $IOFFSET = 0)
		$PBITS = 0
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateDIBSection", "handle", $HDC, "struct*", $TBITMAPINFO, "uint", $IUSAGE, "ptr*", 0, "handle", $HSECTION, "dword", $IOFFSET)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$PBITS = $ACALL[4]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDIBCOLORTABLE(CONST BYREF $ACOLORTABLE, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($ACOLORTABLE, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TCOLORTABLE = DLLSTRUCTCREATE("dword[" & ($IEND - $ISTART + 1) & "]")
		LOCAL $ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			DLLSTRUCTSETDATA($TCOLORTABLE, 1, _WINAPI_SWITCHCOLOR(__RGB($ACOLORTABLE[$I])), $ICOUNT)
			$ICOUNT += 1
		NEXT
		RETURN $TCOLORTABLE
	ENDFUNC
	FUNC _WINAPI_CREATEFONT($IHEIGHT, $IWIDTH, $IESCAPE = 0, $IORIENTN = 0, $IWEIGHT = $__WINAPICONSTANT_FW_NORMAL, $BITALIC = FALSE, $BUNDERLINE = FALSE, $BSTRIKEOUT = FALSE, $ICHARSET = $__WINAPICONSTANT_DEFAULT_CHARSET, $IOUTPUTPREC = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $ICLIPPREC = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $IQUALITY = $__WINAPICONSTANT_DEFAULT_QUALITY, $IPITCH = 0, $SFACE = "Arial")
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateFontW", "int", $IHEIGHT, "int", $IWIDTH, "int", $IESCAPE, "int", $IORIENTN, "int", $IWEIGHT, "dword", $BITALIC, "dword", $BUNDERLINE, "dword", $BSTRIKEOUT, "dword", $ICHARSET, "dword", $IOUTPUTPREC, "dword", $ICLIPPREC, "dword", $IQUALITY, "dword", $IPITCH, "wstr", $SFACE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEFONTINDIRECT($TLOGFONT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $TLOGFONT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATERECTRGN($ILEFTRECT, $ITOPRECT, $IRIGHTRECT, $IBOTTOMRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateRectRgn", "int", $ILEFTRECT, "int", $ITOPRECT, "int", $IRIGHTRECT, "int", $IBOTTOMRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEROUNDRECTRGN($ILEFTRECT, $ITOPRECT, $IRIGHTRECT, $IBOTTOMRECT, $IWIDTHELLIPSE, $IHEIGHTELLIPSE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $ILEFTRECT, "int", $ITOPRECT, "int", $IRIGHTRECT, "int", $IBOTTOMRECT, "int", $IWIDTHELLIPSE, "int", $IHEIGHTELLIPSE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATESOLIDBRUSH($ICOLOR)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateSolidBrush", "INT", $ICOLOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETBITMAPDIMENSION($HBITMAP)
		LOCAL $TOBJ = DLLSTRUCTCREATE($TAGBITMAP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetObject", "handle", $HBITMAP, "int", DLLSTRUCTGETSIZE($TOBJ), "struct*", $TOBJ)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN _WINAPI_CREATESIZE(DLLSTRUCTGETDATA($TOBJ, "bmWidth"), DLLSTRUCTGETDATA($TOBJ, "bmHeight"))
	ENDFUNC
	FUNC _WINAPI_GETSYSCOLORBRUSH($IINDEX)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetSysColorBrush", "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETTEXTEXTENTPOINT32($HDC, $STEXT)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ISIZE = STRINGLEN($STEXT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $HDC, "wstr", $STEXT, "int", $ISIZE, "struct*", $TSIZE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETTEXTMETRICS($HDC)
		LOCAL $TTEXTMETRIC = DLLSTRUCTCREATE($TAGTEXTMETRIC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetTextMetricsW", "handle", $HDC, "struct*", $TTEXTMETRIC)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TTEXTMETRIC
	ENDFUNC
	FUNC _WINAPI_GETWINDOWRGN($HWND, $HRGN)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "GetWindowRgn", "hwnd", $HWND, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISALPHABITMAP($HBITMAP)
		$HBITMAP = _WINAPI_COPYBITMAP($HBITMAP)
		IF NOT $HBITMAP THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL, $IERROR = 0
		DO
			LOCAL $TDIB = DLLSTRUCTCREATE($TAGDIBSECTION)
			IF(NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($TDIB), $TDIB)) OR(DLLSTRUCTGETDATA($TDIB, "bmBitsPixel") <> 32) OR(DLLSTRUCTGETDATA($TDIB, "biCompression")) THEN
				$IERROR = 1
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("user32.dll", "int", "CallWindowProc", "ptr", __ALPHAPROC(), "ptr", 0, "uint", 0, "struct*", $TDIB, "ptr", 0)
			IF @ERROR OR($ACALL[0] = -1) THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
		UNTIL 1
		_WINAPI_DELETEOBJECT($HBITMAP)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PTINRECT(BYREF $TRECT, BYREF $TPOINT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "PtInRect", "struct*", $TRECT, "struct", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REDRAWWINDOW($HWND, $TRECT = 0, $HREGION = 0, $IFLAGS = 5)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "RedrawWindow", "hwnd", $HWND, "struct*", $TRECT, "handle", $HREGION, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWRGN($HWND, $HRGN, $BREDRAW = TRUE)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "SetWindowRgn", "hwnd", $HWND, "handle", $HRGN, "bool", $BREDRAW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
#Region Embedded DLL Functions
	FUNC __ALPHAPROC()
		STATIC $PPROC = 0
		IF NOT $PPROC THEN
			IF @AUTOITX64 THEN
				$PPROC = __INIT(BINARY("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883" & "7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB" & "034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B" & "6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24" & "287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080" & "7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB" & "034831C04883C438415F5DC3"))
			ELSE
				$PPROC = __INIT(BINARY("0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D" & "1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407" & "B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302" & "83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00" & "007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000"))
			ENDIF
		ENDIF
		RETURN $PPROC
	ENDFUNC
	FUNC __ANDPROC()
		STATIC $PPROC = 0
		IF NOT $PPROC THEN
			IF @AUTOITX64 THEN
				$PPROC = __INIT(BINARY("0x48894C240848895424104C894424184C894C2420554157415648C7C009000000" & "4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405" & "4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405" & "4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405" & "4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405" & "4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048" & "21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000" & "EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7" & "44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100" & "0048C74424380000000048C74424400000000048C744244800000000488BAC24" & "A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B" & "7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440" & "4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24" & "4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7" & "442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C" & "24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845" & "0048FF4424604883442458F871B948C74424380000000048C744244000000000" & "48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7" & "D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C" & "244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D" & "184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24" & "585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0" & "010000004863C0EB034831C04883C470415E415F5DC3"))
			ELSE
				$PPROC = __INIT(BINARY("0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05" & "B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24" & "38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0" & "EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000" & "00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7" & "042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000" & "C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B" & "3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480" & "7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24" & "0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424" & "0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3" & "8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8" & "01000000EB0231C083C4205F5B5DC21000"))
			ENDIF
		ENDIF
		RETURN $PPROC
	ENDFUNC
	FUNC __XORPROC()
		STATIC $PPROC = 0
		IF NOT $PPROC THEN
			IF @AUTOITX64 THEN
				$PPROC = __INIT(BINARY("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074" & "054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0" & "4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C" & "3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405" & "4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C" & "897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB" & "034831C04883C438415F5DC3"))
			ELSE
				$PPROC = __INIT(BINARY("0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074" & "0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB" & "5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B" & "6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303" & "895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D" & "C21000"))
			ENDIF
		ENDIF
		RETURN $PPROC
	ENDFUNC
#EndRegion Embedded DLL Functions
#Region Internal Functions
	FUNC __INIT($DDATA)
		LOCAL $ILENGTH = BINARYLEN($DDATA)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "ptr", "VirtualAlloc", "ptr", 0, "ulong_ptr", $ILENGTH, "dword", 4096, "dword", 64)
		IF @ERROR OR NOT $ACALL[0] THEN __FATALEXIT(1, "Error allocating memory.")
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & $ILENGTH & "]", $ACALL[0])
		DLLSTRUCTSETDATA($TDATA, 1, $DDATA)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL CONST $DI_MASK = 1
	GLOBAL CONST $DI_IMAGE = 2
	GLOBAL CONST $DI_NORMAL = 3
	GLOBAL CONST $DI_COMPAT = 4
	GLOBAL CONST $DI_DEFAULTSIZE = 8
	GLOBAL CONST $DI_NOMIRROR = 16
	GLOBAL CONST $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 1
	GLOBAL CONST $DISPLAY_DEVICE_MULTI_DRIVER = 2
	GLOBAL CONST $DISPLAY_DEVICE_PRIMARY_DEVICE = 4
	GLOBAL CONST $DISPLAY_DEVICE_MIRRORING_DRIVER = 8
	GLOBAL CONST $DISPLAY_DEVICE_VGA_COMPATIBLE = 16
	GLOBAL CONST $DISPLAY_DEVICE_REMOVABLE = 32
	GLOBAL CONST $DISPLAY_DEVICE_DISCONNECT = 33554432
	GLOBAL CONST $DISPLAY_DEVICE_REMOTE = 67108864
	GLOBAL CONST $DISPLAY_DEVICE_MODESPRUNED = 134217728
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CREATECOMPATIBLEDC($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DELETEDC($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAWEDGE($HDC, $TRECT, $IEDGETYPE, $IFLAGS)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DrawEdge", "handle", $HDC, "struct*", $TRECT, "uint", $IEDGETYPE, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAWFRAMECONTROL($HDC, $TRECT, $ITYPE, $ISTATE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DrawFrameControl", "handle", $HDC, "struct*", $TRECT, "uint", $ITYPE, "uint", $ISTATE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAWICON($HDC, $IX, $IY, $HICON)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DrawIcon", "handle", $HDC, "int", $IX, "int", $IY, "handle", $HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAWICONEX($HDC, $IX, $IY, $HICON, $IWIDTH = 0, $IHEIGHT = 0, $ISTEP = 0, $HBRUSH = 0, $IFLAGS = 3)
		LOCAL $IOPTIONS
		SWITCH $IFLAGS
			CASE 1
				$IOPTIONS = $DI_MASK
			CASE 2
				$IOPTIONS = $DI_IMAGE
			CASE 3
				$IOPTIONS = $DI_NORMAL
			CASE 4
				$IOPTIONS = $DI_COMPAT
			CASE 5
				$IOPTIONS = $DI_DEFAULTSIZE
			CASE ELSE
				$IOPTIONS = $DI_NOMIRROR
		ENDSWITCH
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DrawIconEx", "handle", $HDC, "int", $IX, "int", $IY, "handle", $HICON, "int", $IWIDTH, "int", $IHEIGHT, "uint", $ISTEP, "handle", $HBRUSH, "uint", $IOPTIONS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAWTEXT($HDC, $STEXT, BYREF $TRECT, $IFLAGS)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "DrawTextW", "handle", $HDC, "wstr", $STEXT, "int", -1, "struct*", $TRECT, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENUMDISPLAYDEVICES($SDEVICE, $IDEVNUM)
		LOCAL $TNAME = 0, $IFLAGS = 0, $ADEVICE[5]
		IF $SDEVICE <> "" THEN
			$TNAME = DLLSTRUCTCREATE("wchar Text[" & STRINGLEN($SDEVICE) + 1 & "]")
			DLLSTRUCTSETDATA($TNAME, "Text", $SDEVICE)
		ENDIF
		LOCAL CONST $TAGDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
		LOCAL $TDEVICE = DLLSTRUCTCREATE($TAGDISPLAY_DEVICE)
		LOCAL $IDEVICE = DLLSTRUCTGETSIZE($TDEVICE)
		DLLSTRUCTSETDATA($TDEVICE, "Size", $IDEVICE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $TNAME, "dword", $IDEVNUM, "struct*", $TDEVICE, "dword", 1)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $IN = DLLSTRUCTGETDATA($TDEVICE, "Flags")
		IF BITAND($IN, $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 1)
		IF BITAND($IN, $DISPLAY_DEVICE_PRIMARY_DEVICE) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 2)
		IF BITAND($IN, $DISPLAY_DEVICE_MIRRORING_DRIVER) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 4)
		IF BITAND($IN, $DISPLAY_DEVICE_VGA_COMPATIBLE) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 8)
		IF BITAND($IN, $DISPLAY_DEVICE_REMOVABLE) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 16)
		IF BITAND($IN, $DISPLAY_DEVICE_MODESPRUNED) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 32)
		$ADEVICE[0] = TRUE
		$ADEVICE[1] = DLLSTRUCTGETDATA($TDEVICE, "Name")
		$ADEVICE[2] = DLLSTRUCTGETDATA($TDEVICE, "String")
		$ADEVICE[3] = $IFLAGS
		$ADEVICE[4] = DLLSTRUCTGETDATA($TDEVICE, "ID")
		RETURN $ADEVICE
	ENDFUNC
	FUNC _WINAPI_FILLRECT($HDC, $TRECT, $HBRUSH)
		LOCAL $ACALL
		IF ISPTR($HBRUSH) THEN
			$ACALL = DLLCALL("user32.dll", "int", "FillRect", "handle", $HDC, "struct*", $TRECT, "handle", $HBRUSH)
		ELSE
			$ACALL = DLLCALL("user32.dll", "int", "FillRect", "handle", $HDC, "struct*", $TRECT, "dword_ptr", $HBRUSH)
		ENDIF
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FRAMERECT($HDC, $TRECT, $HBRUSH)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "FrameRect", "handle", $HDC, "struct*", $TRECT, "handle", $HBRUSH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETBKMODE($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetBkMode", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETDC($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETDCEX($HWND, $HRGN, $IFLAGS)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetDCEx", "hwnd", $HWND, "handle", $HRGN, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETDEVICECAPS($HDC, $IINDEX)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetDeviceCaps", "handle", $HDC, "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETTEXTCOLOR($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "dword", "GetTextColor", "handle", $HDC)
		IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_GETWINDOWDC($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetWindowDC", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PRINTWINDOW($HWND, $HDC, $BCLIENT = FALSE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "PrintWindow", "hwnd", $HWND, "handle", $HDC, "uint", $BCLIENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RELEASEDC($HWND, $HDC)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", $HWND, "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RESTOREDC($HDC, $IID)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "RestoreDC", "handle", $HDC, "int", $IID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SAVEDC($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SaveDC", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETBKCOLOR($HDC, $ICOLOR)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "INT", "SetBkColor", "handle", $HDC, "INT", $ICOLOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETBKMODE($HDC, $IBKMODE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetBkMode", "handle", $HDC, "int", $IBKMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETTEXTCOLOR($HDC, $ICOLOR)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "INT", "SetTextColor", "handle", $HDC, "INT", $ICOLOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_TWIPSPERPIXELX()
		LOCAL $HDC, $ITWIPSPERPIXELX
		$HDC = _WINAPI_GETDC(0)
		LOCAL CONST $__WINAPICONSTANT_LOGPIXELSX = 88
		$ITWIPSPERPIXELX = 1440 / _WINAPI_GETDEVICECAPS($HDC, $__WINAPICONSTANT_LOGPIXELSX)
		_WINAPI_RELEASEDC(0, $HDC)
		RETURN $ITWIPSPERPIXELX
	ENDFUNC
	FUNC _WINAPI_TWIPSPERPIXELY()
		LOCAL $HDC, $ITWIPSPERPIXELY
		$HDC = _WINAPI_GETDC(0)
		LOCAL CONST $__WINAPICONSTANT_LOGPIXELSY = 90
		$ITWIPSPERPIXELY = 1440 / _WINAPI_GETDEVICECAPS($HDC, $__WINAPICONSTANT_LOGPIXELSY)
		_WINAPI_RELEASEDC(0, $HDC)
		RETURN $ITWIPSPERPIXELY
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL CONST $IDC_UNKNOWN = 0
	GLOBAL CONST $IDC_APPSTARTING = 32650
	GLOBAL CONST $IDC_ARROW = 32512
	GLOBAL CONST $IDC_CROSS = 32515
	GLOBAL CONST $IDC_HAND = 32649
	GLOBAL CONST $IDC_HELP = 32651
	GLOBAL CONST $IDC_IBEAM = 32513
	GLOBAL CONST $IDC_NO = 32648
	GLOBAL CONST $IDC_SIZEALL = 32646
	GLOBAL CONST $IDC_SIZENESW = 32643
	GLOBAL CONST $IDC_SIZENS = 32645
	GLOBAL CONST $IDC_SIZENWSE = 32642
	GLOBAL CONST $IDC_SIZEWE = 32644
	GLOBAL CONST $IDC_UPARROW = 32516
	GLOBAL CONST $IDC_WAIT = 32514
	GLOBAL CONST $IDI_APPLICATION = 32512
	GLOBAL CONST $IDI_ASTERISK = 32516
	GLOBAL CONST $IDI_EXCLAMATION = 32515
	GLOBAL CONST $IDI_HAND = 32513
	GLOBAL CONST $IDI_QUESTION = 32514
	GLOBAL CONST $IDI_WINLOGO = 32517
	GLOBAL CONST $IDI_SHIELD = 32518
	GLOBAL CONST $IDI_ERROR = $IDI_HAND
	GLOBAL CONST $IDI_INFORMATION = $IDI_ASTERISK
	GLOBAL CONST $IDI_WARNING = $IDI_EXCLAMATION
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	GLOBAL CONST $TAGICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
	FUNC _WINAPI_ADDICONTRANSPARENCY($HICON, $IPERCENT = 50, $BDELETE = FALSE)
		LOCAL $TBITMAP, $HDIB = 0, $HRESULT = 0
		LOCAL $AHBITMAP[2]
		LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HICON, "struct*", $TICONINFO)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		FOR $I = 0 TO 1
			$AHBITMAP[$I] = DLLSTRUCTGETDATA($TICONINFO, $I + 4)
		NEXT
		LOCAL $IERROR = 0
		DO
			$HDIB = _WINAPI_COPYBITMAP($AHBITMAP[1])
			IF NOT $HDIB THEN
				$IERROR = 20
				EXITLOOP
			ENDIF
			$TBITMAP = DLLSTRUCTCREATE($TAGBITMAP)
			IF(NOT _WINAPI_GETOBJECT($HDIB, DLLSTRUCTGETSIZE($TBITMAP), $TBITMAP)) OR(DLLSTRUCTGETDATA($TBITMAP, "bmBitsPixel") <> 32) THEN
				$IERROR = 21
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("user32.dll", "lresult", "CallWindowProc", "PTR", __TRANSPARENCYPROC(), "hwnd", 0, "uint", $IPERCENT, "wparam", DLLSTRUCTGETPTR($TBITMAP), "lparam", 0)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			IF $ACALL[0] = -1 THEN
				$HRESULT = _WINAPI_CREATEEMPTYICON(DLLSTRUCTGETDATA($TBITMAP, "bmWidth"), DLLSTRUCTGETDATA($TBITMAP, "bmHeight"))
			ELSE
				$HRESULT = _WINAPI_CREATEICONINDIRECT($HDIB, $AHBITMAP[0])
			ENDIF
			IF NOT $HRESULT THEN $IERROR = 22
		UNTIL 1
		IF $HDIB THEN
			_WINAPI_DELETEOBJECT($HDIB)
		ENDIF
		FOR $I = 0 TO 1
			IF $AHBITMAP[$I] THEN
				_WINAPI_DELETEOBJECT($AHBITMAP[$I])
			ENDIF
		NEXT
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		IF $BDELETE THEN
			_WINAPI_DESTROYICON($HICON)
		ENDIF
		RETURN $HRESULT
	ENDFUNC
	FUNC _WINAPI_COPYICON($HICON)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "CopyIcon", "handle", $HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATE32BITHICON($HICON, $BDELETE = FALSE)
		LOCAL $AHBITMAP[2], $HRESULT = 0
		LOCAL $ADIB[2][2] = [[0, 0], [0, 0]]
		LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HICON, "struct*", $TICONINFO)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		FOR $I = 0 TO 1
			$AHBITMAP[$I] = DLLSTRUCTGETDATA($TICONINFO, $I + 4)
		NEXT
		IF _WINAPI_ISALPHABITMAP($AHBITMAP[1]) THEN
			$ADIB[0][0] = _WINAPI_CREATEANDBITMAP($AHBITMAP[1])
			IF NOT @ERROR THEN
				$HRESULT = _WINAPI_CREATEICONINDIRECT($AHBITMAP[1], $ADIB[0][0])
			ENDIF
		ELSE
			LOCAL $TSIZE = _WINAPI_GETBITMAPDIMENSION($AHBITMAP[1])
			LOCAL $ASIZE[2]
			FOR $I = 0 TO 1
				$ASIZE[$I] = DLLSTRUCTGETDATA($TSIZE, $I + 1)
			NEXT
			LOCAL $HSRCDC = _WINAPI_CREATECOMPATIBLEDC(0)
			LOCAL $HDSTDC = _WINAPI_CREATECOMPATIBLEDC(0)
			LOCAL $HSRCSV, $HDSTSV
			FOR $I = 0 TO 1
				$ADIB[$I][0] = _WINAPI_CREATEDIB($ASIZE[0], $ASIZE[1])
				$ADIB[$I][1] = $__G_VEXT
				$HSRCSV = _WINAPI_SELECTOBJECT($HSRCDC, $AHBITMAP[$I])
				$HDSTSV = _WINAPI_SELECTOBJECT($HDSTDC, $ADIB[$I][0])
				_WINAPI_BITBLT($HDSTDC, 0, 0, $ASIZE[0], $ASIZE[1], $HSRCDC, 0, 0, 12583114)
				_WINAPI_SELECTOBJECT($HSRCDC, $HSRCSV)
				_WINAPI_SELECTOBJECT($HDSTDC, $HDSTSV)
			NEXT
			_WINAPI_DELETEDC($HSRCDC)
			_WINAPI_DELETEDC($HDSTDC)
			$ACALL = DLLCALL("user32.dll", "lresult", "CallWindowProc", "ptr", __XORPROC(), "ptr", 0, "uint", $ASIZE[0] * $ASIZE[1] * 4, "wparam", $ADIB[0][1], "lparam", $ADIB[1][1])
			IF NOT @ERROR AND $ACALL[0] THEN
				$HRESULT = _WINAPI_CREATEICONINDIRECT($ADIB[1][0], $AHBITMAP[0])
			ENDIF
		ENDIF
		FOR $I = 0 TO 1
			_WINAPI_DELETEOBJECT($AHBITMAP[$I])
			IF $ADIB[$I][0] THEN
				_WINAPI_DELETEOBJECT($ADIB[$I][0])
			ENDIF
		NEXT
		IF NOT $HRESULT THEN RETURN SETERROR(11, 0, 0)
		IF $BDELETE THEN
			_WINAPI_DESTROYICON($HICON)
		ENDIF
		RETURN $HRESULT
	ENDFUNC
	FUNC _WINAPI_CREATEEMPTYICON($IWIDTH, $IHEIGHT, $IBITSPERPEL = 32)
		LOCAL $HXOR = _WINAPI_CREATEDIB($IWIDTH, $IHEIGHT, $IBITSPERPEL)
		LOCAL $HAND = _WINAPI_CREATEDIB($IWIDTH, $IHEIGHT, 1)
		LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HSV = _WINAPI_SELECTOBJECT($HDC, $HAND)
		LOCAL $HBRUSH = _WINAPI_CREATESOLIDBRUSH(16777215)
		LOCAL $TRECT = _WINAPI_CREATERECT(0, 0, $IWIDTH, $IHEIGHT)
		_WINAPI_FILLRECT($HDC, $TRECT, $HBRUSH)
		_WINAPI_DELETEOBJECT($HBRUSH)
		_WINAPI_SELECTOBJECT($HDC, $HSV)
		_WINAPI_DELETEDC($HDC)
		LOCAL $HICON = _WINAPI_CREATEICONINDIRECT($HXOR, $HAND)
		LOCAL $IERROR = @ERROR
		IF $HXOR THEN
			_WINAPI_DELETEOBJECT($HXOR)
		ENDIF
		IF $HAND THEN
			_WINAPI_DELETEOBJECT($HAND)
		ENDIF
		IF NOT $HICON THEN RETURN SETERROR($IERROR + 10, 0, 0)
		RETURN $HICON
	ENDFUNC
	FUNC _WINAPI_CREATEICON($HINSTANCE, $IWIDTH, $IHEIGHT, $IPLANES, $IBITSPIXEL, $PANDBITS, $PXORBITS)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "CreateIcon", "handle", $HINSTANCE, "int", $IWIDTH, "int", $IHEIGHT, "byte", $IPLANES, "byte", $IBITSPIXEL, "struct*", $PANDBITS, "struct*", $PXORBITS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEICONFROMRESOURCEEX($PDATA, $ISIZE, $BICON = TRUE, $IXDESIREDPIXELS = 0, $IYDESIREDPIXELS = 0, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "CreateIconFromResourceEx", "ptr", $PDATA, "dword", $ISIZE, "bool", $BICON, "dword", 196608, "int", $IXDESIREDPIXELS, "int", $IYDESIREDPIXELS, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEICONINDIRECT($HBITMAP, $HMASK, $IXHOTSPOT = 0, $IYHOTSPOT = 0, $BICON = TRUE)
		LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
		DLLSTRUCTSETDATA($TICONINFO, 1, $BICON)
		DLLSTRUCTSETDATA($TICONINFO, 2, $IXHOTSPOT)
		DLLSTRUCTSETDATA($TICONINFO, 3, $IYHOTSPOT)
		DLLSTRUCTSETDATA($TICONINFO, 4, $HMASK)
		DLLSTRUCTSETDATA($TICONINFO, 5, $HBITMAP)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "CreateIconIndirect", "struct*", $TICONINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DESTROYICON($HICON)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DestroyIcon", "handle", $HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_EXTRACTICON($SICON, $IINDEX, $BSMALL = FALSE)
		LOCAL $PLARGE, $PSMALL, $TPTR = DLLSTRUCTCREATE("ptr")
		IF $BSMALL THEN
			$PLARGE = 0
			$PSMALL = DLLSTRUCTGETPTR($TPTR)
		ELSE
			$PLARGE = DLLSTRUCTGETPTR($TPTR)
			$PSMALL = 0
		ENDIF
		DLLCALL("shell32.dll", "uint", "ExtractIconExW", "wstr", $SICON, "int", $IINDEX, "ptr", $PLARGE, "ptr", $PSMALL, "uint", 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TPTR, 1)
	ENDFUNC
	FUNC _WINAPI_EXTRACTICONEX($SFILEPATH, $IINDEX, $PALARGE, $PASMALL, $IICONS)
		LOCAL $ACALL = DLLCALL("shell32.dll", "uint", "ExtractIconExW", "wstr", $SFILEPATH, "int", $IINDEX, "struct*", $PALARGE, "struct*", $PASMALL, "uint", $IICONS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FILEICONINIT($BRESTORE = TRUE)
		LOCAL $ACALL = DLLCALL("shell32.dll", "int", 660, "int", $BRESTORE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_GETICONDIMENSION($HICON)
		LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HICON, "struct*", $TICONINFO)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TSIZE = _WINAPI_GETBITMAPDIMENSION(DLLSTRUCTGETDATA($TICONINFO, 5))
		FOR $I = 4 TO 5
			_WINAPI_DELETEOBJECT(DLLSTRUCTGETDATA($TICONINFO, $I))
		NEXT
		IF NOT ISDLLSTRUCT($TSIZE) THEN RETURN SETERROR(20, 0, 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETICONINFO($HICON)
		LOCAL $TINFO = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HICON, "struct*", $TINFO)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $AICON[6]
		$AICON[0] = TRUE
		$AICON[1] = DLLSTRUCTGETDATA($TINFO, "Icon") <> 0
		$AICON[2] = DLLSTRUCTGETDATA($TINFO, "XHotSpot")
		$AICON[3] = DLLSTRUCTGETDATA($TINFO, "YHotSpot")
		$AICON[4] = DLLSTRUCTGETDATA($TINFO, "hMask")
		$AICON[5] = DLLSTRUCTGETDATA($TINFO, "hColor")
		RETURN $AICON
	ENDFUNC
	FUNC _WINAPI_GETICONINFOEX($HICON)
		LOCAL $TIIEX = DLLSTRUCTCREATE("dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]")
		DLLSTRUCTSETDATA($TIIEX, 1, DLLSTRUCTGETSIZE($TIIEX))
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetIconInfoExW", "handle", $HICON, "struct*", $TIIEX)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[8]
		FOR $I = 0 TO 7
			$ARET[$I] = DLLSTRUCTGETDATA($TIIEX, $I + 2)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_LOADICON($HINSTANCE, $SNAME)
		LOCAL $STYPEOFNAME = "int"
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "LoadIconW", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADICONMETRIC($HINSTANCE, $SNAME, $IMETRIC)
		LOCAL $STYPEOFNAME = "int"
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ACALL = DLLCALL("comctl32.dll", "long", "LoadIconMetric", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME, "int", $IMETRIC, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[4]
	ENDFUNC
	FUNC _WINAPI_LOADICONWITHSCALEDOWN($HINSTANCE, $SNAME, $IWIDTH, $IHEIGHT)
		LOCAL $STYPEOFNAME = "int"
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ACALL = DLLCALL("comctl32.dll", "long", "LoadIconWithScaleDown", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME, "int", $IWIDTH, "int", $IHEIGHT, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[5]
	ENDFUNC
	FUNC _WINAPI_LOADSHELL32ICON($IICONID)
		LOCAL $TICONS = DLLSTRUCTCREATE("ptr Data")
		LOCAL $IICONS = _WINAPI_EXTRACTICONEX("shell32.dll", $IICONID, 0, $TICONS, 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $IICONS <= 0 THEN RETURN SETERROR(10, 0, 0)
		RETURN DLLSTRUCTGETDATA($TICONS, "Data")
	ENDFUNC
	FUNC _WINAPI_LOOKUPICONIDFROMDIRECTORYEX($PDATA, $BICON = TRUE, $IXDESIREDPIXELS = 0, $IYDESIREDPIXELS = 0, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "LookupIconIdFromDirectoryEx", "ptr", $PDATA, "bool", $BICON, "int", $IXDESIREDPIXELS, "int", $IYDESIREDPIXELS, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MIRRORICON($HICON, $BDELETE = FALSE)
		IF NOT $BDELETE THEN
			$HICON = _WINAPI_COPYICON($HICON)
		ENDIF
		LOCAL $ACALL = DLLCALL("comctl32.dll", "int", 414, "ptr", 0, "ptr*", $HICON)
		IF @ERROR OR NOT $ACALL[0] THEN
			LOCAL $IERROR = @ERROR + 10
			IF $HICON AND NOT $BDELETE THEN
				_WINAPI_DESTROYICON($HICON)
			ENDIF
			RETURN SETERROR($IERROR, 0, 0)
		ENDIF
		RETURN $ACALL[2]
	ENDFUNC
#EndRegion Public Functions
#Region Embedded DLL Functions
	FUNC __TRANSPARENCYPROC()
		STATIC $PPROC = 0
		IF NOT $PPROC THEN
			IF @AUTOITX64 THEN
				$PPROC = __INIT(BINARY("0x48894C240848895424104C894424184C894C24205541574831C0505050505050" & "4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522" & "488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502" & "EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63" & "7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF" & "7D08C74424780000000048C74424280100000048C74424300000000048C74424" & "3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF" & "F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18" & "4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C" & "244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899" & "48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7" & "4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24" & "3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0" & "FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F" & "5DC3"))
			ELSE
				$PPROC = __INIT(BINARY("0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24" & "28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021" & "C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24" & "2421DB7D08C744242400000000C7042401000000C744240400000000C7442408" & "000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B" & "6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24" & "100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058" & "8845008B6C240C807D00007407C7042400000000C74424040100000083442408" & "047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF" & "FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000"))
			ENDIF
		ENDIF
		RETURN $PPROC
	ENDFUNC
#EndRegion Embedded DLL Functions
#Region Global Variables and Constants
	GLOBAL CONST $TAGBITMAPV4HEADER = "struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct"
	GLOBAL CONST $TAGCOLORADJUSTMENT = "ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint"
	GLOBAL CONST $TAGDEVMODE = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight"
	GLOBAL CONST $TAGDEVMODE_DISPLAY = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;" & $TAGPOINT & ";dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency"
	GLOBAL CONST $TAGDWM_COLORIZATION_PARAMETERS = "dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend"
	GLOBAL CONST $TAGENHMETAHEADER = "struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct"
	GLOBAL CONST $TAGEXTLOGPEN = "dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries"
	GLOBAL CONST $TAGFONTSIGNATURE = "dword fsUsb[4];dword fsCsb[2]"
	GLOBAL CONST $TAGGLYPHMETRICS = "uint BlackBoxX;uint BlackBoxY;" & $TAGPOINT & ";short CellIncX;short CellIncY"
	GLOBAL CONST $TAGLOGBRUSH = "uint Style;dword Color;ulong_ptr Hatch"
	GLOBAL CONST $TAGLOGPEN = "uint Style;dword Width;dword Color"
	GLOBAL CONST $TAGMAT2 = "short eM11[2];short eM12[2];short eM21[2];short eM22[2]"
	GLOBAL CONST $TAGNEWTEXTMETRIC = $TAGTEXTMETRIC & ";dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth"
	GLOBAL CONST $TAGNEWTEXTMETRICEX = $TAGNEWTEXTMETRIC & ";" & $TAGFONTSIGNATURE
	GLOBAL CONST $TAGPANOSE = "struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct"
	GLOBAL CONST $TAGOUTLINETEXTMETRIC = "struct;uint otmSize;" & $TAGTEXTMETRIC & ";byte otmFiller;" & $TAGPANOSE & ";byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct"
	GLOBAL CONST $TAGPAINTSTRUCT = "hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]"
	GLOBAL CONST $TAGRGNDATAHEADER = "struct;dword Size;dword Type;dword Count;dword RgnSize;" & $TAGRECT & ";endstruct"
	GLOBAL CONST $TAGXFORM = "float eM11;float eM12;float eM21;float eM22;float eDx;float eDy"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_ABORTPATH($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "AbortPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ADDFONTMEMRESOURCEEX($PDATA, $ISIZE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "AddFontMemResourceEx", "ptr", $PDATA, "dword", $ISIZE, "ptr", 0, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN SETEXTENDED($ACALL[4], $ACALL[0])
	ENDFUNC
	FUNC _WINAPI_ADDFONTRESOURCEEX($SFONT, $IFLAG = 0, $BNOTIFY = FALSE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "AddFontResourceExW", "wstr", $SFONT, "dword", $IFLAG, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $BNOTIFY THEN
			LOCAL CONST $WM_FONTCHANGE = 29
			LOCAL CONST $HWND_BROADCAST = 65535
			DLLCALL("user32.dll", "lresult", "SendMessage", "hwnd", $HWND_BROADCAST, "uint", $WM_FONTCHANGE, "wparam", 0, "lparam", 0)
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ADDICONOVERLAY($HICON, $HOVERLAY)
		LOCAL $ACALL, $HRESULT = 0, $IERROR = 0
		LOCAL $AHDEV[2] = [0, 0]
		LOCAL $TSIZE = _WINAPI_GETICONDIMENSION($HICON)
		LOCAL $HIL = DLLCALL("comctl32.dll", "handle", "ImageList_Create", "int", DLLSTRUCTGETDATA($TSIZE, 1), "int", DLLSTRUCTGETDATA($TSIZE, 2), "uint", 33, "int", 2, "int", 2)
		IF @ERROR OR NOT $HIL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		DO
			$AHDEV[0] = _WINAPI_CREATE32BITHICON($HICON)
			IF @ERROR THEN
				$IERROR = @ERROR + 100
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $HIL[0], "int", -1, "handle", $AHDEV[0])
			IF @ERROR OR($ACALL[0] = -1) THEN
				$IERROR = @ERROR + 200
				EXITLOOP
			ENDIF
			$AHDEV[1] = _WINAPI_CREATE32BITHICON($HOVERLAY)
			IF @ERROR THEN
				$IERROR = @ERROR + 300
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $HIL[0], "int", -1, "handle", $AHDEV[1])
			IF @ERROR OR($ACALL[0] = -1) THEN
				$IERROR = @ERROR + 400
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $HIL[0], "int", 1, "int", 1)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 500
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $HIL[0], "int", 0, "uint", 256)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 600
				EXITLOOP
			ENDIF
			$HRESULT = $ACALL[0]
		UNTIL 1
		DLLCALL("comctl32.dll", "bool", "ImageList_Destroy", "handle", $HIL[0])
		FOR $I = 0 TO 1
			IF $AHDEV[$I] THEN
				_WINAPI_DESTROYICON($AHDEV[$I])
			ENDIF
		NEXT
		IF NOT $HRESULT THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $HRESULT
	ENDFUNC
	FUNC _WINAPI_ADJUSTBITMAP($HBITMAP, $IWIDTH, $IHEIGHT, $IMODE = 3, $TADJUSTMENT = 0)
		LOCAL $TOBJ = DLLSTRUCTCREATE($TAGBITMAP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetObject", "handle", $HBITMAP, "int", DLLSTRUCTGETSIZE($TOBJ), "struct*", $TOBJ)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $IWIDTH = -1 THEN
			$IWIDTH = DLLSTRUCTGETDATA($TOBJ, "bmWidth")
		ENDIF
		IF $IHEIGHT = -1 THEN
			$IHEIGHT = DLLSTRUCTGETDATA($TOBJ, "bmHeight")
		ENDIF
		$ACALL = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", 0)
		LOCAL $HDC = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		LOCAL $HDESTDC = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $HDC, "int", $IWIDTH, "int", $IHEIGHT)
		LOCAL $HBMP = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HBMP)
		LOCAL $HDESTSV = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		LOCAL $HSRCDC = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HSRCDC, "handle", $HBITMAP)
		LOCAL $HSRCSV = $ACALL[0]
		IF _WINAPI_SETSTRETCHBLTMODE($HDESTDC, $IMODE) THEN
			SWITCH $IMODE
				CASE 4
					IF ISDLLSTRUCT($TADJUSTMENT) THEN
						IF NOT _WINAPI_SETCOLORADJUSTMENT($HDESTDC, $TADJUSTMENT) THEN
						ENDIF
					ENDIF
				CASE ELSE
			ENDSWITCH
		ENDIF
		$ACALL = _WINAPI_STRETCHBLT($HDESTDC, 0, 0, $IWIDTH, $IHEIGHT, $HSRCDC, 0, 0, DLLSTRUCTGETDATA($TOBJ, "bmWidth"), DLLSTRUCTGETDATA($TOBJ, "bmHeight"), 13369376)
		DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $HDC)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HDESTSV)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HSRCDC, "handle", $HSRCSV)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HDESTDC)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HSRCDC)
		IF NOT $ACALL THEN RETURN SETERROR(10, 0, 0)
		RETURN $HBMP
	ENDFUNC
	FUNC _WINAPI_ALPHABLEND($HDESTDC, $IXDEST, $IYDEST, $IWIDTHDEST, $IHEIGHTDEST, $HSRCDC, $IXSRC, $IYSRC, $IWIDTHSRC, $IHEIGHTSRC, $IALPHA, $BALPHA = FALSE)
		LOCAL $IBLEND = BITOR(BITSHIFT(NOT($BALPHA = FALSE), -24), BITSHIFT(BITAND($IALPHA, 255), -16))
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GdiAlphaBlend", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTHDEST, "int", $IHEIGHTDEST, "handle", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTHSRC, "int", $IHEIGHTSRC, "dword", $IBLEND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ANGLEARC($HDC, $IX, $IY, $IRADIUS, $NSTARTANGLE, $NSWEEPANGLE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "AngleArc", "handle", $HDC, "int", $IX, "int", $IY, "dword", $IRADIUS, "float", $NSTARTANGLE, "float", $NSWEEPANGLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ARC($HDC, $TRECT, $IXSTARTARC, $IYSTARTARC, $IXENDARC, $IYENDARC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "Arc", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4), "int", $IXSTARTARC, "int", $IYSTARTARC, "int", $IXENDARC, "int", $IYENDARC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ARCTO($HDC, $TRECT, $IXRADIAL1, $IYRADIAL1, $IXRADIAL2, $IYRADIAL2)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "ArcTo", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4), "int", $IXRADIAL1, "int", $IYRADIAL1, "int", $IXRADIAL2, "int", $IYRADIAL2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BEGINPAINT($HWND, BYREF $TPAINTSTRUCT)
		$TPAINTSTRUCT = DLLSTRUCTCREATE($TAGPAINTSTRUCT)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "BeginPaint", "hwnd", $HWND, "struct*", $TPAINTSTRUCT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BEGINPATH($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "BeginPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEENHMETAFILE($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CloseEnhMetaFile", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEFIGURE($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "CloseFigure", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COLORADJUSTLUMA($IRGB, $IPERCENT, $BSCALE = TRUE)
		IF $IRGB = -1 THEN RETURN SETERROR(10, 0, -1)
		IF $BSCALE THEN
			$IPERCENT = FLOOR($IPERCENT * 10)
		ENDIF
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "dword", "ColorAdjustLuma", "dword", __RGB($IRGB), "int", $IPERCENT, "bool", $BSCALE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_COLORHLSTORGB($IHUE, $ILUMINANCE, $ISATURATION)
		IF NOT $ISATURATION THEN $IHUE = 160
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "dword", "ColorHLSToRGB", "word", $IHUE, "word", $ILUMINANCE, "word", $ISATURATION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_COLORRGBTOHLS($IRGB, BYREF $IHUE, BYREF $ILUMINANCE, BYREF $ISATURATION)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "none", "ColorRGBToHLS", "dword", __RGB($IRGB), "word*", 0, "word*", 0, "word*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$IHUE = $ACALL[2]
		$ILUMINANCE = $ACALL[3]
		$ISATURATION = $ACALL[4]
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_COMBINETRANSFORM($TXFORM1, $TXFORM2)
		LOCAL $TXFORM = DLLSTRUCTCREATE($TAGXFORM)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "CombineTransform", "struct*", $TXFORM, "struct*", $TXFORM1, "struct*", $TXFORM2)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TXFORM
	ENDFUNC
	FUNC _WINAPI_COMPRESSBITMAPBITS($HBITMAP, BYREF $PBUFFER, $ICOMPRESSION = 0, $IQUALITY = 100)
		IF NOT __DLL("gdiplus.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ASIZE[2], $ICOUNT, $IFORMAT, $ILENGTH, $SMIME, $ACALL, $HDC, $HSV, $HMEM, $TBITS, $TDATA, $PDATA, $IERROR = 1
		LOCAL $HSOURCE = 0, $HIMAGE = 0, $HTOKEN = 0, $PSTREAM = 0, $TPARAM = 0
		LOCAL $TDIB = DLLSTRUCTCREATE($TAGDIBSECTION)
		DO
			SWITCH $ICOMPRESSION
				CASE 0
					$SMIME = "image/png"
				CASE 1
					$SMIME = "image/jpeg"
				CASE ELSE
					$IERROR = 10
					EXITLOOP
			ENDSWITCH
			WHILE $HBITMAP
				IF NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($TDIB), $TDIB) THEN
					$IERROR = 11
					EXITLOOP 2
				ENDIF
				IF(DLLSTRUCTGETDATA($TDIB, "bmBitsPixel") = 32) AND(NOT DLLSTRUCTGETDATA($TDIB, "biCompression")) THEN
					$IERROR = 12
					EXITLOOP
				ENDIF
				IF $HSOURCE THEN
					$IERROR = 13
					EXITLOOP 2
				ENDIF
				$HSOURCE = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($TDIB, "bmWidth"), DLLSTRUCTGETDATA($TDIB, "bmHeight"))
				IF NOT $HSOURCE THEN
					$IERROR = @ERROR + 100
					EXITLOOP 2
				ENDIF
				$HDC = _WINAPI_CREATECOMPATIBLEDC(0)
				$HSV = _WINAPI_SELECTOBJECT($HDC, $HSOURCE)
				IF _WINAPI_DRAWBITMAP($HDC, 0, 0, $HBITMAP) THEN
					$HBITMAP = $HSOURCE
				ELSE
					$IERROR = @ERROR + 200
					$HBITMAP = 0
				ENDIF
				_WINAPI_SELECTOBJECT($HDC, $HSV)
				_WINAPI_DELETEDC($HDC)
			WEND
			IF NOT $HBITMAP THEN
				EXITLOOP
			ENDIF
			FOR $I = 0 TO 1
				$ASIZE[$I] = DLLSTRUCTGETDATA($TDIB, $I + 2)
			NEXT
			$TBITS = DLLSTRUCTCREATE("byte[" & ($ASIZE[0] * $ASIZE[1] * 4) & "]")
			IF NOT _WINAPI_GETBITMAPBITS($HBITMAP, DLLSTRUCTGETSIZE($TBITS), $TBITS) THEN
				$IERROR = @ERROR + 300
				EXITLOOP
			ENDIF
			$TDATA = DLLSTRUCTCREATE($TAGGDIPSTARTUPINPUT)
			DLLSTRUCTSETDATA($TDATA, "Version", 1)
			$ACALL = DLLCALL("gdiplus.dll", "int", "GdiplusStartup", "ulong_ptr*", 0, "struct*", $TDATA, "ptr", 0)
			IF @ERROR OR $ACALL[0] THEN
				$IERROR = @ERROR + 400
				EXITLOOP
			ENDIF
			IF _WINAPI_ISALPHABITMAP($HBITMAP) THEN
				$IFORMAT = 2498570
			ELSE
				$IFORMAT = 139273
			ENDIF
			$HTOKEN = $ACALL[1]
			$ACALL = DLLCALL("gdiplus.dll", "int", "GdipCreateBitmapFromScan0", "int", $ASIZE[0], "int", $ASIZE[1], "uint", $ASIZE[0] * 4, "int", $IFORMAT, "struct*", $TBITS, "ptr*", 0)
			IF @ERROR OR $ACALL[0] THEN
				$IERROR = @ERROR + 500
				EXITLOOP
			ENDIF
			$HIMAGE = $ACALL[6]
			$ACALL = DLLCALL("gdiplus.dll", "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
			IF @ERROR OR $ACALL[0] THEN
				$IERROR = @ERROR + 600
				EXITLOOP
			ENDIF
			$ICOUNT = $ACALL[1]
			$TDATA = DLLSTRUCTCREATE("byte[" & $ACALL[2] & "]")
			IF @ERROR THEN
				$IERROR = @ERROR + 700
				EXITLOOP
			ENDIF
			$PDATA = DLLSTRUCTGETPTR($TDATA)
			$ACALL = DLLCALL("gdiplus.dll", "int", "GdipGetImageEncoders", "uint", $ICOUNT, "uint", $ACALL[2], "struct*", $TDATA)
			IF @ERROR OR $ACALL[0] THEN
				$IERROR = @ERROR + 800
				EXITLOOP
			ENDIF
			LOCAL $TCODEC, $PENCODER = 0
			FOR $I = 1 TO $ICOUNT
				$TCODEC = DLLSTRUCTCREATE($TAGGDIPIMAGECODECINFO, $PDATA)
				IF NOT STRINGINSTR(_WINAPI_GETSTRING(DLLSTRUCTGETDATA($TCODEC, "MimeType")), $SMIME) THEN
					$PDATA += DLLSTRUCTGETSIZE($TAGGDIPIMAGECODECINFO)
				ELSE
					$PENCODER = $PDATA
					$IERROR = 0
					EXITLOOP
				ENDIF
			NEXT
			IF NOT $PENCODER THEN
				$IERROR = 15
				EXITLOOP
			ENDIF
			SWITCH $ICOMPRESSION
				CASE 0
				CASE 1
					LOCAL CONST $TAGENCODERPARAMETER = "byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue"
					$TPARAM = DLLSTRUCTCREATE("dword Count;" & $TAGENCODERPARAMETER & ";ulong Quality")
					DLLSTRUCTSETDATA($TPARAM, "Count", 1)
					DLLSTRUCTSETDATA($TPARAM, "NumberOfValues", 1)
					DLLSTRUCTSETDATA($TPARAM, "Type", 4)
					DLLSTRUCTSETDATA($TPARAM, "pValue", DLLSTRUCTGETPTR($TPARAM, "Quality"))
					DLLSTRUCTSETDATA($TPARAM, "Quality", $IQUALITY)
					$ACALL = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}", "ptr", DLLSTRUCTGETPTR($TPARAM, 2))
					IF @ERROR OR $ACALL[0] THEN
						$TPARAM = 0
					ENDIF
			ENDSWITCH
			$PSTREAM = _WINAPI_CREATESTREAMONHGLOBAL()
			$ACALL = DLLCALL("gdiplus.dll", "int", "GdipSaveImageToStream", "handle", $HIMAGE, "ptr", $PSTREAM, "ptr", $PENCODER, "struct*", $TPARAM)
			IF @ERROR OR $ACALL[0] THEN
				$IERROR = @ERROR + 900
				EXITLOOP
			ENDIF
			$HMEM = _WINAPI_GETHGLOBALFROMSTREAM($PSTREAM)
			$ACALL = DLLCALL("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $HMEM)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 1000
				EXITLOOP
			ENDIF
			$ILENGTH = $ACALL[0]
			$ACALL = DLLCALL("kernel32.dll", "ptr", "GlobalLock", "handle", $HMEM)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 1100
				EXITLOOP
			ENDIF
			$PBUFFER = __HEAPREALLOC($PBUFFER, $ILENGTH, 1)
			IF NOT @ERROR THEN
				_WINAPI_MOVEMEMORY($PBUFFER, $ACALL[0], $ILENGTH)
			ELSE
				$IERROR = @ERROR + 1300
			ENDIF
		UNTIL 1
		IF $PSTREAM THEN
			_WINAPI_RELEASESTREAM($PSTREAM)
		ENDIF
		IF $HIMAGE THEN
			DLLCALL("gdiplus.dll", "int", "GdipDisposeImage", "handle", $HIMAGE)
		ENDIF
		IF $HTOKEN THEN
			DLLCALL("gdiplus.dll", "none", "GdiplusShutdown", "ulong_ptr", $HTOKEN)
		ENDIF
		IF $HSOURCE THEN
			_WINAPI_DELETEOBJECT($HSOURCE)
		ENDIF
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ILENGTH
	ENDFUNC
	FUNC _WINAPI_COPYENHMETAFILE($HEMF, $SFILEPATH = "")
		IF NOT STRINGSTRIPWS($SFILEPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SFILEPATH = NULL
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CopyEnhMetaFileW", "handle", $HEMF, "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COPYRECT($TRECT)
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "CopyRect", "struct*", $TDATA, "struct*", $TRECT)
		IF @ERROR OR NOT $ACALL[0] THEN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TDATA
	ENDFUNC
	FUNC _WINAPI_CREATE32BITHBITMAP($HICON, $BDIB = FALSE, $BDELETE = FALSE)
		LOCAL $HBITMAP = 0
		LOCAL $ADIB[2] = [0, 0]
		LOCAL $HTEMP = _WINAPI_CREATE32BITHICON($HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $IERROR = 0
		DO
			LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
			LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HTEMP, "struct*", $TICONINFO)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			FOR $I = 0 TO 1
				$ADIB[$I] = DLLSTRUCTGETDATA($TICONINFO, $I + 4)
			NEXT
			LOCAL $TBITMAP = DLLSTRUCTCREATE($TAGBITMAP)
			IF NOT _WINAPI_GETOBJECT($ADIB[0], DLLSTRUCTGETSIZE($TBITMAP), $TBITMAP) THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			IF $BDIB THEN
				$HBITMAP = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($TBITMAP, "bmWidth"), DLLSTRUCTGETDATA($TBITMAP, "bmHeight"))
				LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
				LOCAL $HSV = _WINAPI_SELECTOBJECT($HDC, $HBITMAP)
				_WINAPI_DRAWICONEX($HDC, 0, 0, $HTEMP)
				_WINAPI_SELECTOBJECT($HDC, $HSV)
				_WINAPI_DELETEDC($HDC)
			ELSE
				$HBITMAP = $ADIB[1]
				$ADIB[1] = 0
			ENDIF
		UNTIL 1
		FOR $I = 0 TO 1
			IF $ADIB[$I] THEN
				_WINAPI_DELETEOBJECT($ADIB[$I])
			ENDIF
		NEXT
		_WINAPI_DESTROYICON($HTEMP)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		IF NOT $HBITMAP THEN RETURN SETERROR(12, 0, 0)
		IF $BDELETE THEN
			_WINAPI_DESTROYICON($HICON)
		ENDIF
		RETURN $HBITMAP
	ENDFUNC
	FUNC _WINAPI_CREATEBITMAPINDIRECT(BYREF $TBITMAP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateBitmapIndirect", "struct*", $TBITMAP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEBRUSHINDIRECT($ISTYLE, $IRGB, $IHATCH = 0)
		LOCAL $TLOGBRUSH = DLLSTRUCTCREATE($TAGLOGBRUSH)
		DLLSTRUCTSETDATA($TLOGBRUSH, 1, $ISTYLE)
		DLLSTRUCTSETDATA($TLOGBRUSH, 2, __RGB($IRGB))
		DLLSTRUCTSETDATA($TLOGBRUSH, 3, $IHATCH)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateBrushIndirect", "struct*", $TLOGBRUSH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATECOLORADJUSTMENT($IFLAGS = 0, $IILLUMINANT = 0, $IGAMMAR = 10000, $IGAMMAG = 10000, $IGAMMAB = 10000, $IBLACK = 0, $IWHITE = 10000, $ICONTRAST = 0, $IBRIGHTNESS = 0, $ICOLORFULNESS = 0, $ITINT = 0)
		LOCAL $TCA = DLLSTRUCTCREATE($TAGCOLORADJUSTMENT)
		DLLSTRUCTSETDATA($TCA, 1, DLLSTRUCTGETSIZE($TCA))
		DLLSTRUCTSETDATA($TCA, 2, $IFLAGS)
		DLLSTRUCTSETDATA($TCA, 3, $IILLUMINANT)
		DLLSTRUCTSETDATA($TCA, 4, $IGAMMAR)
		DLLSTRUCTSETDATA($TCA, 5, $IGAMMAG)
		DLLSTRUCTSETDATA($TCA, 6, $IGAMMAB)
		DLLSTRUCTSETDATA($TCA, 7, $IBLACK)
		DLLSTRUCTSETDATA($TCA, 8, $IWHITE)
		DLLSTRUCTSETDATA($TCA, 9, $ICONTRAST)
		DLLSTRUCTSETDATA($TCA, 10, $IBRIGHTNESS)
		DLLSTRUCTSETDATA($TCA, 11, $ICOLORFULNESS)
		DLLSTRUCTSETDATA($TCA, 12, $ITINT)
		RETURN $TCA
	ENDFUNC
	FUNC _WINAPI_CREATECOMPATIBLEBITMAPEX($HDC, $IWIDTH, $IHEIGHT, $IRGB)
		LOCAL $HBRUSH = _WINAPI_CREATEBRUSHINDIRECT(0, $IRGB)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		LOCAL $HDESTDC = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $HDC, "int", $IWIDTH, "int", $IHEIGHT)
		LOCAL $HBMP = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HBMP)
		LOCAL $HDESTSV = $ACALL[0]
		LOCAL $TRECT = _WINAPI_CREATERECTEX(0, 0, $IWIDTH, $IHEIGHT)
		LOCAL $IERROR = 0
		$ACALL = DLLCALL("user32.dll", "int", "FillRect", "handle", $HDESTDC, "struct*", $TRECT, "handle", $HBRUSH)
		IF @ERROR OR NOT $ACALL[0] THEN
			$IERROR = @ERROR + 10
			_WINAPI_DELETEOBJECT($HBMP)
		ENDIF
		_WINAPI_DELETEOBJECT($HBRUSH)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HDESTSV)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HDESTDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $HBMP
	ENDFUNC
	FUNC _WINAPI_CREATEDIBITMAP($HDC, BYREF $TBITMAPINFO, $IUSAGE, $PBITS = 0)
		LOCAL $IINIT = 0
		IF $PBITS THEN
			$IINIT = 4
		ENDIF
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateDIBitmap", "handle", $HDC, "struct*", $TBITMAPINFO, "dword", $IINIT, "struct*", $PBITS, "struct*", $TBITMAPINFO, "uint", $IUSAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEELLIPTICRGN($TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateEllipticRgnIndirect", "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEENHMETAFILE($HDC = 0, $TRECT = 0, $BPIXELS = FALSE, $SFILEPATH = "", $SDESCRIPTION = "")
		IF NOT STRINGSTRIPWS($SFILEPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SFILEPATH = NULL
		LOCAL $TDATA = 0, $ADATA = STRINGSPLIT($SDESCRIPTION, "|", $STR_NOCOUNT)
		IF UBOUND($ADATA) < 2 THEN
			REDIM $ADATA[2]
			$ADATA[1] = ""
		ENDIF
		FOR $I = 0 TO 1
			$ADATA[$I] = STRINGSTRIPWS($ADATA[$I], $STR_STRIPLEADING + $STR_STRIPTRAILING)
		NEXT
		IF($ADATA[0]) OR($ADATA[1]) THEN
			$TDATA = _WINAPI_ARRAYTOSTRUCT($ADATA)
		ENDIF
		LOCAL $IXP, $IYP, $IXM, $IYM, $HREF = 0
		IF $BPIXELS AND(ISDLLSTRUCT($TRECT)) THEN
			IF NOT $HDC THEN
				$HREF = _WINAPI_GETDC(0)
			ENDIF
			$IXP = _WINAPI_GETDEVICECAPS($HREF, 8)
			$IYP = _WINAPI_GETDEVICECAPS($HREF, 10)
			$IXM = _WINAPI_GETDEVICECAPS($HREF, 4)
			$IYM = _WINAPI_GETDEVICECAPS($HREF, 6)
			IF $HREF THEN
				_WINAPI_RELEASEDC(0, $HREF)
			ENDIF
			FOR $I = 1 TO 3 STEP 2
				DLLSTRUCTSETDATA($TRECT, $I, ROUND(DLLSTRUCTGETDATA($TRECT, $I) * $IXM / $IXP * 100))
			NEXT
			FOR $I = 2 TO 4 STEP 2
				DLLSTRUCTSETDATA($TRECT, $I, ROUND(DLLSTRUCTGETDATA($TRECT, $I) * $IYM / $IYP * 100))
			NEXT
		ENDIF
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateEnhMetaFileW", "handle", $HDC, "wstr", $SFILEPATH, "struct*", $TRECT, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEFONTEX($IHEIGHT, $IWIDTH = 0, $IESCAPEMENT = 0, $IORIENTATION = 0, $IWEIGHT = 400, $BITALIC = FALSE, $BUNDERLINE = FALSE, $BSTRIKEOUT = FALSE, $ICHARSET = 1, $IOUTPRECISION = 0, $ICLIPPRECISION = 0, $IQUALITY = 0, $IPITCHANDFAMILY = 0, $SFACENAME = "", $ISTYLE = 0)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateFontW", "int", $IHEIGHT, "int", $IWIDTH, "int", $IESCAPEMENT, "int", $IORIENTATION, "int", $IWEIGHT, "dword", $BITALIC, "dword", $BUNDERLINE, "dword", $BSTRIKEOUT, "dword", $ICHARSET, "dword", $IOUTPRECISION, "dword", $ICLIPPRECISION, "dword", $IQUALITY, "dword", $IPITCHANDFAMILY, "wstr", _WINAPI_GETFONTNAME($SFACENAME, $ISTYLE, $ICHARSET))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATENULLRGN()
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateRectRgn", "int", 0, "int", 0, "int", 0, "int", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEPEN($IPENSTYLE, $IWIDTH, $ICOLOR)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreatePen", "int", $IPENSTYLE, "int", $IWIDTH, "INT", $ICOLOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEPOLYGONRGN(CONST BYREF $APOINT, $ISTART = 0, $IEND = -1, $IMODE = 1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "int[2];"
		NEXT
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TDATA, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
			$ICOUNT += 1
		NEXT
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreatePolygonRgn", "struct*", $TDATA, "int", $ICOUNT - 1, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATERECTRGNINDIRECT($TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "CreateRectRgnIndirect", "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATESOLIDBITMAP($HWND, $ICOLOR, $IWIDTH, $IHEIGHT, $BRGB = 1)
		LOCAL $HDC = _WINAPI_GETDC($HWND)
		LOCAL $HDESTDC = _WINAPI_CREATECOMPATIBLEDC($HDC)
		LOCAL $HBITMAP = _WINAPI_CREATECOMPATIBLEBITMAP($HDC, $IWIDTH, $IHEIGHT)
		LOCAL $HOLD = _WINAPI_SELECTOBJECT($HDESTDC, $HBITMAP)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLSTRUCTSETDATA($TRECT, 1, 0)
		DLLSTRUCTSETDATA($TRECT, 2, 0)
		DLLSTRUCTSETDATA($TRECT, 3, $IWIDTH)
		DLLSTRUCTSETDATA($TRECT, 4, $IHEIGHT)
		IF $BRGB THEN
			$ICOLOR = BITOR(BITAND($ICOLOR, 65280), BITSHIFT(BITAND($ICOLOR, 255), -16), BITSHIFT(BITAND($ICOLOR, 16711680), 16))
		ENDIF
		LOCAL $HBRUSH = _WINAPI_CREATESOLIDBRUSH($ICOLOR)
		IF NOT _WINAPI_FILLRECT($HDESTDC, $TRECT, $HBRUSH) THEN
			_WINAPI_DELETEOBJECT($HBITMAP)
			$HBITMAP = 0
		ENDIF
		_WINAPI_DELETEOBJECT($HBRUSH)
		_WINAPI_RELEASEDC($HWND, $HDC)
		_WINAPI_SELECTOBJECT($HDESTDC, $HOLD)
		_WINAPI_DELETEDC($HDESTDC)
		IF NOT $HBITMAP THEN RETURN SETERROR(1, 0, 0)
		RETURN $HBITMAP
	ENDFUNC
	FUNC _WINAPI_CREATETRANSFORM($NM11 = 1, $NM12 = 0, $NM21 = 0, $NM22 = 1, $NDX = 0, $NDY = 0)
		LOCAL $TXFORM = DLLSTRUCTCREATE($TAGXFORM)
		DLLSTRUCTSETDATA($TXFORM, 1, $NM11)
		DLLSTRUCTSETDATA($TXFORM, 2, $NM12)
		DLLSTRUCTSETDATA($TXFORM, 3, $NM21)
		DLLSTRUCTSETDATA($TXFORM, 4, $NM22)
		DLLSTRUCTSETDATA($TXFORM, 5, $NDX)
		DLLSTRUCTSETDATA($TXFORM, 6, $NDY)
		RETURN $TXFORM
	ENDFUNC
	FUNC _WINAPI_DELETEENHMETAFILE($HEMF)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "DeleteEnhMetaFile", "handle", $HEMF)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DPTOLP($HDC, BYREF $TPOINT, $ICOUNT = 1)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "DPtoLP", "handle", $HDC, "struct*", $TPOINT, "int", $ICOUNT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAWANIMATEDRECTS($HWND, $TRECTFROM, $TRECTTO)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DrawAnimatedRects", "hwnd", $HWND, "int", 3, "struct*", $TRECTFROM, "struct*", $TRECTTO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAWBITMAP($HDC, $IX, $IY, $HBITMAP, $IROP = 13369376)
		LOCAL $TOBJ = DLLSTRUCTCREATE($TAGBITMAP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetObject", "handle", $HBITMAP, "int", DLLSTRUCTGETSIZE($TOBJ), "struct*", $TOBJ)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		$ACALL = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", 0)
		LOCAL $_HDC = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $_HDC)
		LOCAL $HSRCDC = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HSRCDC, "handle", $HBITMAP)
		LOCAL $HSRCSV = $ACALL[0]
		LOCAL $IERROR = 0
		$ACALL = DLLCALL("gdi32.dll", "int", "BitBlt", "hwnd", $HDC, "int", $IX, "int", $IY, "int", DLLSTRUCTGETDATA($TOBJ, "bmWidth"), "int", DLLSTRUCTGETDATA($TOBJ, "bmHeight"), "hwnd", $HSRCDC, "int", 0, "int", 0, "int", $IROP)
		IF @ERROR OR NOT $ACALL[0] THEN
			$IERROR = @ERROR + 1
		ENDIF
		DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $_HDC)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HSRCDC, "handle", $HSRCSV)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HSRCDC)
		IF $IERROR THEN RETURN SETERROR(10, 0, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAWFOCUSRECT($HDC, $TRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DrawFocusRect", "handle", $HDC, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAWLINE($HDC, $IX1, $IY1, $IX2, $IY2)
		_WINAPI_MOVETO($HDC, $IX1, $IY1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		_WINAPI_LINETO($HDC, $IX2, $IY2)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		RETURN TRUE
	ENDFUNC
	FUNC _WINAPI_DRAWSHADOWTEXT($HDC, $STEXT, $IRGBTEXT, $IRGBSHADOW, $IXOFFSET = 0, $IYOFFSET = 0, $TRECT = 0, $IFLAGS = 0)
		LOCAL $ACALL
		IF NOT ISDLLSTRUCT($TRECT) THEN
			$TRECT = DLLSTRUCTCREATE($TAGRECT)
			$ACALL = DLLCALL("user32.dll", "bool", "GetClientRect", "hwnd", _WINAPI_WINDOWFROMDC($HDC), "struct*", $TRECT)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			IF NOT $ACALL[0] THEN RETURN SETERROR(10, 0, 0)
		ENDIF
		$ACALL = DLLCALL("comctl32.dll", "int", "DrawShadowText", "handle", $HDC, "wstr", $STEXT, "uint", -1, "struct*", $TRECT, "dword", $IFLAGS, "int", __RGB($IRGBTEXT), "int", __RGB($IRGBSHADOW), "int", $IXOFFSET, "int", $IYOFFSET)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DWMDEFWINDOWPROC($HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "bool", "DwmDefWindowProc", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM, "lresult*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[5]
	ENDFUNC
	FUNC _WINAPI_DWMENABLEBLURBEHINDWINDOW($HWND, $BENABLE = TRUE, $BTRANSITION = FALSE, $HRGN = 0)
		LOCAL $TBLURBEHIND = DLLSTRUCTCREATE("dword;bool;handle;bool")
		LOCAL $IFLAGS = 0
		IF $HRGN THEN
			$IFLAGS += 2
			DLLSTRUCTSETDATA($TBLURBEHIND, 3, $HRGN)
		ENDIF
		DLLSTRUCTSETDATA($TBLURBEHIND, 1, BITOR($IFLAGS, 5))
		DLLSTRUCTSETDATA($TBLURBEHIND, 2, $BENABLE)
		DLLSTRUCTSETDATA($TBLURBEHIND, 4, $BTRANSITION)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmEnableBlurBehindWindow", "hwnd", $HWND, "struct*", $TBLURBEHIND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMENABLECOMPOSITION($BENABLE)
		IF $BENABLE THEN $BENABLE = 1
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmEnableComposition", "uint", $BENABLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMEXTENDFRAMEINTOCLIENTAREA($HWND, $TMARGINS = 0)
		IF NOT ISDLLSTRUCT($TMARGINS) THEN
			$TMARGINS = _WINAPI_CREATEMARGINS(-1, -1, -1, -1)
		ENDIF
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmExtendFrameIntoClientArea", "hwnd", $HWND, "struct*", $TMARGINS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMGETCOLORIZATIONCOLOR()
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmGetColorizationColor", "dword*", 0, "bool*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN SETEXTENDED($ACALL[2], $ACALL[1])
	ENDFUNC
	FUNC _WINAPI_DWMGETCOLORIZATIONPARAMETERS()
		LOCAL $TDWMCP = DLLSTRUCTCREATE($TAGDWM_COLORIZATION_PARAMETERS)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "uint", 127, "struct*", $TDWMCP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $TDWMCP
	ENDFUNC
	FUNC _WINAPI_DWMGETWINDOWATTRIBUTE($HWND, $IATTRIBUTE)
		LOCAL $TAGSTRUCT
		SWITCH $IATTRIBUTE
			CASE 5, 9
				$TAGSTRUCT = $TAGRECT
			CASE 1
				$TAGSTRUCT = "uint"
			CASE ELSE
				RETURN SETERROR(11, 0, 0)
		ENDSWITCH
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $HWND, "dword", $IATTRIBUTE, "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		SWITCH $IATTRIBUTE
			CASE 1
				RETURN DLLSTRUCTGETDATA($TDATA, 1)
			CASE ELSE
				RETURN $TDATA
		ENDSWITCH
	ENDFUNC
	FUNC _WINAPI_DWMINVALIDATEICONICBITMAPS($HWND)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmInvalidateIconicBitmaps", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMISCOMPOSITIONENABLED()
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmIsCompositionEnabled", "bool*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_DWMQUERYTHUMBNAILSOURCESIZE($HTHUMBNAIL)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmQueryThumbnailSourceSize", "handle", $HTHUMBNAIL, "struct*", $TSIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_DWMREGISTERTHUMBNAIL($HDESTINATION, $HSOURCE)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmRegisterThumbnail", "hwnd", $HDESTINATION, "hwnd", $HSOURCE, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_DWMSETCOLORIZATIONPARAMETERS($TDWMCP)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "uint", 131, "struct*", $TDWMCP, "uint", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMSETICONICLIVEPREVIEWBITMAP($HWND, $HBITMAP, $BFRAME = FALSE, $TCLIENT = 0)
		LOCAL $IFLAGS
		IF $BFRAME THEN
			$IFLAGS = 1
		ELSE
			$IFLAGS = 0
		ENDIF
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "uint", "DwmSetIconicLivePreviewBitmap", "hwnd", $HWND, "handle", $HBITMAP, "struct*", $TCLIENT, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMSETICONICTHUMBNAIL($HWND, $HBITMAP, $BFRAME = FALSE)
		LOCAL $IFLAGS
		IF $BFRAME THEN
			$IFLAGS = 1
		ELSE
			$IFLAGS = 0
		ENDIF
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmSetIconicThumbnail", "hwnd", $HWND, "handle", $HBITMAP, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMSETWINDOWATTRIBUTE($HWND, $IATTRIBUTE, $IDATA)
		SWITCH $IATTRIBUTE
			CASE 2, 3, 4, 6, 7, 8, 10, 11, 12
			CASE ELSE
				RETURN SETERROR(1, 0, 0)
		ENDSWITCH
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmSetWindowAttribute", "hwnd", $HWND, "dword", $IATTRIBUTE, "dword*", $IDATA, "dword", 4)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMUNREGISTERTHUMBNAIL($HTHUMBNAIL)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmUnregisterThumbnail", "handle", $HTHUMBNAIL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMUPDATETHUMBNAILPROPERTIES($HTHUMBNAIL, $BVISIBLE = TRUE, $BCLIENTAREAONLY = FALSE, $IOPACITY = 255, $TRECTDEST = 0, $TRECTSRC = 0)
		LOCAL CONST $TAGDWM_THUMBNAIL_PROPERTIES = "struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct"
		LOCAL $TTHUMBNAILPROPERTIES = DLLSTRUCTCREATE($TAGDWM_THUMBNAIL_PROPERTIES)
		LOCAL $TSIZE, $IFLAGS = 0
		IF NOT ISDLLSTRUCT($TRECTDEST) THEN
			$TSIZE = _WINAPI_DWMQUERYTHUMBNAILSOURCESIZE($HTHUMBNAIL)
			IF @ERROR THEN
				RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			ENDIF
			$TRECTDEST = _WINAPI_CREATERECTEX(0, 0, DLLSTRUCTGETDATA($TSIZE, 1), DLLSTRUCTGETDATA($TSIZE, 2))
		ENDIF
		FOR $I = 1 TO 4
			DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 2, DLLSTRUCTGETDATA($TRECTDEST, $I), $I)
		NEXT
		IF ISDLLSTRUCT($TRECTSRC) THEN
			$IFLAGS += 2
			FOR $I = 1 TO 4
				DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 3, DLLSTRUCTGETDATA($TRECTSRC, $I), $I)
			NEXT
		ENDIF
		DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 1, BITOR($IFLAGS, 29))
		DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 4, $IOPACITY)
		DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 5, $BVISIBLE)
		DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 6, $BCLIENTAREAONLY)
		LOCAL $ACALL = DLLCALL("dwmapi.dll", "long", "DwmUpdateThumbnailProperties", "handle", $HTHUMBNAIL, "struct*", $TTHUMBNAILPROPERTIES)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ELLIPSE($HDC, $TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "Ellipse", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENDPAINT($HWND, BYREF $TPAINTSTRUCT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EndPaint", "hwnd", $HWND, "struct*", $TPAINTSTRUCT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENDPATH($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "EndPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENUMDISPLAYMONITORS($HDC = 0, $TRECT = 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumDisplayMonitorsProc", "bool", "handle;handle;ptr;lparam")
		DIM $__G_VENUM[101][2] = [[0]]
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EnumDisplayMonitors", "handle", $HDC, "struct*", $TRECT, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", 0)
		IF @ERROR OR NOT $ACALL[0] OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMDISPLAYSETTINGS($SDEVICE, $IMODE)
		IF NOT STRINGSTRIPWS($SDEVICE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SDEVICE = NULL
		LOCAL $TDEVMODE = DLLSTRUCTCREATE($TAGDEVMODE_DISPLAY)
		DLLSTRUCTSETDATA($TDEVMODE, "Size", DLLSTRUCTGETSIZE($TDEVMODE))
		DLLSTRUCTSETDATA($TDEVMODE, "DriverExtra", 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EnumDisplaySettingsW", "wstr", $SDEVICE, "dword", $IMODE, "struct*", $TDEVMODE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[5]
		$ARET[0] = DLLSTRUCTGETDATA($TDEVMODE, "PelsWidth")
		$ARET[1] = DLLSTRUCTGETDATA($TDEVMODE, "PelsHeight")
		$ARET[2] = DLLSTRUCTGETDATA($TDEVMODE, "BitsPerPel")
		$ARET[3] = DLLSTRUCTGETDATA($TDEVMODE, "DisplayFrequency")
		$ARET[4] = DLLSTRUCTGETDATA($TDEVMODE, "DisplayFlags")
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_ENUMFONTFAMILIES($HDC = 0, $SFACENAME = "", $ICHARSET = 1, $IFONTTYPE = 7, $SPATTERN = "", $BEXCLUDE = FALSE)
		LOCAL $TLOGFONT = DLLSTRUCTCREATE($TAGLOGFONT)
		LOCAL $TPATTERN = DLLSTRUCTCREATE("uint;uint;ptr;wchar[" & (STRINGLEN($SPATTERN) + 1) & "]")
		DLLSTRUCTSETDATA($TPATTERN, 1, $IFONTTYPE)
		IF NOT $SPATTERN THEN
			DLLSTRUCTSETDATA($TPATTERN, 2, 0)
			DLLSTRUCTSETDATA($TPATTERN, 3, 0)
		ELSE
			DLLSTRUCTSETDATA($TPATTERN, 2, $BEXCLUDE)
			DLLSTRUCTSETDATA($TPATTERN, 3, DLLSTRUCTGETPTR($TPATTERN, 4))
			DLLSTRUCTSETDATA($TPATTERN, 4, $SPATTERN)
		ENDIF
		DLLSTRUCTSETDATA($TLOGFONT, 9, $ICHARSET)
		DLLSTRUCTSETDATA($TLOGFONT, 13, 0)
		DLLSTRUCTSETDATA($TLOGFONT, 14, STRINGLEFT($SFACENAME, 31))
		LOCAL $HCDC
		IF NOT $HDC THEN
			$HCDC = _WINAPI_CREATECOMPATIBLEDC(0)
		ELSE
			$HCDC = $HDC
		ENDIF
		DIM $__G_VENUM[101][8] = [[0]]
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumFontFamiliesProc", "int", "ptr;ptr;dword;PTR")
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $HCDC, "struct*", $TLOGFONT, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "struct*", $TPATTERN, "dword", 0)
		IF @ERROR OR NOT $ACALL[0] OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF NOT $HDC THEN
			_WINAPI_DELETEDC($HCDC)
		ENDIF
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_EQUALRECT($TRECT1, $TRECT2)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EqualRect", "struct*", $TRECT1, "struct*", $TRECT2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_EQUALRGN($HRGN1, $HRGN2)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "EqualRgn", "handle", $HRGN1, "handle", $HRGN2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_EXCLUDECLIPRECT($HDC, $TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "ExcludeClipRect", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_EXTCREATEPEN($IPENSTYLE, $IWIDTH, $IBRUSHSTYLE, $IRGB, $IHATCH = 0, $AUSERSTYLE = 0, $ISTART = 0, $IEND = -1)
		LOCAL $ICOUNT = 0, $TSTYLE = 0
		IF BITAND($IPENSTYLE, 255) = 7 THEN
			IF __CHECKERRORARRAYBOUNDS($AUSERSTYLE, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$TSTYLE = DLLSTRUCTCREATE("dword[" & ($IEND - $ISTART + 1) & "]")
			FOR $I = $ISTART TO $IEND
				DLLSTRUCTSETDATA($TSTYLE, 1, $AUSERSTYLE[$I], $ICOUNT + 1)
				$ICOUNT += 1
			NEXT
		ENDIF
		LOCAL $TLOGBRUSH = DLLSTRUCTCREATE($TAGLOGBRUSH)
		DLLSTRUCTSETDATA($TLOGBRUSH, 1, $IBRUSHSTYLE)
		DLLSTRUCTSETDATA($TLOGBRUSH, 2, __RGB($IRGB))
		DLLSTRUCTSETDATA($TLOGBRUSH, 3, $IHATCH)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "ExtCreatePen", "dword", $IPENSTYLE, "dword", $IWIDTH, "struct*", $TLOGBRUSH, "dword", $ICOUNT, "struct*", $TSTYLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_EXTCREATEREGION($TRGNDATA, $TXFORM = 0)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "ExtCreateRegion", "struct*", $TXFORM, "dword", DLLSTRUCTGETSIZE($TRGNDATA), "struct*", $TRGNDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_EXTFLOODFILL($HDC, $IX, $IY, $IRGB, $ITYPE = 0)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "ExtFloodFill", "handle", $HDC, "int", $IX, "int", $IY, "dword", __RGB($IRGB), "uint", $ITYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_EXTSELECTCLIPRGN($HDC, $HRGN, $IMODE = 5)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "ExtSelectClipRgn", "handle", $HDC, "handle", $HRGN, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FILLPATH($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "FillPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FILLRGN($HDC, $HRGN, $HBRUSH)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "FillRgn", "handle", $HDC, "handle", $HRGN, "handle", $HBRUSH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FLATTENPATH($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "FlattenPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FRAMERGN($HDC, $HRGN, $HBRUSH, $IWIDTH, $IHEIGHT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "FrameRgn", "handle", $HDC, "handle", $HRGN, "handle", $HBRUSH, "int", $IWIDTH, "int", $IHEIGHT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GDICOMMENT($HDC, $PBUFFER, $ISIZE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GdiComment", "handle", $HDC, "uint", $ISIZE, "struct*", $PBUFFER)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETARCDIRECTION($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetArcDirection", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF($ACALL[0] < 1) OR($ACALL[0] > 2) THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETBITMAPBITS($HBITMAP, $ISIZE, $PBITS)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "long", "GetBitmapBits", "handle", $HBITMAP, "long", $ISIZE, "struct*", $PBITS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETBITMAPDIMENSIONEX($HBITMAP)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetBitmapDimensionEx", "handle", $HBITMAP, "struct*", $TSIZE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETBKCOLOR($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "dword", "GetBkColor", "handle", $HDC)
		IF @ERROR OR($ACALL[0] = -1) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_GETBOUNDSRECT($HDC, $IFLAGS = 0)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "GetBoundsRect", "handle", $HDC, "struct*", $TRECT, "uint", $IFLAGS)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN SETEXTENDED($ACALL[0], $TRECT)
	ENDFUNC
	FUNC _WINAPI_GETBRUSHORG($HDC)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetBrushOrgEx", "handle", $HDC, "struct*", $TPOINT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETBVALUE($IRGB)
		RETURN BITSHIFT(BITAND(__RGB($IRGB), 16711680), 16)
	ENDFUNC
	FUNC _WINAPI_GETCLIPBOX($HDC, BYREF $TRECT)
		$TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetClipBox", "handle", $HDC, "struct*", $TRECT)
		IF @ERROR OR NOT $ACALL[0] THEN
			$TRECT = 0
			RETURN SETERROR(@ERROR, @EXTENDED, 0)
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCLIPRGN($HDC)
		LOCAL $HRGN = _WINAPI_CREATERECTRGN(0, 0, 0, 0)
		LOCAL $IERROR = 0
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetClipRgn", "handle", $HDC, "handle", $HRGN)
		IF @ERROR OR($ACALL[0] = -1) THEN $IERROR = @ERROR + 10
		IF $IERROR OR NOT $ACALL[0] THEN
			_WINAPI_DELETEOBJECT($HRGN)
			$HRGN = 0
		ENDIF
		RETURN SETERROR($IERROR, 0, $HRGN)
	ENDFUNC
	FUNC _WINAPI_GETCOLORADJUSTMENT($HDC)
		LOCAL $TADJUSTMENT = DLLSTRUCTCREATE($TAGCOLORADJUSTMENT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetColorAdjustment", "handle", $HDC, "struct*", $TADJUSTMENT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TADJUSTMENT
	ENDFUNC
	FUNC _WINAPI_GETCURRENTPOSITION($HDC)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetCurrentPositionEx", "handle", $HDC, "struct*", $TPOINT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETDEVICEGAMMARAMP($HDC, BYREF $ARAMP)
		$ARAMP = 0
		LOCAL $TDATA = DLLSTRUCTCREATE("word[256];word[256];word[256]")
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetDeviceGammaRamp", "handle", $HDC, "struct*", $TDATA)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		DIM $ARAMP[256][3]
		FOR $I = 0 TO 2
			FOR $J = 0 TO 255
				$ARAMP[$J][$I] = DLLSTRUCTGETDATA($TDATA, $I + 1, $J + 1)
			NEXT
		NEXT
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_GETDIBCOLORTABLE($HBITMAP)
		LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HSV = _WINAPI_SELECTOBJECT($HDC, $HBITMAP)
		LOCAL $TPEAK = DLLSTRUCTCREATE("dword[256]")
		LOCAL $IERROR = 0
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "GetDIBColorTable", "handle", $HDC, "uint", 0, "uint", 256, "struct*", $TPEAK)
		IF @ERROR OR NOT $ACALL[0] THEN $IERROR = @ERROR + 10
		_WINAPI_SELECTOBJECT($HDC, $HSV)
		_WINAPI_DELETEDC($HDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("dword[" & $ACALL[0] & "]")
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		_WINAPI_MOVEMEMORY($TDATA, $ACALL[4], 4 * $ACALL[0])
		RETURN SETEXTENDED($ACALL[0], $TDATA)
	ENDFUNC
	FUNC _WINAPI_GETDIBITS($HDC, $HBITMAP, $ISTARTSCAN, $ISCANLINES, $PBITS, $TBI, $IUSAGE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetDIBits", "handle", $HDC, "handle", $HBITMAP, "uint", $ISTARTSCAN, "uint", $ISCANLINES, "struct*", $PBITS, "struct*", $TBI, "uint", $IUSAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "GetEnhMetaFileW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILEBITS($HEMF, BYREF $PBUFFER)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $HEMF, "uint", 0, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 50, @EXTENDED, 0)
		$PBUFFER = __HEAPREALLOC($PBUFFER, $ACALL[0], 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$ACALL = DLLCALL("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $HEMF, "uint", $ACALL[0], "ptr", $PBUFFER)
		IF NOT $ACALL[0] THEN RETURN SETERROR(60, 0, 0)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILEDESCRIPTION($HEMF)
		LOCAL $TDATA = DLLSTRUCTCREATE("wchar[4096]")
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "GetEnhMetaFileDescriptionW", "handle", $HEMF, "uint", 4096, "struct*", $TDATA)
		IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR + 20, $ACALL[0], 0)
		IF NOT $ACALL[0] THEN RETURN 0
		LOCAL $ADATA = _WINAPI_STRUCTTOARRAY($TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET[2]
		FOR $I = 0 TO 1
			IF $ADATA[0] > $I THEN
				$ARET[$I] = $ADATA[$I + 1]
			ELSE
				$ARET[$I] = ""
			ENDIF
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILEDIMENSION($HEMF)
		LOCAL $TENHMETAHEADER = _WINAPI_GETENHMETAFILEHEADER($HEMF)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		DLLSTRUCTSETDATA($TSIZE, 1, ROUND((DLLSTRUCTGETDATA($TENHMETAHEADER, "rcFrame", 3) - DLLSTRUCTGETDATA($TENHMETAHEADER, "rcFrame", 1)) * DLLSTRUCTGETDATA($TENHMETAHEADER, "Device", 1) / DLLSTRUCTGETDATA($TENHMETAHEADER, "Millimeters", 1) / 100))
		DLLSTRUCTSETDATA($TSIZE, 2, ROUND((DLLSTRUCTGETDATA($TENHMETAHEADER, "rcFrame", 4) - DLLSTRUCTGETDATA($TENHMETAHEADER, "rcFrame", 2)) * DLLSTRUCTGETDATA($TENHMETAHEADER, "Device", 2) / DLLSTRUCTGETDATA($TENHMETAHEADER, "Millimeters", 2) / 100))
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILEHEADER($HEMF)
		LOCAL $TENHMETAHEADER = DLLSTRUCTCREATE($TAGENHMETAHEADER)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "GetEnhMetaFileHeader", "handle", $HEMF, "uint", DLLSTRUCTGETSIZE($TENHMETAHEADER), "struct*", $TENHMETAHEADER)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN SETEXTENDED($ACALL[0], $TENHMETAHEADER)
	ENDFUNC
	FUNC _WINAPI_GETFONTNAME($SFACENAME, $ISTYLE = 0, $ICHARSET = 1)
		IF NOT $SFACENAME THEN RETURN SETERROR(1, 0, "")
		LOCAL $IFLAGS = 0
		IF BITAND($ISTYLE, 1) THEN
			$IFLAGS += 32
		ENDIF
		IF BITAND($ISTYLE, 2) THEN
			$IFLAGS += 1
		ENDIF
		IF NOT $IFLAGS THEN
			$IFLAGS = 64
		ENDIF
		LOCAL $TLOGFONT = DLLSTRUCTCREATE($TAGLOGFONT)
		DLLSTRUCTSETDATA($TLOGFONT, 9, $ICHARSET)
		DLLSTRUCTSETDATA($TLOGFONT, 13, 0)
		DLLSTRUCTSETDATA($TLOGFONT, 14, STRINGLEFT($SFACENAME, 31))
		LOCAL $TFN = DLLSTRUCTCREATE("dword;wchar[64]")
		DLLSTRUCTSETDATA($TFN, 1, $IFLAGS)
		DLLSTRUCTSETDATA($TFN, 2, "")
		LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumFontStylesProc", "int", "ptr;ptr;dword;lparam")
		LOCAL $SRET = ""
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $HDC, "struct*", $TLOGFONT, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "struct*", $TFN, "dword", 0)
		IF NOT @ERROR AND NOT $ACALL[0] THEN $SRET = DLLSTRUCTGETDATA($TFN, 2)
		DLLCALLBACKFREE($HENUMPROC)
		_WINAPI_DELETEDC($HDC)
		IF NOT $SRET THEN RETURN SETERROR(2, 0, "")
		RETURN $SRET
	ENDFUNC
	FUNC _WINAPI_GETFONTRESOURCEINFO($SFONT, $BFORCE = FALSE, $IFLAG = DEFAULT)
		IF $IFLAG = DEFAULT THEN
			IF $BFORCE THEN
				IF NOT _WINAPI_ADDFONTRESOURCEEX($SFONT, $FR_NOT_ENUM) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
			ENDIF
			LOCAL $IERROR = 0
			LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetFontResourceInfoW", "wstr", $SFONT, "dword*", 4096, "wstr", "", "dword", 1)
			IF @ERROR OR NOT $ARET[0] THEN $IERROR = @ERROR + 10
			IF $BFORCE THEN
				_WINAPI_REMOVEFONTRESOURCEEX($SFONT, $FR_NOT_ENUM)
			ENDIF
			IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
			RETURN $ARET[3]
		ELSE
			IF NOT FILEEXISTS($SFONT) THEN
				$SFONT = REGREAD("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $SFONT
				IF NOT FILEEXISTS($SFONT) THEN RETURN SETERROR(31, 0, "")
			ENDIF
			LOCAL CONST $HFILE = _WINAPI_CREATEFILE($SFONT, 2, 2, 2)
			IF NOT $HFILE THEN RETURN SETERROR(32, _WINAPI_GETLASTERROR(), "")
			LOCAL CONST $IFILE = FILEGETSIZE($SFONT)
			LOCAL CONST $TBUFFER = DLLSTRUCTCREATE("byte[" & $IFILE + 1 & "]")
			LOCAL CONST $PFILE = DLLSTRUCTGETPTR($TBUFFER)
			LOCAL $IREAD
			_WINAPI_READFILE($HFILE, $PFILE, $IFILE, $IREAD)
			_WINAPI_CLOSEHANDLE($HFILE)
			LOCAL $STTFNAME = _WINAPI_GETFONTMEMORYRESOURCEINFO($PFILE, $IFLAG)
			IF @ERROR THEN
				IF @ERROR = 1 THEN
					$STTFNAME = _WINAPI_GETFONTRESOURCEINFO($SFONT, TRUE)
					RETURN SETERROR(@ERROR, @EXTENDED, $STTFNAME)
				ENDIF
				RETURN SETERROR(33, @ERROR, "")
			ENDIF
			RETURN $STTFNAME
		ENDIF
	ENDFUNC
	FUNC _WINAPI_GETFONTMEMORYRESOURCEINFO($PMEMORY, $IFLAG = 1)
		LOCAL CONST $TAGTT_OFFSET_TABLE = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
		LOCAL CONST $TAGTT_TABLE_DIRECTORY = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
		LOCAL CONST $TAGTT_NAME_TABLE_HEADER = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
		LOCAL CONST $TAGTT_NAME_RECORD = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
		LOCAL $TTTOFFSETTABLE = DLLSTRUCTCREATE($TAGTT_OFFSET_TABLE, $PMEMORY)
		LOCAL $INUMOFTABLES = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTOFFSETTABLE, "uNumOfTables"))
		IF NOT(_WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTOFFSETTABLE, "uMajorVersion")) = 1 AND _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTOFFSETTABLE, "uMinorVersion")) = 0) THEN RETURN SETERROR(1, 0, "")
		LOCAL $ITBLDIRSIZE = DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGTT_TABLE_DIRECTORY))
		LOCAL $BFOUND = FALSE, $IOFFSET, $TTBLDIR
		FOR $I = 0 TO $INUMOFTABLES - 1
			$TTBLDIR = DLLSTRUCTCREATE($TAGTT_TABLE_DIRECTORY, $PMEMORY + DLLSTRUCTGETSIZE($TTTOFFSETTABLE) + $I * $ITBLDIRSIZE)
			IF STRINGLEFT(DLLSTRUCTGETDATA($TTBLDIR, "szTag"), 4) = "name" THEN
				$BFOUND = TRUE
				$IOFFSET = _WINAPI_SWAPDWORD(DLLSTRUCTGETDATA($TTBLDIR, "uOffset"))
				EXITLOOP
			ENDIF
		NEXT
		IF NOT $BFOUND THEN RETURN SETERROR(2, 0, "")
		LOCAL $TNTHEADER = DLLSTRUCTCREATE($TAGTT_NAME_TABLE_HEADER, $PMEMORY + $IOFFSET)
		LOCAL $INTHEADERSIZE = DLLSTRUCTGETSIZE($TNTHEADER)
		LOCAL $INRCOUNT = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TNTHEADER, "uNRCount"))
		LOCAL $ISTORAGEOFFSET = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TNTHEADER, "uStorageOffset"))
		LOCAL $ITTRECORDSIZE = DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGTT_NAME_RECORD))
		LOCAL $TRESULT, $SRESULT, $ISTRINGLENGTH = 0, $ISTRINGOFFSET, $IENCODINGID, $TTTRECORD
		FOR $I = 0 TO $INRCOUNT - 1
			$TTTRECORD = DLLSTRUCTCREATE($TAGTT_NAME_RECORD, $PMEMORY + $IOFFSET + $INTHEADERSIZE + $I * $ITTRECORDSIZE)
			IF @ERROR THEN CONTINUELOOP
			IF _WINAPI_SWAPWORD($TTTRECORD.uNameID) = $IFLAG THEN
				$ISTRINGLENGTH = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTRECORD, "uStringLength"))
				$ISTRINGOFFSET = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTRECORD, "uStringOffset"))
				$IENCODINGID = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTRECORD, "uEncodingID"))
				LOCAL $SWCHAR = "char"
				IF $IENCODINGID = 1 THEN
					$SWCHAR = "word"
					$ISTRINGLENGTH /= 2
				ENDIF
				IF NOT $ISTRINGLENGTH THEN
					$SRESULT = ""
					CONTINUELOOP
				ENDIF
				$TRESULT = DLLSTRUCTCREATE($SWCHAR & " szTTFName[" & $ISTRINGLENGTH & "]", $PMEMORY + $IOFFSET + $ISTRINGOFFSET + $ISTORAGEOFFSET)
				IF $IENCODINGID = 1 THEN
					$SRESULT = ""
					FOR $J = 1 TO $ISTRINGLENGTH
						$SRESULT &= CHRW(_WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TRESULT, 1, $J)))
					NEXT
				ELSE
					$SRESULT = $TRESULT.szTTFName
				ENDIF
				IF STRINGLEN($SRESULT) > 0 THEN EXITLOOP
			ENDIF
		NEXT
		RETURN $SRESULT
	ENDFUNC
	FUNC _WINAPI_GETGLYPHOUTLINE($HDC, $SCHAR, $IFORMAT, BYREF $PBUFFER, $TMAT2 = 0)
		LOCAL $TGM = DLLSTRUCTCREATE($TAGGLYPHMETRICS)
		LOCAL $ACALL, $ILENGTH = 0
		IF NOT ISDLLSTRUCT($TMAT2) THEN
			$TMAT2 = DLLSTRUCTCREATE("short[8]")
			DLLSTRUCTSETDATA($TMAT2, 1, 1, 2)
			DLLSTRUCTSETDATA($TMAT2, 1, 1, 8)
		ENDIF
		IF $IFORMAT THEN
			$ACALL = DLLCALL("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $HDC, "uint", ASCW($SCHAR), "uint", $IFORMAT, "struct*", $TGM, "dword", 0, "ptr", 0, "struct*", $TMAT2)
			IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$ILENGTH = $ACALL[0]
			$PBUFFER = __HEAPREALLOC($PBUFFER, $ILENGTH, 1)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		ENDIF
		$ACALL = DLLCALL("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $HDC, "uint", ASCW($SCHAR), "uint", $IFORMAT, "struct*", $TGM, "dword", $ILENGTH, "ptr", $PBUFFER, "struct*", $TMAT2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = 4294967295 THEN RETURN SETERROR(10, -1, 0)
		RETURN SETEXTENDED($ILENGTH, $TGM)
	ENDFUNC
	FUNC _WINAPI_GETGRAPHICSMODE($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetGraphicsMode", "handle", $HDC)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETGVALUE($IRGB)
		RETURN BITSHIFT(BITAND(__RGB($IRGB), 65280), 8)
	ENDFUNC
	FUNC _WINAPI_GETMAPMODE($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetMapMode", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETMONITORINFO($HMONITOR)
		LOCAL $TMIEX = DLLSTRUCTCREATE("dword;long[4];long[4];dword;wchar[32]")
		DLLSTRUCTSETDATA($TMIEX, 1, DLLSTRUCTGETSIZE($TMIEX))
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetMonitorInfoW", "handle", $HMONITOR, "struct*", $TMIEX)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[4]
		FOR $I = 0 TO 1
			$ARET[$I] = DLLSTRUCTCREATE($TAGRECT)
			_WINAPI_MOVEMEMORY($ARET[$I], DLLSTRUCTGETPTR($TMIEX, $I + 2), 16)
		NEXT
		$ARET[3] = DLLSTRUCTGETDATA($TMIEX, 5)
		SWITCH DLLSTRUCTGETDATA($TMIEX, 4)
			CASE 1
				$ARET[2] = 1
			CASE ELSE
				$ARET[2] = 0
		ENDSWITCH
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETOUTLINETEXTMETRICS($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $HDC, "uint", 0, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & $ACALL[0] & "]")
		LOCAL $TOLTM = DLLSTRUCTCREATE($TAGOUTLINETEXTMETRIC, DLLSTRUCTGETPTR($TDATA))
		$ACALL = DLLCALL("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $HDC, "uint", $ACALL[0], "struct*", $TDATA)
		IF NOT $ACALL[0] THEN RETURN SETERROR(20, 0, 0)
		RETURN $TOLTM
	ENDFUNC
	FUNC _WINAPI_GETPIXEL($HDC, $IX, $IY)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "dword", "GetPixel", "handle", $HDC, "int", $IX, "int", $IY)
		IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_GETPOLYFILLMODE($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetPolyFillMode", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETPOSFROMRECT($TRECT)
		LOCAL $ARET[4]
		FOR $I = 0 TO 3
			$ARET[$I] = DLLSTRUCTGETDATA($TRECT, $I + 1)
			IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		NEXT
		FOR $I = 2 TO 3
			$ARET[$I] -= $ARET[$I - 2]
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETREGIONDATA($HRGN, BYREF $TRGNDATA)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "dword", "GetRegionData", "handle", $HRGN, "dword", 0, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN
			$TRGNDATA = 0
			RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		ENDIF
		$TRGNDATA = DLLSTRUCTCREATE($TAGRGNDATAHEADER)
		LOCAL $IRECTSIZE = $ACALL[0] - DLLSTRUCTGETSIZE($TRGNDATA)
		IF $IRECTSIZE > 0 THEN $TRGNDATA = DLLSTRUCTCREATE($TAGRGNDATAHEADER & ";byte[" & $IRECTSIZE & "]")
		$ACALL = DLLCALL("gdi32.dll", "dword", "GetRegionData", "handle", $HRGN, "dword", $ACALL[0], "struct*", $TRGNDATA)
		IF NOT $ACALL[0] THEN $TRGNDATA = 0
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETRGNBOX($HRGN, BYREF $TRECT)
		$TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetRgnBox", "handle", $HRGN, "struct*", $TRECT)
		IF @ERROR OR NOT $ACALL[0] THEN
			$TRECT = 0
			RETURN SETERROR(@ERROR, @EXTENDED, 0)
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETROP2($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetROP2", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETRVALUE($IRGB)
		RETURN BITAND(__RGB($IRGB), 255)
	ENDFUNC
	FUNC _WINAPI_GETSTRETCHBLTMODE($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetStretchBltMode", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETTABBEDTEXTEXTENT($HDC, $STEXT, $ATAB = 0, $ISTART = 0, $IEND = -1)
		LOCAL $ITAB, $ICOUNT
		IF NOT ISARRAY($ATAB) THEN
			IF $ATAB THEN
				$ITAB = $ATAB
				DIM $ATAB[1] = [$ITAB]
				$ISTART = 0
				$IEND = 0
				$ICOUNT = 1
			ELSE
				$ICOUNT = 0
			ENDIF
		ELSE
			$ICOUNT = 1
		ENDIF
		LOCAL $TTAB = 0
		IF $ICOUNT THEN
			IF __CHECKERRORARRAYBOUNDS($ATAB, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$ICOUNT = $IEND - $ISTART + 1
			$TTAB = DLLSTRUCTCREATE("uint[" & $ICOUNT & "]")
			$ITAB = 1
			FOR $I = $ISTART TO $IEND
				DLLSTRUCTSETDATA($TTAB, 1, $ATAB[$I], $ITAB)
				$ITAB += 1
			NEXT
		ENDIF
		LOCAL $ACALL = DLLCALL("user32.dll", "dword", "GetTabbedTextExtentW", "handle", $HDC, "wstr", $STEXT, "int", STRINGLEN($STEXT), "int", $ICOUNT, "struct*", $TTAB)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		RETURN _WINAPI_CREATESIZE(_WINAPI_LOWORD($ACALL[0]), _WINAPI_HIWORD($ACALL[0]))
	ENDFUNC
	FUNC _WINAPI_GETTEXTALIGN($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "GetTextAlign", "handle", $HDC)
		IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETTEXTCHARACTEREXTRA($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetTextCharacterExtra", "handle", $HDC)
		IF @ERROR OR($ACALL[0] = 134217728) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETTEXTFACE($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetTextFaceW", "handle", $HDC, "int", 2048, "wstr", "")
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_GETUDFCOLORMODE()
		RETURN NUMBER($__G_IRGBMODE)
	ENDFUNC
	FUNC _WINAPI_GETUPDATERECT($HWND, $BERASE = TRUE)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetUpdateRect", "hwnd", $HWND, "struct*", $TRECT, "bool", $BERASE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETUPDATERGN($HWND, $HRGN, $BERASE = TRUE)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "GetUpdateRgn", "hwnd", $HWND, "handle", $HRGN, "bool", $BERASE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWEXT($HDC)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetWindowExtEx", "handle", $HDC, "struct*", $TSIZE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETWINDOWORG($HDC)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetWindowOrgEx", "handle", $HDC, "struct*", $TPOINT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETWINDOWRGNBOX($HWND, BYREF $TRECT)
		$TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "GetWindowRgnBox", "hwnd", $HWND, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETWORLDTRANSFORM($HDC)
		LOCAL $TXFORM = DLLSTRUCTCREATE($TAGXFORM)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GetWorldTransform", "handle", $HDC, "struct*", $TXFORM)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TXFORM
	ENDFUNC
	FUNC _WINAPI_GRADIENTFILL($HDC, CONST BYREF $AVERTEX, $ISTART = 0, $IEND = -1, $BROTATE = FALSE)
		IF __CHECKERRORARRAYBOUNDS($AVERTEX, $ISTART, $IEND, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF UBOUND($AVERTEX, $UBOUND_COLUMNS) < 3 THEN RETURN SETERROR(13, 0, 0)
		LOCAL $IPOINT = $IEND - $ISTART + 1
		IF $IPOINT > 3 THEN
			$IEND = $ISTART + 2
			$IPOINT = 3
		ENDIF
		LOCAL $IMODE
		SWITCH $IPOINT
			CASE 2
				$IMODE = NUMBER(NOT $BROTATE)
			CASE 3
				$IMODE = 2
			CASE ELSE
				RETURN SETERROR(15, 0, 0)
		ENDSWITCH
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "ushort[8];"
		NEXT
		LOCAL $TVERTEX = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 1
		LOCAL $TGRADIENT = DLLSTRUCTCREATE("ulong[" & $IPOINT & "]")
		FOR $I = $ISTART TO $IEND
			DLLSTRUCTSETDATA($TGRADIENT, 1, $ICOUNT - 1, $ICOUNT)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, _WINAPI_LOWORD($AVERTEX[$I][0]), 1)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, _WINAPI_HIWORD($AVERTEX[$I][0]), 2)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, _WINAPI_LOWORD($AVERTEX[$I][1]), 3)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, _WINAPI_HIWORD($AVERTEX[$I][1]), 4)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, BITSHIFT(_WINAPI_GETRVALUE($AVERTEX[$I][2]), -8), 5)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, BITSHIFT(_WINAPI_GETGVALUE($AVERTEX[$I][2]), -8), 6)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, BITSHIFT(_WINAPI_GETBVALUE($AVERTEX[$I][2]), -8), 7)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, 0, 8)
			$ICOUNT += 1
		NEXT
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GdiGradientFill", "handle", $HDC, "struct*", $TVERTEX, "ulong", $IPOINT, "struct*", $TGRADIENT, "ulong", 1, "ulong", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_INFLATERECT(BYREF $TRECT, $IDX, $IDY)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "InflateRect", "struct*", $TRECT, "int", $IDX, "int", $IDY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_INTERSECTCLIPRECT($HDC, $TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "IntersectClipRect", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_INTERSECTRECT($TRECT1, $TRECT2)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IntersectRect", "struct*", $TRECT, "struct*", $TRECT1, "struct*", $TRECT2)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_INVALIDATERGN($HWND, $HRGN = 0, $BERASE = TRUE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "InvalidateRgn", "hwnd", $HWND, "handle", $HRGN, "bool", $BERASE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_INVERTANDBITMAP($HBITMAP, $BDELETE = FALSE)
		LOCAL $TBITMAP = DLLSTRUCTCREATE($TAGBITMAP)
		IF NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($TBITMAP), $TBITMAP) OR(DLLSTRUCTGETDATA($TBITMAP, "bmBitsPixel") <> 1) THEN
			RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		ENDIF
		LOCAL $HRESULT = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($TBITMAP, "bmWidth"), DLLSTRUCTGETDATA($TBITMAP, "bmHeight"), 1)
		IF NOT $HRESULT THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $HSRCDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HSRCSV = _WINAPI_SELECTOBJECT($HSRCDC, $HBITMAP)
		LOCAL $HDSTDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HDSTSV = _WINAPI_SELECTOBJECT($HDSTDC, $HRESULT)
		_WINAPI_BITBLT($HDSTDC, 0, 0, DLLSTRUCTGETDATA($TBITMAP, "bmWidth"), DLLSTRUCTGETDATA($TBITMAP, "bmHeight"), $HSRCDC, 0, 0, 3342344)
		_WINAPI_SELECTOBJECT($HSRCDC, $HSRCSV)
		_WINAPI_DELETEDC($HSRCDC)
		_WINAPI_SELECTOBJECT($HDSTDC, $HDSTSV)
		_WINAPI_DELETEDC($HDSTDC)
		IF $BDELETE THEN
			_WINAPI_DELETEOBJECT($HBITMAP)
		ENDIF
		RETURN $HRESULT
	ENDFUNC
	FUNC _WINAPI_INVERTCOLOR($ICOLOR)
		IF $ICOLOR = -1 THEN RETURN 0
		RETURN 16777215 - BITAND($ICOLOR, 16777215)
	ENDFUNC
	FUNC _WINAPI_INVERTRECT($HDC, BYREF $TRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "InvertRect", "handle", $HDC, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_INVERTRGN($HDC, $HRGN)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "InvertRgn", "handle", $HDC, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISRECTEMPTY(BYREF $TRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsRectEmpty", "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LINEDDA($IX1, $IY1, $IX2, $IY2, $PLINEPROC, $PDATA = 0)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "LineDDA", "int", $IX1, "int", $IY1, "int", $IX2, "int", $IY2, "ptr", $PLINEPROC, "lparam", $PDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LINETO($HDC, $IX, $IY)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "LineTo", "handle", $HDC, "int", $IX, "int", $IY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOCKWINDOWUPDATE($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "LockWindowUpdate", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LPTODP($HDC, BYREF $TPOINT, $ICOUNT = 1)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "LPtoDP", "handle", $HDC, "struct*", $TPOINT, "int", $ICOUNT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MASKBLT($HDESTDC, $IXDEST, $IYDEST, $IWIDTH, $IHEIGHT, $HSRCDC, $IXSRC, $IYSRC, $HMASK, $IXMASK, $IYMASK, $IROP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "MaskBlt", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTH, "int", $IHEIGHT, "hwnd", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "handle", $HMASK, "int", $IXMASK, "int", $IYMASK, "dword", $IROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MODIFYWORLDTRANSFORM($HDC, BYREF $TXFORM, $IMODE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "ModifyWorldTransform", "handle", $HDC, "struct*", $TXFORM, "dword", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MONITORFROMPOINT(BYREF $TPOINT, $IFLAG = 1)
		IF DLLSTRUCTGETSIZE($TPOINT) <> 8 THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "MonitorFromPoint", "struct", $TPOINT, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MONITORFROMRECT(BYREF $TRECT, $IFLAG = 1)
		LOCAL $ACALL = DLLCALL("user32.dll", "ptr", "MonitorFromRect", "struct*", $TRECT, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MONITORFROMWINDOW($HWND, $IFLAG = 1)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "MonitorFromWindow", "hwnd", $HWND, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MOVETO($HDC, $IX, $IY)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "MoveToEx", "handle", $HDC, "int", $IX, "int", $IY, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MOVETOEX($HDC, $IX, $IY)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "MoveToEx", "handle", $HDC, "int", $IX, "int", $IY, "struct*", $TPOINT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_OFFSETCLIPRGN($HDC, $IXOFFSET, $IYOFFSET)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "OffsetClipRgn", "handle", $HDC, "int", $IXOFFSET, "int", $IYOFFSET)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OFFSETPOINTS(BYREF $APOINT, $IXOFFSET, $IYOFFSET, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF UBOUND($APOINT, $UBOUND_COLUMNS) < 2 THEN RETURN SETERROR(13, 0, 0)
		FOR $I = $ISTART TO $IEND
			$APOINT[$I][0] += $IXOFFSET
			$APOINT[$I][1] += $IYOFFSET
		NEXT
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_OFFSETRECT(BYREF $TRECT, $IDX, $IDY)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "OffsetRect", "struct*", $TRECT, "int", $IDX, "int", $IDY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OFFSETRGN($HRGN, $IXOFFSET, $IYOFFSET)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "OffsetRgn", "handle", $HRGN, "int", $IXOFFSET, "int", $IYOFFSET)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OFFSETWINDOWORG($HDC, $IXOFFSET, $IYOFFSET)
		$__G_VEXT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "OffsetWindowOrgEx", "handle", $HDC, "int", $IXOFFSET, "int", $IYOFFSET, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PAINTDESKTOP($HDC)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "PaintDesktop", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PAINTRGN($HDC, $HRGN)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PaintRgn", "handle", $HDC, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATBLT($HDC, $IX, $IY, $IWIDTH, $IHEIGHT, $IROP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PatBlt", "handle", $HDC, "int", $IX, "int", $IY, "int", $IWIDTH, "int", $IHEIGHT, "dword", $IROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PATHTOREGION($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "PathToRegion", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PLAYENHMETAFILE($HDC, $HEMF, BYREF $TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PlayEnhMetaFile", "handle", $HDC, "handle", $HEMF, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PLGBLT($HDESTDC, CONST BYREF $APOINT, $HSRCDC, $IXSRC, $IYSRC, $IWIDTH, $IHEIGHT, $HMASK = 0, $IXMASK = 0, $IYMASK = 0)
		IF(UBOUND($APOINT) < 3) OR(UBOUND($APOINT, $UBOUND_COLUMNS) < 2) THEN RETURN SETERROR(12, 0, FALSE)
		LOCAL $TPOINTS = DLLSTRUCTCREATE("long[2];long[2];long[2]")
		FOR $I = 0 TO 2
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TPOINTS, $I + 1, $APOINT[$I][$J], $J + 1)
			NEXT
		NEXT
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PlgBlt", "handle", $HDESTDC, "struct*", $TPOINTS, "handle", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTH, "int", $IHEIGHT, "handle", $HMASK, "int", $IXMASK, "int", $IYMASK)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_POLYBEZIER($HDC, CONST BYREF $APOINT, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		LOCAL $IPOINT = 1 + 3 * FLOOR(($IEND - $ISTART) / 3)
		IF $IPOINT < 1 THEN RETURN SETERROR(15, 0, FALSE)
		$IEND = $ISTART + $IPOINT - 1
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "long[2];"
		NEXT
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 0
		FOR $I = $ISTART TO $IEND
			$ICOUNT += 1
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TPOINT, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
		NEXT
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PolyBezier", "handle", $HDC, "struct*", $TPOINT, "dword", $IPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_POLYBEZIERTO($HDC, CONST BYREF $APOINT, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		LOCAL $IPOINT = 3 * FLOOR(($IEND - $ISTART + 1) / 3)
		IF $IPOINT < 3 THEN RETURN SETERROR(15, 0, FALSE)
		$IEND = $ISTART + $IPOINT - 1
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "long[2];"
		NEXT
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 0
		FOR $I = $ISTART TO $IEND
			$ICOUNT += 1
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TPOINT, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
		NEXT
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PolyBezierTo", "handle", $HDC, "struct*", $TPOINT, "dword", $IPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_POLYDRAW($HDC, CONST BYREF $APOINT, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF UBOUND($APOINT, $UBOUND_COLUMNS) < 3 THEN RETURN SETERROR(13, 0, FALSE)
		LOCAL $IPOINT = $IEND - $ISTART + 1
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "long[2];"
		NEXT
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $TTYPES = DLLSTRUCTCREATE("byte[" & $IPOINT & "]")
		LOCAL $ICOUNT = 0
		FOR $I = $ISTART TO $IEND
			$ICOUNT += 1
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TPOINT, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
			DLLSTRUCTSETDATA($TTYPES, 1, $APOINT[$I][2], $ICOUNT)
		NEXT
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PolyDraw", "handle", $HDC, "struct*", $TPOINT, "struct*", $TTYPES, "dword", $IPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_POLYGON($HDC, CONST BYREF $APOINT, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "int[2];"
		NEXT
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TDATA, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
			$ICOUNT += 1
		NEXT
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "Polygon", "handle", $HDC, "struct*", $TDATA, "int", $ICOUNT - 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PTINRECTEX($IX, $IY, $ILEFT, $ITOP, $IRIGHT, $IBOTTOM)
		LOCAL $TRECT = _WINAPI_CREATERECT($ILEFT, $ITOP, $IRIGHT, $IBOTTOM)
		LOCAL $TPOINT = _WINAPI_CREATEPOINT($IX, $IY)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "PtInRect", "struct*", $TRECT, "struct", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PTINREGION($HRGN, $IX, $IY)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PtInRegion", "handle", $HRGN, "int", $IX, "int", $IY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_PTVISIBLE($HDC, $IX, $IY)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "PtVisible", "handle", $HDC, "int", $IX, "int", $IY)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF $ACALL[0] = -1 THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RADIALGRADIENTFILL($HDC, $IX, $IY, $IRADIUS, $IRGB1, $IRGB2, $FANGLESTART = 0, $FANGLEEND = 360, $FSTEP = 5)
		IF ABS($FANGLESTART) > 360 THEN
			$FANGLESTART = MOD($FANGLESTART, 360)
		ENDIF
		IF ABS($FANGLEEND) > 360 THEN
			$FANGLEEND = MOD($FANGLEEND, 360)
		ENDIF
		IF($FANGLESTART < 0) OR($FANGLEEND < 0) THEN
			$FANGLESTART += 360
			$FANGLEEND += 360
		ENDIF
		IF $FANGLESTART > $FANGLEEND THEN
			LOCAL $FVAL = $FANGLESTART
			$FANGLESTART = $FANGLEEND
			$FANGLEEND = $FVAL
		ENDIF
		IF $FSTEP < 1 THEN
			$FSTEP = 1
		ENDIF
		LOCAL $FKI = ATAN(1) / 45
		LOCAL $IXP = ROUND($IX + $IRADIUS * COS($FKI * $FANGLESTART))
		LOCAL $IYP = ROUND($IY + $IRADIUS * SIN($FKI * $FANGLESTART))
		LOCAL $IXN, $IYN, $FAN = $FANGLESTART
		LOCAL $AVERTEX[3][3]
		WHILE $FAN < $FANGLEEND
			$FAN += $FSTEP
			IF $FAN > $FANGLEEND THEN
				$FAN = $FANGLEEND
			ENDIF
			$IXN = ROUND($IX + $IRADIUS * COS($FKI * $FAN))
			$IYN = ROUND($IY + $IRADIUS * SIN($FKI * $FAN))
			$AVERTEX[0][0] = $IX
			$AVERTEX[0][1] = $IY
			$AVERTEX[0][2] = $IRGB1
			$AVERTEX[1][0] = $IXP
			$AVERTEX[1][1] = $IYP
			$AVERTEX[1][2] = $IRGB2
			$AVERTEX[2][0] = $IXN
			$AVERTEX[2][1] = $IYN
			$AVERTEX[2][2] = $IRGB2
			IF NOT _WINAPI_GRADIENTFILL($HDC, $AVERTEX, 0, 2) THEN
				RETURN SETERROR(@ERROR, @EXTENDED, 0)
			ENDIF
			$IXP = $IXN
			$IYP = $IYN
		WEND
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_RECTANGLE($HDC, $TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "Rectangle", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RECTINREGION($HRGN, $TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "RectInRegion", "handle", $HRGN, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RECTISEMPTY(BYREF $TRECT)
		RETURN(DLLSTRUCTGETDATA($TRECT, "Left") = 0) AND(DLLSTRUCTGETDATA($TRECT, "Top") = 0) AND(DLLSTRUCTGETDATA($TRECT, "Right") = 0) AND(DLLSTRUCTGETDATA($TRECT, "Bottom") = 0)
	ENDFUNC
	FUNC _WINAPI_RECTVISIBLE($HDC, $TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "RectVisible", "handle", $HDC, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		SWITCH $ACALL[0]
			CASE 0, 1, 2
			CASE ELSE
				RETURN SETERROR(10, $ACALL[0], 0)
		ENDSWITCH
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REMOVEFONTMEMRESOURCEEX($HFONT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "RemoveFontMemResourceEx", "handle", $HFONT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REMOVEFONTRESOURCEEX($SFONT, $IFLAG = 0, $BNOTIFY = FALSE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "RemoveFontResourceExW", "wstr", $SFONT, "dword", $IFLAG, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF $BNOTIFY THEN
			LOCAL CONST $WM_FONTCHANGE = 29
			LOCAL CONST $HWND_BROADCAST = 65535
			DLLCALL("user32.dll", "none", "SendMessage", "hwnd", $HWND_BROADCAST, "uint", $WM_FONTCHANGE, "wparam", 0, "lparam", 0)
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RGB($IRED, $IGREEN, $IBLUE)
		RETURN __RGB(BITOR(BITSHIFT($IBLUE, -16), BITSHIFT($IGREEN, -8), $IRED))
	ENDFUNC
	FUNC _WINAPI_ROTATEPOINTS(BYREF $APOINT, $IXC, $IYC, $FANGLE, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF UBOUND($APOINT, $UBOUND_COLUMNS) < 2 THEN RETURN SETERROR(13, 0, 0)
		LOCAL $FCOS = COS(ATAN(1) / 45 * $FANGLE)
		LOCAL $FSIN = SIN(ATAN(1) / 45 * $FANGLE)
		LOCAL $IXN, $IYN
		FOR $I = $ISTART TO $IEND
			$IXN = $APOINT[$I][0] - $IXC
			$IYN = $APOINT[$I][1] - $IYC
			$APOINT[$I][0] = $IXC + ROUND($IXN * $FCOS - $IYN * $FSIN)
			$APOINT[$I][1] = $IYC + ROUND($IXN * $FSIN + $IYN * $FCOS)
		NEXT
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ROUNDRECT($HDC, $TRECT, $IWIDTH, $IHEIGHT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "RoundRect", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4), "int", $IWIDTH, "int", $IHEIGHT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SAVEHBITMAPTOFILE($SFILEPATH, $HBITMAP, $IXPELSPERMETER = DEFAULT, $IYPELSPERMETER = DEFAULT)
		LOCAL $TBMP = DLLSTRUCTCREATE("align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset")
		LOCAL $TDIB = DLLSTRUCTCREATE($TAGDIBSECTION)
		LOCAL $HDC, $HSV, $HSOURCE = 0
		WHILE $HBITMAP
			IF(NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($TDIB), $TDIB)) OR(DLLSTRUCTGETDATA($TDIB, "biCompression")) THEN
				$HBITMAP = 0
			ELSE
				SWITCH DLLSTRUCTGETDATA($TDIB, "bmBitsPixel")
					CASE 32
						IF NOT _WINAPI_ISALPHABITMAP($HBITMAP) THEN
							IF NOT $HSOURCE THEN
								$HSOURCE = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($TDIB, "bmWidth"), DLLSTRUCTGETDATA($TDIB, "bmHeight"), 24)
								IF NOT $HSOURCE THEN
									$HBITMAP = 0
								ENDIF
								$HDC = _WINAPI_CREATECOMPATIBLEDC(0)
								$HSV = _WINAPI_SELECTOBJECT($HDC, $HSOURCE)
								IF _WINAPI_DRAWBITMAP($HDC, 0, 0, $HBITMAP) THEN
									$HBITMAP = $HSOURCE
								ELSE
									$HBITMAP = 0
								ENDIF
								_WINAPI_SELECTOBJECT($HDC, $HSV)
								_WINAPI_DELETEDC($HDC)
							ELSE
								$HBITMAP = 0
							ENDIF
							CONTINUELOOP
						ENDIF
					CASE ELSE
				ENDSWITCH
				IF(NOT DLLSTRUCTGETDATA($TDIB, "bmBits")) OR(NOT DLLSTRUCTGETDATA($TDIB, "biSizeImage")) THEN
					IF NOT $HSOURCE THEN
						$HBITMAP = _WINAPI_COPYBITMAP($HBITMAP)
						$HSOURCE = $HBITMAP
					ELSE
						$HBITMAP = 0
					ENDIF
				ELSE
					EXITLOOP
				ENDIF
			ENDIF
		WEND
		LOCAL $HFILE = 0, $IERROR = 0, $IRESULT = 0
		DO
			IF NOT $HBITMAP THEN
				$IERROR = 1
				EXITLOOP
			ENDIF
			LOCAL $ADATA[4][2]
			$ADATA[0][0] = DLLSTRUCTGETPTR($TBMP)
			$ADATA[0][1] = DLLSTRUCTGETSIZE($TBMP)
			$ADATA[1][0] = DLLSTRUCTGETPTR($TDIB, "biSize")
			$ADATA[1][1] = 40
			$ADATA[2][1] = DLLSTRUCTGETDATA($TDIB, "biClrUsed") * 4
			LOCAL $TTABLE = 0
			IF $ADATA[2][1] THEN
				$TTABLE = _WINAPI_GETDIBCOLORTABLE($HBITMAP)
				IF @ERROR OR(@EXTENDED <> $ADATA[2][1] / 4) THEN
					$IERROR = @ERROR + 10
					EXITLOOP
				ENDIF
			ENDIF
			$ADATA[2][0] = DLLSTRUCTGETPTR($TTABLE)
			$ADATA[3][0] = DLLSTRUCTGETDATA($TDIB, "bmBits")
			$ADATA[3][1] = DLLSTRUCTGETDATA($TDIB, "biSizeImage")
			DLLSTRUCTSETDATA($TBMP, "bfType", 19778)
			DLLSTRUCTSETDATA($TBMP, "bfSize", $ADATA[0][1] + $ADATA[1][1] + $ADATA[2][1] + $ADATA[3][1])
			DLLSTRUCTSETDATA($TBMP, "bfReserved1", 0)
			DLLSTRUCTSETDATA($TBMP, "bfReserved2", 0)
			DLLSTRUCTSETDATA($TBMP, "bfOffset", $ADATA[0][1] + $ADATA[1][1] + $ADATA[2][1])
			$HDC = _WINAPI_GETDC(0)
			IF $IXPELSPERMETER = DEFAULT THEN
				IF NOT DLLSTRUCTGETDATA($TDIB, "biXPelsPerMeter") THEN
					DLLSTRUCTSETDATA($TDIB, "biXPelsPerMeter", _WINAPI_GETDEVICECAPS($HDC, 8) / _WINAPI_GETDEVICECAPS($HDC, 4) * 1000)
				ENDIF
			ELSE
				DLLSTRUCTSETDATA($TDIB, "biXPelsPerMeter", $IXPELSPERMETER)
			ENDIF
			IF $IYPELSPERMETER = DEFAULT THEN
				IF NOT DLLSTRUCTGETDATA($TDIB, "biYPelsPerMeter") THEN
					DLLSTRUCTSETDATA($TDIB, "biYPelsPerMeter", _WINAPI_GETDEVICECAPS($HDC, 10) / _WINAPI_GETDEVICECAPS($HDC, 6) * 1000)
				ENDIF
			ELSE
				DLLSTRUCTSETDATA($TDIB, "biYPelsPerMeter", $IYPELSPERMETER)
			ENDIF
			_WINAPI_RELEASEDC(0, $HDC)
			$HFILE = _WINAPI_CREATEFILE($SFILEPATH, 1, 4)
			IF @ERROR THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			LOCAL $IBYTES
			FOR $I = 0 TO 3
				IF $ADATA[$I][1] THEN
					IF NOT _WINAPI_WRITEFILE($HFILE, $ADATA[$I][0], $ADATA[$I][1], $IBYTES) THEN
						$IERROR = @ERROR + 30
						EXITLOOP 2
					ENDIF
				ENDIF
			NEXT
			$IRESULT = 1
		UNTIL 1
		IF $HSOURCE THEN
			_WINAPI_DELETEOBJECT($HSOURCE)
		ENDIF
		_WINAPI_CLOSEHANDLE($HFILE)
		IF NOT $IRESULT THEN
			FILEDELETE($SFILEPATH)
		ENDIF
		RETURN SETERROR($IERROR, 0, $IRESULT)
	ENDFUNC
	FUNC _WINAPI_SAVEHICONTOFILE($SFILEPATH, CONST BYREF $VICON, $BCOMPRESS = 0, $ISTART = 0, $IEND = -1)
		LOCAL $AICON, $ATEMP, $ICOUNT = 1
		IF NOT ISARRAY($VICON) THEN
			DIM $AICON[1] = [$VICON]
			DIM $ATEMP[1] = [0]
		ELSE
			IF __CHECKERRORARRAYBOUNDS($VICON, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$ICOUNT = $IEND - $ISTART + 1
			IF $ICOUNT THEN
				DIM $AICON[$ICOUNT]
				DIM $ATEMP[$ICOUNT]
				FOR $I = 0 TO $ICOUNT - 1
					$AICON[$I] = $VICON[$ISTART + $I]
					$ATEMP[$I] = 0
				NEXT
			ENDIF
		ENDIF
		LOCAL $HFILE = _WINAPI_CREATEFILE($SFILEPATH, 1, 4)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TICO = DLLSTRUCTCREATE("align 1;ushort Reserved;ushort Type;ushort Count;byte Data[" & (16 * $ICOUNT) & "]")
		LOCAL $ILENGTH = DLLSTRUCTGETSIZE($TICO)
		LOCAL $TBI = DLLSTRUCTCREATE($TAGBITMAPINFOHEADER)
		LOCAL $TII = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $TDIB = DLLSTRUCTCREATE($TAGDIBSECTION)
		LOCAL $IDIB = DLLSTRUCTGETSIZE($TDIB)
		LOCAL $PDIB = DLLSTRUCTGETPTR($TDIB)
		LOCAL $IOFFSET = $ILENGTH
		DLLSTRUCTSETDATA($TBI, "biSize", 40)
		DLLSTRUCTSETDATA($TBI, "biPlanes", 1)
		DLLSTRUCTSETDATA($TBI, "biXPelsPerMeter", 0)
		DLLSTRUCTSETDATA($TBI, "biYPelsPerMeter", 0)
		DLLSTRUCTSETDATA($TBI, "biClrUsed", 0)
		DLLSTRUCTSETDATA($TBI, "biClrImportant", 0)
		DLLSTRUCTSETDATA($TICO, "Reserved", 0)
		DLLSTRUCTSETDATA($TICO, "Type", 1)
		DLLSTRUCTSETDATA($TICO, "Count", $ICOUNT)
		LOCAL $IRESULT = 0, $IERROR = 0, $IBYTES
		LOCAL $AINFO[8], $ACALL, $PDATA = 0, $IINDEX = 0
		LOCAL $ASIZE[2], $TDATA = 0
		DO
			IF NOT _WINAPI_WRITEFILE($HFILE, $TICO, $ILENGTH, $IBYTES) THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			WHILE $ICOUNT > $IINDEX
				$ACALL = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $AICON[$IINDEX], "struct*", $TII)
				IF @ERROR OR NOT $ACALL[0] THEN
					$IERROR = @ERROR + 40
					EXITLOOP 2
				ENDIF
				FOR $I = 4 TO 5
					$AINFO[$I] = _WINAPI_COPYIMAGE(DLLSTRUCTGETDATA($TII, $I), 0, 0, 0, 8200)
					IF _WINAPI_GETOBJECT($AINFO[$I], $IDIB, $PDIB) THEN
						$AINFO[$I - 4] = DLLSTRUCTGETDATA($TDIB, "biSizeImage")
						$AINFO[$I - 2] = DLLSTRUCTGETDATA($TDIB, "bmBits")
					ELSE
						$IERROR = @ERROR + 50
					ENDIF
				NEXT
				$AINFO[6] = 40
				$AINFO[7] = DLLSTRUCTGETDATA($TDIB, "bmBitsPixel")
				SWITCH $AINFO[7]
					CASE 16, 24
					CASE 32
						IF NOT _WINAPI_ISALPHABITMAP($AINFO[5]) THEN
							IF NOT $ATEMP[$IINDEX] THEN
								$AICON[$IINDEX] = _WINAPI_CREATE32BITHICON($AICON[$IINDEX])
								$ATEMP[$IINDEX] = $AICON[$IINDEX]
								IF NOT @ERROR THEN
									CONTINUELOOP
								ELSE
									CONTINUECASE
								ENDIF
							ENDIF
						ELSE
							IF($AINFO[1] >= 256 * 256 * 4) AND($BCOMPRESS) THEN
								$IBYTES = _WINAPI_COMPRESSBITMAPBITS($AINFO[5], $PDATA)
								IF NOT @ERROR THEN
									$AINFO[0] = 0
									$AINFO[1] = $IBYTES
									$AINFO[2] = 0
									$AINFO[3] = $PDATA
									$AINFO[6] = 0
								ENDIF
							ENDIF
						ENDIF
					CASE ELSE
						$IERROR = 60
				ENDSWITCH
				IF NOT $IERROR THEN
					$TDATA = DLLSTRUCTCREATE("byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset", DLLSTRUCTGETPTR($TICO) + 6 + 16 * $IINDEX)
					DLLSTRUCTSETDATA($TDATA, "ColorCount", 0)
					DLLSTRUCTSETDATA($TDATA, "Reserved", 0)
					DLLSTRUCTSETDATA($TDATA, "Planes", 1)
					DLLSTRUCTSETDATA($TDATA, "BitCount", $AINFO[7])
					DLLSTRUCTSETDATA($TDATA, "Size", $AINFO[0] + $AINFO[1] + $AINFO[6])
					DLLSTRUCTSETDATA($TDATA, "Offset", $IOFFSET)
					FOR $I = 0 TO 1
						$ASIZE[$I] = DLLSTRUCTGETDATA($TDIB, $I + 2)
						IF $ASIZE[$I] < 256 THEN
							DLLSTRUCTSETDATA($TDATA, $I + 1, $ASIZE[$I])
						ELSE
							DLLSTRUCTSETDATA($TDATA, $I + 1, 0)
						ENDIF
					NEXT
					DLLSTRUCTSETDATA($TBI, "biWidth", $ASIZE[0])
					DLLSTRUCTSETDATA($TBI, "biHeight", 2 * $ASIZE[1])
					DLLSTRUCTSETDATA($TBI, "biBitCount", $AINFO[7])
					DLLSTRUCTSETDATA($TBI, "biCompression", 0)
					DLLSTRUCTSETDATA($TBI, "biSizeImage", $AINFO[0] + $AINFO[1])
					$IOFFSET += $AINFO[0] + $AINFO[1] + $AINFO[6]
					DO
						IF $AINFO[6] THEN
							IF NOT _WINAPI_WRITEFILE($HFILE, $TBI, $AINFO[6], $IBYTES) THEN
								$IERROR = @ERROR + 70
								EXITLOOP
							ENDIF
							FOR $I = 1 TO 0 STEP -1
								IF NOT _WINAPI_WRITEFILE($HFILE, $AINFO[$I + 2], $AINFO[$I], $IBYTES) THEN
									$IERROR = @ERROR + 80
									EXITLOOP 2
								ENDIF
							NEXT
						ELSE
							IF NOT _WINAPI_WRITEFILE($HFILE, $AINFO[3], $AINFO[1], $IBYTES) THEN
								$IERROR = @ERROR + 90
								EXITLOOP
							ENDIF
						ENDIF
					UNTIL 1
				ENDIF
				FOR $I = 4 TO 5
					_WINAPI_DELETEOBJECT($AINFO[$I])
				NEXT
				IF $IERROR THEN
					EXITLOOP 2
				ENDIF
				$IINDEX += 1
			WEND
			$ACALL = DLLCALL("kernel32.dll", "bool", "SetFilePointerEx", "handle", $HFILE, "int64", 0, "int64*", 0, "dword", 0)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 100
				EXITLOOP
			ENDIF
			IF NOT _WINAPI_WRITEFILE($HFILE, $TICO, $ILENGTH, $IBYTES) THEN
				$IERROR = @ERROR + 110
				EXITLOOP
			ENDIF
			$IRESULT = 1
		UNTIL 1
		FOR $I = 0 TO $ICOUNT - 1
			IF $ATEMP[$I] THEN
				_WINAPI_DESTROYICON($ATEMP[$I])
			ENDIF
		NEXT
		IF $PDATA THEN
			__HEAPFREE($PDATA)
		ENDIF
		_WINAPI_CLOSEHANDLE($HFILE)
		IF NOT $IRESULT THEN
			FILEDELETE($SFILEPATH)
		ENDIF
		RETURN SETERROR($IERROR, 0, $IRESULT)
	ENDFUNC
	FUNC _WINAPI_SCALEWINDOWEXT($HDC, $IXNUM, $IXDENOM, $IYNUM, $IYDENOM)
		$__G_VEXT = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "ScaleWindowExtEx", "handle", $HDC, "int", $IXNUM, "int", $IXDENOM, "int", $IYNUM, "int", $IYDENOM, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SELECTCLIPPATH($HDC, $IMODE = 5)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SelectClipPath", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SELECTCLIPRGN($HDC, $HRGN)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SelectClipRgn", "handle", $HDC, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETARCDIRECTION($HDC, $IDIRECTION)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetArcDirection", "handle", $HDC, "int", $IDIRECTION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETBITMAPBITS($HBITMAP, $ISIZE, $PBITS)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "long", "SetBitmapBits", "handle", $HBITMAP, "dword", $ISIZE, "struct*", $PBITS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETBITMAPDIMENSIONEX($HBITMAP, $IWIDTH, $IHEIGHT)
		$__G_VEXT = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetBitmapDimensionEx", "handle", $HBITMAP, "int", $IWIDTH, "int", $IHEIGHT, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETBOUNDSRECT($HDC, $IFLAGS, $TRECT = 0)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "SetBoundsRect", "handle", $HDC, "struct*", $TRECT, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETBRUSHORG($HDC, $IX, $IY)
		$__G_VEXT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetBrushOrgEx", "handle", $HDC, "int", $IX, "int", $IY, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETCOLORADJUSTMENT($HDC, $TADJUSTMENT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetColorAdjustment", "handle", $HDC, "struct*", $TADJUSTMENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETDCBRUSHCOLOR($HDC, $IRGB)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "dword", "SetDCBrushColor", "handle", $HDC, "dword", __RGB($IRGB))
		IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_SETDCPENCOLOR($HDC, $IRGB)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "dword", "SetDCPenColor", "handle", $HDC, "dword", __RGB($IRGB))
		IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ACALL[0])
	ENDFUNC
	FUNC _WINAPI_SETDEVICEGAMMARAMP($HDC, CONST BYREF $ARAMP)
		IF(UBOUND($ARAMP, $UBOUND_DIMENSIONS) <> 2) OR(UBOUND($ARAMP, $UBOUND_ROWS) <> 256) OR(UBOUND($ARAMP, $UBOUND_COLUMNS) <> 3) THEN
			RETURN SETERROR(12, 0, 0)
		ENDIF
		LOCAL $TDATA = DLLSTRUCTCREATE("ushort[256];ushort[256];ushort[256]")
		FOR $I = 0 TO 2
			FOR $J = 0 TO 255
				DLLSTRUCTSETDATA($TDATA, $I + 1, $ARAMP[$J][$I], $J + 1)
			NEXT
		NEXT
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetDeviceGammaRamp", "handle", $HDC, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETDIBCOLORTABLE($HBITMAP, $TCOLORTABLE, $ICOLORCOUNT)
		IF $ICOLORCOUNT > DLLSTRUCTGETSIZE($TCOLORTABLE) / 4 THEN RETURN SETERROR(1, 0, 0)
		LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HSV = _WINAPI_SELECTOBJECT($HDC, $HBITMAP)
		LOCAL $IERROR = 0
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "SetDIBColorTable", "handle", $HDC, "uint", 0, "uint", $ICOLORCOUNT, "struct*", $TCOLORTABLE)
		IF @ERROR THEN $IERROR = @ERROR
		_WINAPI_SELECTOBJECT($HDC, $HSV)
		_WINAPI_DELETEDC($HDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETDIBITS($HDC, $HBITMAP, $ISTARTSCAN, $ISCANLINES, $PBITS, $TBMI, $ICOLORUSE = 0)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetDIBits", "handle", $HDC, "handle", $HBITMAP, "uint", $ISTARTSCAN, "uint", $ISCANLINES, "struct*", $PBITS, "struct*", $TBMI, "INT", $ICOLORUSE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETDIBITSTODEVICE($HDC, $IXDEST, $IYDEST, $IWIDTH, $IHEIGHT, $IXSRC, $IYSRC, $ISTARTSCAN, $ISCANLINES, $TBITMAPINFO, $IUSAGE, $PBITS)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetDIBitsToDevice", "handle", $HDC, "int", $IXDEST, "int", $IYDEST, "dword", $IWIDTH, "dword", $IHEIGHT, "int", $IXSRC, "int", $IYSRC, "uint", $ISTARTSCAN, "uint", $ISCANLINES, "struct*", $PBITS, "struct*", $TBITMAPINFO, "uint", $IUSAGE)
		IF @ERROR OR($ACALL[0] = -1) THEN RETURN SETERROR(@ERROR + 10, $ACALL[0], 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETENHMETAFILEBITS($PDATA, $ILENGTH)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "handle", "SetEnhMetaFileBits", "uint", $ILENGTH, "struct*", $PDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETGRAPHICSMODE($HDC, $IMODE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetGraphicsMode", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETMAPMODE($HDC, $IMODE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetMapMode", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETPIXEL($HDC, $IX, $IY, $IRGB)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetPixelV", "handle", $HDC, "int", $IX, "int", $IY, "dword", __RGB($IRGB))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETPOLYFILLMODE($HDC, $IMODE = 1)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetPolyFillMode", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETRECTRGN($HRGN, $TRECT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetRectRgn", "handle", $HRGN, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETROP2($HDC, $IMODE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetROP2", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETSTRETCHBLTMODE($HDC, $IMODE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetStretchBltMode", "handle", $HDC, "int", $IMODE)
		IF @ERROR OR NOT $ACALL[0] OR($ACALL[0] = 87) THEN RETURN SETERROR(@ERROR + 10, $ACALL[0], 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETTEXTALIGN($HDC, $IMODE = 0)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "uint", "SetTextAlign", "handle", $HDC, "uint", $IMODE)
		IF @ERROR OR($ACALL[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETTEXTCHARACTEREXTRA($HDC, $ICHAREXTRA)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "SetTextCharacterExtra", "handle", $HDC, "int", $ICHAREXTRA)
		IF @ERROR OR($ACALL[0] = -2147483648) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETTEXTJUSTIFICATION($HDC, $IBREAKEXTRA, $IBREAKCOUNT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetTextJustification", "handle", $HDC, "int", $IBREAKEXTRA, "int", $IBREAKCOUNT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETUDFCOLORMODE($IMODE)
		$__G_IRGBMODE = NOT($IMODE = 0)
	ENDFUNC
	FUNC _WINAPI_SETWINDOWEXT($HDC, $IXEXTENT, $IYEXTENT)
		$__G_VEXT = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetWindowExtEx", "handle", $HDC, "int", $IXEXTENT, "int", $IYEXTENT, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWORG($HDC, $IX, $IY)
		$__G_VEXT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetWindowOrgEx", "handle", $HDC, "int", $IX, "int", $IY, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWORLDTRANSFORM($HDC, BYREF $TXFORM)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "SetWorldTransform", "handle", $HDC, "struct*", $TXFORM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_STRETCHBLT($HDESTDC, $IXDEST, $IYDEST, $IWIDTHDEST, $IHEIGHTDEST, $HSRCDC, $IXSRC, $IYSRC, $IWIDTHSRC, $IHEIGHTSRC, $IROP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "StretchBlt", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTHDEST, "int", $IHEIGHTDEST, "hwnd", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTHSRC, "int", $IHEIGHTSRC, "dword", $IROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_STRETCHDIBITS($HDESTDC, $IXDEST, $IYDEST, $IWIDTHDEST, $IHEIGHTDEST, $IXSRC, $IYSRC, $IWIDTHSRC, $IHEIGHTSRC, $TBITMAPINFO, $IUSAGE, $PBITS, $IROP)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "int", "StretchDIBits", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTHDEST, "int", $IHEIGHTDEST, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTHSRC, "int", $IHEIGHTSRC, "struct*", $PBITS, "struct*", $TBITMAPINFO, "uint", $IUSAGE, "dword", $IROP)
		IF @ERROR OR($ACALL[0] = -1) THEN RETURN SETERROR(@ERROR + 10, $ACALL[0], 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_STROKEANDFILLPATH($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "StrokeAndFillPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_STROKEPATH($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "StrokePath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SUBTRACTRECT(BYREF $TRECT1, BYREF $TRECT2)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SubtractRect", "struct*", $TRECT, "struct*", $TRECT1, "struct*", $TRECT2)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_TABBEDTEXTOUT($HDC, $IX, $IY, $STEXT, $ATAB = 0, $ISTART = 0, $IEND = -1, $IORIGIN = 0)
		LOCAL $ITAB, $ICOUNT
		IF NOT ISARRAY($ATAB) THEN
			IF $ATAB THEN
				$ITAB = $ATAB
				DIM $ATAB[1] = [$ITAB]
				$ISTART = 0
				$IEND = 0
				$ICOUNT = 1
			ELSE
				$ICOUNT = 0
			ENDIF
		ELSE
			$ICOUNT = 1
		ENDIF
		LOCAL $TTAB = 0
		IF $ICOUNT THEN
			IF __CHECKERRORARRAYBOUNDS($ATAB, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$ICOUNT = $IEND - $ISTART + 1
			$TTAB = DLLSTRUCTCREATE("uint[" & $ICOUNT & "]")
			$ITAB = 1
			FOR $I = $ISTART TO $IEND
				DLLSTRUCTSETDATA($TTAB, 1, $ATAB[$I], $ITAB)
				$ITAB += 1
			NEXT
		ENDIF
		LOCAL $ACALL = DLLCALL("user32.dll", "long", "TabbedTextOutW", "handle", $HDC, "int", $IX, "int", $IY, "wstr", $STEXT, "int", STRINGLEN($STEXT), "int", $ICOUNT, "struct*", $TTAB, "int", $IORIGIN)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$__G_VEXT = _WINAPI_CREATESIZE(_WINAPI_LOWORD($ACALL[0]), _WINAPI_HIWORD($ACALL[0]))
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_TEXTOUT($HDC, $IX, $IY, $STEXT)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "TextOutW", "handle", $HDC, "int", $IX, "int", $IY, "wstr", $STEXT, "int", STRINGLEN($STEXT))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_TRANSPARENTBLT($HDESTDC, $IXDEST, $IYDEST, $IWIDTHDEST, $IHEIGHTDEST, $HSRCDC, $IXSRC, $IYSRC, $IWIDTHSRC, $IHEIGHTSRC, $IRGB)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "GdiTransparentBlt", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTHDEST, "int", $IHEIGHTDEST, "hwnd", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTHSRC, "int", $IHEIGHTSRC, "dword", __RGB($IRGB))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNIONRECT(BYREF $TRECT1, BYREF $TRECT2)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UnionRect", "struct*", $TRECT, "struct*", $TRECT1, "struct*", $TRECT2)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, 0, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_VALIDATERECT($HWND, $TRECT = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ValidateRect", "hwnd", $HWND, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_VALIDATERGN($HWND, $HRGN = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ValidateRgn", "hwnd", $HWND, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WIDENPATH($HDC)
		LOCAL $ACALL = DLLCALL("gdi32.dll", "bool", "WidenPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WINDOWFROMDC($HDC)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "WindowFromDC", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __ENUMDISPLAYMONITORSPROC($HMONITOR, $HDC, $PRECT, $LPARAM)
		#forceref $HDC, $LPARAM
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0][0]][0] = $HMONITOR
		IF NOT $PRECT THEN
			$__G_VENUM[$__G_VENUM[0][0]][1] = 0
		ELSE
			$__G_VENUM[$__G_VENUM[0][0]][1] = DLLSTRUCTCREATE($TAGRECT)
			IF NOT _WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($__G_VENUM[$__G_VENUM[0][0]][1]), $PRECT, 16) THEN RETURN 0
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMFONTFAMILIESPROC($PELFEX, $PNTMEX, $IFONTTYPE, $PPATTERN)
		LOCAL $TELFEX = DLLSTRUCTCREATE($TAGLOGFONT & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $PELFEX)
		LOCAL $TNTMEX = DLLSTRUCTCREATE($TAGNEWTEXTMETRICEX, $PNTMEX)
		LOCAL $TPATTERN = DLLSTRUCTCREATE("uint;uint;ptr", $PPATTERN)
		IF $IFONTTYPE AND NOT BITAND($IFONTTYPE, DLLSTRUCTGETDATA($TPATTERN, 1)) THEN
			RETURN 1
		ENDIF
		IF DLLSTRUCTGETDATA($TPATTERN, 3) THEN
			LOCAL $ACALL = DLLCALL("shlwapi.dll", "bool", "PathMatchSpecW", "ptr", DLLSTRUCTGETPTR($TELFEX, 14), "ptr", DLLSTRUCTGETDATA($TPATTERN, 3))
			IF NOT @ERROR THEN
				IF DLLSTRUCTGETDATA($TPATTERN, 2) THEN
					IF $ACALL[0] THEN
						RETURN 1
					ELSE
					ENDIF
				ELSE
					IF $ACALL[0] THEN
					ELSE
						RETURN 1
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0][0]][0] = DLLSTRUCTGETDATA($TELFEX, 14)
		$__G_VENUM[$__G_VENUM[0][0]][1] = DLLSTRUCTGETDATA($TELFEX, 16)
		$__G_VENUM[$__G_VENUM[0][0]][2] = DLLSTRUCTGETDATA($TELFEX, 15)
		$__G_VENUM[$__G_VENUM[0][0]][3] = DLLSTRUCTGETDATA($TELFEX, 17)
		$__G_VENUM[$__G_VENUM[0][0]][4] = $IFONTTYPE
		$__G_VENUM[$__G_VENUM[0][0]][5] = DLLSTRUCTGETDATA($TNTMEX, 19)
		$__G_VENUM[$__G_VENUM[0][0]][6] = DLLSTRUCTGETDATA($TNTMEX, 20)
		$__G_VENUM[$__G_VENUM[0][0]][7] = DLLSTRUCTGETDATA($TNTMEX, 21)
		RETURN 1
	ENDFUNC
	FUNC __ENUMFONTSTYLESPROC($PELFEX, $PNTMEX, $IFONTTYPE, $PFN)
		#forceref $IFONTTYPE
		LOCAL $TELFEX = DLLSTRUCTCREATE($TAGLOGFONT & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $PELFEX)
		LOCAL $TNTMEX = DLLSTRUCTCREATE($TAGNEWTEXTMETRICEX, $PNTMEX)
		LOCAL $TFN = DLLSTRUCTCREATE("dword;wchar[64]", $PFN)
		IF BITAND(DLLSTRUCTGETDATA($TNTMEX, "ntmFlags"), 97) = DLLSTRUCTGETDATA($TFN, 1) THEN
			DLLSTRUCTSETDATA($TFN, 2, DLLSTRUCTGETDATA($TELFEX, "FullName"))
			RETURN 0
		ELSE
			RETURN 1
		ENDIF
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $CREATE_BREAKAWAY_FROM_JOB = 16777216
GLOBAL CONST $CREATE_DEFAULT_ERROR_MODE = 67108864
GLOBAL CONST $CREATE_NEW_CONSOLE = 16
GLOBAL CONST $CREATE_NEW_PROCESS_GROUP = 512
GLOBAL CONST $CREATE_NO_WINDOW = 134217728
GLOBAL CONST $CREATE_PROTECTED_PROCESS = 262144
GLOBAL CONST $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 33554432
GLOBAL CONST $CREATE_SEPARATE_WOW_VDM = 2048
GLOBAL CONST $CREATE_SHARED_WOW_VDM = 4096
GLOBAL CONST $CREATE_SUSPENDED = 4
GLOBAL CONST $CREATE_UNICODE_ENVIRONMENT = 1024
GLOBAL CONST $LIST_MODULES_32BIT = 1
GLOBAL CONST $LIST_MODULES_64BIT = 2
GLOBAL CONST $LIST_MODULES_ALL = 3
GLOBAL CONST $LIST_MODULES_DEFAULT = 0
GLOBAL CONST $ABOVE_NORMAL_PRIORITY_CLASS = 32768
GLOBAL CONST $BELOW_NORMAL_PRIORITY_CLASS = 16384
GLOBAL CONST $HIGH_PRIORITY_CLASS = 128
GLOBAL CONST $IDLE_PRIORITY_CLASS = 64
GLOBAL CONST $NORMAL_PRIORITY_CLASS = 32
GLOBAL CONST $REALTIME_PRIORITY_CLASS = 256
GLOBAL CONST $PROCESS_MODE_BACKGROUND_BEGIN = 1048576
GLOBAL CONST $PROCESS_MODE_BACKGROUND_END = 2097152
GLOBAL CONST $MUTEX_MODIFY_STATE = 1
GLOBAL CONST $MUTEX_ALL_ACCESS = 2031617
GLOBAL CONST $JOB_OBJECT_ASSIGN_PROCESS = 1
GLOBAL CONST $JOB_OBJECT_QUERY = 4
GLOBAL CONST $JOB_OBJECT_SET_ATTRIBUTES = 2
GLOBAL CONST $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 16
GLOBAL CONST $JOB_OBJECT_TERMINATE = 8
GLOBAL CONST $JOB_OBJECT_ALL_ACCESS = 2031647
GLOBAL CONST $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 8
GLOBAL CONST $JOB_OBJECT_LIMIT_AFFINITY = 16
GLOBAL CONST $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 2048
GLOBAL CONST $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 1024
GLOBAL CONST $JOB_OBJECT_LIMIT_JOB_MEMORY = 512
GLOBAL CONST $JOB_OBJECT_LIMIT_JOB_TIME = 4
GLOBAL CONST $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 8192
GLOBAL CONST $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 64
GLOBAL CONST $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 32
GLOBAL CONST $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 256
GLOBAL CONST $JOB_OBJECT_LIMIT_PROCESS_TIME = 2
GLOBAL CONST $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 128
GLOBAL CONST $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 4096
GLOBAL CONST $JOB_OBJECT_LIMIT_WORKINGSET = 1
GLOBAL CONST $JOB_OBJECT_UILIMIT_DESKTOP = 64
GLOBAL CONST $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 16
GLOBAL CONST $JOB_OBJECT_UILIMIT_EXITWINDOWS = 128
GLOBAL CONST $JOB_OBJECT_UILIMIT_GLOBALATOMS = 32
GLOBAL CONST $JOB_OBJECT_UILIMIT_HANDLES = 1
GLOBAL CONST $JOB_OBJECT_UILIMIT_READCLIPBOARD = 2
GLOBAL CONST $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 8
GLOBAL CONST $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 4
GLOBAL CONST $JOB_OBJECT_SECURITY_FILTER_TOKENS = 8
GLOBAL CONST $JOB_OBJECT_SECURITY_NO_ADMIN = 1
GLOBAL CONST $JOB_OBJECT_SECURITY_ONLY_TOKEN = 4
GLOBAL CONST $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 2
GLOBAL CONST $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
GLOBAL CONST $JOB_OBJECT_POST_AT_END_OF_JOB = 1
GLOBAL CONST $SEMAPHORE_MODIFY_STATE = 2
GLOBAL CONST $SEMAPHORE_QUERY_STATE = 1
GLOBAL CONST $SEMAPHORE_ALL_ACCESS = 2031619
GLOBAL CONST $ES_AWAYMODE_REQUIRED = 64
GLOBAL CONST $ES_CONTINUOUS = -2147483648
GLOBAL CONST $ES_DISPLAY_REQUIRED = 2
GLOBAL CONST $ES_SYSTEM_REQUIRED = 1
GLOBAL CONST $ES_USER_PRESENT = 4
#Region Global Variables and Constants
	GLOBAL CONST $TAGIO_COUNTERS = "struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;endstruct"
	GLOBAL CONST $TAGJOBOBJECT_ASSOCIATE_COMPLETION_PORT = "ulong_ptr CompletionKey;ptr CompletionPort"
	GLOBAL CONST $TAGJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = "struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;endstruct"
	GLOBAL CONST $TAGJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $TAGJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & ";" & $TAGIO_COUNTERS
	GLOBAL CONST $TAGJOBOBJECT_BASIC_LIMIT_INFORMATION = "struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct"
	GLOBAL CONST $TAGJOBOBJECT_BASIC_PROCESS_ID_LIST = "dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList"
	GLOBAL CONST $TAGJOBOBJECT_BASIC_UI_RESTRICTIONS = "dword UIRestrictionsClass"
	GLOBAL CONST $TAGJOBOBJECT_END_OF_JOB_TIME_INFORMATION = "dword EndOfJobTimeAction"
	GLOBAL CONST $TAGJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $TAGJOBOBJECT_BASIC_LIMIT_INFORMATION & ";" & $TAGIO_COUNTERS & ";ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed"
	GLOBAL CONST $TAGJOBOBJECT_GROUP_INFORMATION = ""
	GLOBAL CONST $TAGJOBOBJECT_SECURITY_LIMIT_INFORMATION = "dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids"
	GLOBAL CONST $TAGMODULEINFO = "ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint"
	GLOBAL CONST $TAGPROCESSENTRY32 = "dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_ADJUSTTOKENPRIVILEGES($HTOKEN, $APRIVILEGES, $IATTRIBUTES, BYREF $AADJUST)
		$AADJUST = 0
		IF NOT $APRIVILEGES AND ISNUMBER($APRIVILEGES) THEN RETURN 0
		LOCAL $TTP1 = 0, $TTP2, $ICOUNT, $ACALL, $BDISABLE = FALSE
		IF $APRIVILEGES = -1 THEN
			$TTP2 = DLLSTRUCTCREATE("dword")
			$ACALL = DLLCALL("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $HTOKEN, "bool", 1, "ptr", 0, "dword", 0, "struct*", $TTP2, "dword*", 0)
			IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
			LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
			SWITCH $ILASTERROR
				CASE 122
					$TTP2 = DLLSTRUCTCREATE("dword;dword[" & ($ACALL[6] / 4 - 1) & "]")
					IF @ERROR THEN
						CONTINUECASE
					ENDIF
				CASE ELSE
					RETURN SETERROR(10, $ILASTERROR, 0)
			ENDSWITCH
			$BDISABLE = TRUE
		ELSE
			LOCAL $APREV = 0
			IF NOT ISARRAY($APRIVILEGES) THEN
				DIM $APREV[1][2]
				$APREV[0][0] = $APRIVILEGES
				$APREV[0][1] = $IATTRIBUTES
			ELSE
				IF NOT UBOUND($APRIVILEGES, $UBOUND_COLUMNS) THEN
					$ICOUNT = UBOUND($APRIVILEGES)
					DIM $APREV[$ICOUNT][2]
					FOR $I = 0 TO $ICOUNT - 1
						$APREV[$I][0] = $APRIVILEGES[$I]
						$APREV[$I][1] = $IATTRIBUTES
					NEXT
				ENDIF
			ENDIF
			IF ISARRAY($APREV) THEN
				$APRIVILEGES = $APREV
			ENDIF
			LOCAL $TAGSTRUCT = "dword;dword[" & (3 * UBOUND($APRIVILEGES)) & "]"
			$TTP1 = DLLSTRUCTCREATE($TAGSTRUCT)
			$TTP2 = DLLSTRUCTCREATE($TAGSTRUCT)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 20, 0, 0)
			DLLSTRUCTSETDATA($TTP1, 1, UBOUND($APRIVILEGES))
			FOR $I = 0 TO UBOUND($APRIVILEGES) - 1
				DLLSTRUCTSETDATA($TTP1, 2, $APRIVILEGES[$I][1], 3 * $I + 3)
				$ACALL = DLLCALL("advapi32.dll", "bool", "LookupPrivilegeValueW", "ptr", 0, "wstr", $APRIVILEGES[$I][0], "ptr", DLLSTRUCTGETPTR($TTP1, 2) + 12 * $I)
				IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 100, @EXTENDED, 0)
			NEXT
		ENDIF
		$ACALL = DLLCALL("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $HTOKEN, "bool", $BDISABLE, "struct*", $TTP1, "dword", DLLSTRUCTGETSIZE($TTP2), "struct*", $TTP2, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 200, @EXTENDED, 0)
		LOCAL $IRESULT
		SWITCH _WINAPI_GETLASTERROR()
			CASE 1300
				$IRESULT = 1
			CASE ELSE
				$IRESULT = 0
		ENDSWITCH
		$ICOUNT = DLLSTRUCTGETDATA($TTP2, 1)
		IF $ICOUNT THEN
			LOCAL $TDATA = DLLSTRUCTCREATE("wchar[128]")
			DIM $APRIVILEGES[$ICOUNT][2]
			FOR $I = 0 TO $ICOUNT - 1
				$ACALL = DLLCALL("advapi32.dll", "bool", "LookupPrivilegeNameW", "ptr", 0, "ptr", DLLSTRUCTGETPTR($TTP2, 2) + 12 * $I, "struct*", $TDATA, "dword*", 128)
				IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 300, @EXTENDED, 0)
				$APRIVILEGES[$I][1] = DLLSTRUCTGETDATA($TTP2, 2, 3 * $I + 3)
				$APRIVILEGES[$I][0] = DLLSTRUCTGETDATA($TDATA, 1)
			NEXT
			$AADJUST = $APRIVILEGES
		ENDIF
		RETURN SETEXTENDED($IRESULT, 1)
	ENDFUNC
	FUNC _WINAPI_ASSIGNPROCESSTOJOBOBJECT($HJOB, $HPROCESS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "AssignProcessToJobObject", "handle", $HJOB, "handle", $HPROCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ATTACHCONSOLE($IPID = -1)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "AttachConsole", "dword", $IPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ATTACHTHREADINPUT($IATTACH, $IATTACHTO, $BATTACH)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "AttachThreadInput", "dword", $IATTACH, "dword", $IATTACHTO, "bool", $BATTACH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEEVENT($TATTRIBUTES = 0, $BMANUALRESET = TRUE, $BINITIALSTATE = TRUE, $SNAME = "")
		IF $SNAME = "" THEN $SNAME = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "CreateEventW", "struct*", $TATTRIBUTES, "bool", $BMANUALRESET, "bool", $BINITIALSTATE, "wstr", $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
		IF $ILASTERROR THEN RETURN SETEXTENDED($ILASTERROR, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEJOBOBJECT($SNAME = "", $TSECURITY = 0)
		IF NOT STRINGSTRIPWS($SNAME, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SNAME = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "CreateJobObjectW", "struct*", $TSECURITY, "wstr", $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEMUTEX($SMUTEX, $BINITIAL = TRUE, $TSECURITY = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "CreateMutexW", "struct*", $TSECURITY, "bool", $BINITIAL, "wstr", $SMUTEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEPROCESS($SAPPNAME, $SCOMMAND, $TSECURITY, $TTHREAD, $BINHERIT, $IFLAGS, $PENVIRON, $SDIR, $TSTARTUPINFO, $TPROCESS)
		LOCAL $TCOMMAND = 0
		IF $SAPPNAME = "" THEN $SAPPNAME = NULL
		IF $SCOMMAND <> "" THEN
			$TCOMMAND = DLLSTRUCTCREATE("wchar Text[" & 260 + 1 & "]")
			DLLSTRUCTSETDATA($TCOMMAND, "Text", $SCOMMAND)
		ENDIF
		IF $SDIR = "" THEN $SDIR = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "CreateProcessW", "wstr", $SAPPNAME, "struct*", $TCOMMAND, "struct*", $TSECURITY, "struct*", $TTHREAD, "bool", $BINHERIT, "dword", $IFLAGS, "struct*", $PENVIRON, "wstr", $SDIR, "struct*", $TSTARTUPINFO, "struct*", $TPROCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEPROCESSWITHTOKEN($SAPP, $SCMD, $IFLAGS, $TSTARTUPINFO, $TPROCESSINFO, $HTOKEN, $ILOGON = 0, $PENVIRONMENT = 0, $SDIR = "")
		IF NOT STRINGSTRIPWS($SAPP, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SAPP = NULL
		IF NOT STRINGSTRIPWS($SCMD, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SCMD = NULL
		IF NOT STRINGSTRIPWS($SDIR, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN $SDIR = NULL
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $HTOKEN, "dword", $ILOGON, "wstr", $SAPP, "wstr", $SCMD, "dword", $IFLAGS, "struct*", $PENVIRONMENT, "wstr", $SDIR, "struct*", $TSTARTUPINFO, "struct*", $TPROCESSINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATESEMAPHORE($SSEMAPHORE, $IINITIAL, $IMAXIMUM, $TSECURITY = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "CreateSemaphoreW", "struct*", $TSECURITY, "long", $IINITIAL, "long", $IMAXIMUM, "wstr", $SSEMAPHORE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DUPLICATETOKENEX($HTOKEN, $IACCESS, $ILEVEL, $ITYPE = 1, $TSECURITY = 0)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $HTOKEN, "dword", $IACCESS, "struct*", $TSECURITY, "int", $ILEVEL, "int", $ITYPE, "handle*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[6]
	ENDFUNC
	FUNC _WINAPI_EMPTYWORKINGSET($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1280 : 4352), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EmptyWorkingSet", "handle", $HPROCESS[0])
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ENUMCHILDPROCESS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HSNAPSHOT = DLLCALL("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 2, "dword", 0)
		IF @ERROR OR($HSNAPSHOT[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TPROCESSENTRY32 = DLLSTRUCTCREATE($TAGPROCESSENTRY32)
		LOCAL $ARET[101][2] = [[0]]
		$HSNAPSHOT = $HSNAPSHOT[0]
		DLLSTRUCTSETDATA($TPROCESSENTRY32, "Size", DLLSTRUCTGETSIZE($TPROCESSENTRY32))
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "Process32FirstW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
		LOCAL $IERROR = @ERROR
		WHILE(NOT @ERROR) AND($ACALL[0])
			IF DLLSTRUCTGETDATA($TPROCESSENTRY32, "ParentProcessID") = $IPID THEN
				__INC($ARET)
				$ARET[$ARET[0][0]][0] = DLLSTRUCTGETDATA($TPROCESSENTRY32, "ProcessID")
				$ARET[$ARET[0][0]][1] = DLLSTRUCTGETDATA($TPROCESSENTRY32, "ExeFile")
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "Process32NextW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
			$IERROR = @ERROR
		WEND
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HSNAPSHOT)
		IF NOT $ARET[0][0] THEN RETURN SETERROR($IERROR + 20, 0, 0)
		__INC($ARET, -1)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_ENUMDEVICEDRIVERS()
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumDeviceDrivers", "ptr", 0, "dword", 0, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ISIZE
		IF @AUTOITX64 THEN
			$ISIZE = $ACALL[3] / 8
		ELSE
			$ISIZE = $ACALL[3] / 4
		ENDIF
		LOCAL $TDATA = DLLSTRUCTCREATE("ptr[" & $ISIZE & "]")
		$ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumDeviceDrivers", "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA), "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET[$ISIZE + 1] = [$ISIZE]
		FOR $I = 1 TO $ISIZE
			$ARET[$I] = DLLSTRUCTGETDATA($TDATA, 1, $I)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_ENUMPROCESSHANDLES($IPID = 0, $ITYPE = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $ARET[101][4] = [[0]]
		LOCAL $TAGSYSTEM_HANDLE_TABLE_ENTRY_INFO = "ulong ProcessId;byte ObjectTypeNumber;byte Flags;ushort Handle;ptr Object;ulong GrantedAccess"
		LOCAL $THANDLE = DLLSTRUCTCREATE($TAGSYSTEM_HANDLE_TABLE_ENTRY_INFO)
		LOCAL $IENTRYSIZE = DLLSTRUCTGETSIZE($THANDLE)
		LOCAL $IMAXENTRIES = 262143
		LOCAL $TSHI = DLLSTRUCTCREATE("ulong_ptr NumberOfHandles;byte Data[" & ($IMAXENTRIES + 1) * $IENTRYSIZE & "]")
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "ZwQuerySystemInformation", "uint", 16, "struct*", $TSHI, "ulong", DLLSTRUCTGETSIZE($TSHI), "ulong*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		LOCAL $PDATA = DLLSTRUCTGETPTR($TSHI, "Data")
		LOCAL $I, $INUMBEROFHANDLES = DLLSTRUCTGETDATA($TSHI, "NumberOfHandles")
		FOR $I = 1 TO $INUMBEROFHANDLES
			IF $I > $IMAXENTRIES THEN EXITLOOP
			$THANDLE = DLLSTRUCTCREATE($TAGSYSTEM_HANDLE_TABLE_ENTRY_INFO, $PDATA + ($I - 1) * $IENTRYSIZE)
			IF(DLLSTRUCTGETDATA($THANDLE, "ProcessId") = $IPID) AND((NOT $ITYPE) OR($ITYPE = DLLSTRUCTGETDATA($THANDLE, "ObjectTypeNumber"))) THEN
				__INC($ARET)
				$ARET[$ARET[0][0]][0] = PTR(DLLSTRUCTGETDATA($THANDLE, "Handle"))
				$ARET[$ARET[0][0]][1] = DLLSTRUCTGETDATA($THANDLE, "ObjectTypeNumber")
				$ARET[$ARET[0][0]][2] = DLLSTRUCTGETDATA($THANDLE, "Flags")
				$ARET[$ARET[0][0]][3] = DLLSTRUCTGETDATA($THANDLE, "GrantedAccess")
			ENDIF
		NEXT
		IF NOT $ARET[0][0] THEN RETURN SETERROR(11, 0, 0)
		__INC($ARET, -1)
		IF $I < $INUMBEROFHANDLES THEN RETURN SETEXTENDED($INUMBEROFHANDLES, $ARET)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_ENUMPROCESSMODULES($IPID = 0, $IFLAG = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ICOUNT, $ACALL, $IERROR = 0
		DO
			IF _WINAPI_GETVERSION() >= 6 THEN
				$ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumProcessModulesEx", "handle", $HPROCESS[0], "ptr", 0, "dword", 0, "dword*", 0, "dword", $IFLAG)
			ELSE
				$ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumProcessModules", "handle", $HPROCESS[0], "ptr", 0, "dword", 0, "dword*", 0)
			ENDIF
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			IF @AUTOITX64 THEN
				$ICOUNT = $ACALL[4] / 8
			ELSE
				$ICOUNT = $ACALL[4] / 4
			ENDIF
			LOCAL $TPTR = DLLSTRUCTCREATE("ptr[" & $ICOUNT & "]")
			IF @ERROR THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			IF _WINAPI_GETVERSION() >= 6 THEN
				$ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumProcessModulesEx", "handle", $HPROCESS[0], "struct*", $TPTR, "dword", DLLSTRUCTGETSIZE($TPTR), "dword*", 0, "dword", $IFLAG)
			ELSE
				$ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumProcessModules", "handle", $HPROCESS[0], "struct*", $TPTR, "dword", DLLSTRUCTGETSIZE($TPTR), "dword*", 0)
			ENDIF
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			LOCAL $ARET[$ICOUNT + 1][2] = [[$ICOUNT]]
			FOR $I = 1 TO $ICOUNT
				$ARET[$I][0] = DLLSTRUCTGETDATA($TPTR, 1, $I)
				$ARET[$I][1] = _WINAPI_GETMODULEFILENAMEEX($HPROCESS[0], $ARET[$I][0])
			NEXT
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_ENUMPROCESSTHREADS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HSNAPSHOT = DLLCALL("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 4, "dword", 0)
		IF @ERROR OR NOT $HSNAPSHOT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL CONST $TAGTHREADENTRY32 = "dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags"
		LOCAL $TTHREADENTRY32 = DLLSTRUCTCREATE($TAGTHREADENTRY32)
		LOCAL $ARET[101] = [0]
		$HSNAPSHOT = $HSNAPSHOT[0]
		DLLSTRUCTSETDATA($TTHREADENTRY32, "Size", DLLSTRUCTGETSIZE($TTHREADENTRY32))
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "Thread32First", "handle", $HSNAPSHOT, "struct*", $TTHREADENTRY32)
		WHILE NOT @ERROR AND $ACALL[0]
			IF DLLSTRUCTGETDATA($TTHREADENTRY32, "OwnerProcessID") = $IPID THEN
				__INC($ARET)
				$ARET[$ARET[0]] = DLLSTRUCTGETDATA($TTHREADENTRY32, "ThreadID")
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "Thread32Next", "handle", $HSNAPSHOT, "struct*", $TTHREADENTRY32)
		WEND
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HSNAPSHOT)
		IF NOT $ARET[0] THEN RETURN SETERROR(1, 0, 0)
		__INC($ARET, -1)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_ENUMPROCESSWINDOWS($IPID = 0, $BVISIBLE = TRUE)
		LOCAL $ATHREADS = _WINAPI_ENUMPROCESSTHREADS($IPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumWindowsProc", "bool", "hwnd;lparam")
		DIM $__G_VENUM[101][2] = [[0]]
		FOR $I = 1 TO $ATHREADS[0]
			DLLCALL("user32.dll", "bool", "EnumThreadWindows", "dword", $ATHREADS[$I], "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", $BVISIBLE)
			IF @ERROR THEN
				EXITLOOP
			ENDIF
		NEXT
		DLLCALLBACKFREE($HENUMPROC)
		IF NOT $__G_VENUM[0][0] THEN RETURN SETERROR(11, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_FATALAPPEXIT($SMESSAGE)
		DLLCALL("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $SMESSAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED)
	ENDFUNC
	FUNC _WINAPI_GETCURRENTPROCESSEXPLICITAPPUSERMODELID()
		LOCAL $ACALL = DLLCALL("shell32.dll", "long", "GetCurrentProcessExplicitAppUserModelID", "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		LOCAL $SID = _WINAPI_GETSTRING($ACALL[1])
		_WINAPI_COTASKMEMFREE($ACALL[1])
		RETURN $SID
	ENDFUNC
	FUNC _WINAPI_GETCURRENTPROCESSID()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetCurrentProcessId")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTTHREAD()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "GetCurrentThread")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTTHREADID()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetCurrentThreadId")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETDEVICEDRIVERBASENAME($PDRIVER)
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "dword", "GetDeviceDriverBaseNameW", "ptr", $PDRIVER, "wstr", "", "dword", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETDEVICEDRIVERFILENAME($PDRIVER)
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "dword", "GetDeviceDriverFileNameW", "ptr", $PDRIVER, "wstr", "", "dword", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETEXITCODEPROCESS($HPROCESS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetExitCodeProcess", "handle", $HPROCESS, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETGUIRESOURCES($IFLAG = 0, $HPROCESS = -1)
		IF $HPROCESS = -1 THEN $HPROCESS = _WINAPI_GETCURRENTPROCESS()
		LOCAL $ACALL = DLLCALL("user32.dll", "dword", "GetGuiResources", "handle", $HPROCESS, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETMODULEFILENAMEEX($HPROCESS, $HMODULE = 0)
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "dword", "GetModuleFileNameExW", "handle", $HPROCESS, "handle", $HMODULE, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_GETMODULEINFORMATION($HPROCESS, $HMODULE = 0)
		LOCAL $TMODULEINFO = DLLSTRUCTCREATE($TAGMODULEINFO)
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "GetModuleInformation", "handle", $HPROCESS, "handle", $HMODULE, "struct*", $TMODULEINFO, "dword", DLLSTRUCTGETSIZE($TMODULEINFO))
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TMODULEINFO
	ENDFUNC
	FUNC _WINAPI_GETPARENTPROCESS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HSNAPSHOT = DLLCALL("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 2, "dword", 0)
		IF @ERROR OR NOT $HSNAPSHOT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TPROCESSENTRY32 = DLLSTRUCTCREATE($TAGPROCESSENTRY32)
		LOCAL $IRESULT = 0
		$HSNAPSHOT = $HSNAPSHOT[0]
		DLLSTRUCTSETDATA($TPROCESSENTRY32, "Size", DLLSTRUCTGETSIZE($TPROCESSENTRY32))
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "Process32FirstW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
		LOCAL $IERROR = @ERROR
		WHILE(NOT @ERROR) AND($ACALL[0])
			IF DLLSTRUCTGETDATA($TPROCESSENTRY32, "ProcessID") = $IPID THEN
				$IRESULT = DLLSTRUCTGETDATA($TPROCESSENTRY32, "ParentProcessID")
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "Process32NextW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
			$IERROR = @ERROR
		WEND
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HSNAPSHOT)
		IF NOT $IRESULT THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $IRESULT
	ENDFUNC
	FUNC _WINAPI_GETPRIORITYCLASS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $IERROR = 0
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetPriorityClass", "handle", $HPROCESS[0])
		IF @ERROR THEN $IERROR = @ERROR
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETPROCESSAFFINITYMASK($HPROCESS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $HPROCESS, "dword_ptr*", 0, "dword_ptr*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $AMASK[3]
		$AMASK[0] = TRUE
		$AMASK[1] = $ACALL[2]
		$AMASK[2] = $ACALL[3]
		RETURN $AMASK
	ENDFUNC
	FUNC _WINAPI_GETPROCESSCOMMANDLINE($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$HPROCESS = $HPROCESS[0]
		LOCAL $TPBI = DLLSTRUCTCREATE("ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId")
		LOCAL $TPEB = DLLSTRUCTCREATE("byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId")
		LOCAL $TUPP = DLLSTRUCTCREATE("ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5")
		LOCAL $TCMD
		LOCAL $ACALL, $IERROR = 0
		DO
			$ACALL = DLLCALL("ntdll.dll", "long", "NtQueryInformationProcess", "handle", $HPROCESS, "ulong", 0, "struct*", $TPBI, "ulong", DLLSTRUCTGETSIZE($TPBI), "ulong*", 0)
			IF @ERROR OR $ACALL[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TPBI, "PebBaseAddress"), "struct*", $TPEB, "ulong_ptr", DLLSTRUCTGETSIZE($TPEB), "ulong_ptr*", 0)
			IF @ERROR OR NOT $ACALL[0] OR(NOT $ACALL[5]) THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TPEB, "ProcessParameters"), "struct*", $TUPP, "ulong_ptr", DLLSTRUCTGETSIZE($TUPP), "ulong_ptr*", 0)
			IF @ERROR OR NOT $ACALL[0] OR(NOT $ACALL[5]) THEN
				$IERROR = @ERROR + 50
				EXITLOOP
			ENDIF
			$TCMD = DLLSTRUCTCREATE("byte[" & DLLSTRUCTGETDATA($TUPP, "MaxLengthCommandLine") & "]")
			IF @ERROR THEN
				$IERROR = @ERROR + 60
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TUPP, "CommandLine"), "struct*", $TCMD, "ulong_ptr", DLLSTRUCTGETSIZE($TCMD), "ulong_ptr*", 0)
			IF @ERROR OR NOT $ACALL[0] OR(NOT $ACALL[5]) THEN
				$IERROR = @ERROR + 70
				EXITLOOP
			ENDIF
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
		RETURN STRINGSTRIPWS(_WINAPI_PATHGETARGS(_WINAPI_GETSTRING(DLLSTRUCTGETPTR($TCMD, 1))), $STR_STRIPLEADING + $STR_STRIPTRAILING)
	ENDFUNC
	FUNC _WINAPI_GETPROCESSFILENAME($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		LOCAL $SPATH = _WINAPI_GETMODULEFILENAMEEX($HPROCESS[0])
		LOCAL $IERROR = @ERROR
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR(@ERROR, 0, "")
		RETURN $SPATH
	ENDFUNC
	FUNC _WINAPI_GETPROCESSHANDLECOUNT($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetProcessHandleCount", "handle", $HPROCESS[0], "dword*", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETPROCESSID($HPROCESS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetProcessId", "handle", $HPROCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETPROCESSIOCOUNTERS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TIO_COUNTERS = DLLSTRUCTCREATE("uint64[6]")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetProcessIoCounters", "handle", $HPROCESS[0], "struct*", $TIO_COUNTERS)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET[6]
		FOR $I = 0 TO 5
			$ARET[$I] = DLLSTRUCTGETDATA($TIO_COUNTERS, 1, $I + 1)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETPROCESSMEMORYINFO($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TPMC_EX = DLLSTRUCTCREATE("dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr")
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "GetProcessMemoryInfo", "handle", $HPROCESS[0], "struct*", $TPMC_EX, "int", DLLSTRUCTGETSIZE($TPMC_EX))
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET[10]
		FOR $I = 0 TO 9
			$ARET[$I] = DLLSTRUCTGETDATA($TPMC_EX, $I + 2)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETPROCESSNAME($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HSNAPSHOT = DLLCALL("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 2, "dword", 0)
		IF @ERROR OR NOT $HSNAPSHOT[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$HSNAPSHOT = $HSNAPSHOT[0]
		LOCAL $TPROCESSENTRY32 = DLLSTRUCTCREATE($TAGPROCESSENTRY32)
		DLLSTRUCTSETDATA($TPROCESSENTRY32, "Size", DLLSTRUCTGETSIZE($TPROCESSENTRY32))
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "Process32FirstW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
		LOCAL $IERROR = @ERROR
		WHILE(NOT @ERROR) AND($ACALL[0])
			IF DLLSTRUCTGETDATA($TPROCESSENTRY32, "ProcessID") = $IPID THEN
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "Process32NextW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
			$IERROR = @ERROR
		WEND
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HSNAPSHOT)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
		IF NOT $ACALL[0] THEN SETERROR(10, 0, "")
		RETURN DLLSTRUCTGETDATA($TPROCESSENTRY32, "ExeFile")
	ENDFUNC
	FUNC _WINAPI_GETPROCESSTIMES($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TFILETIME = DLLSTRUCTCREATE($TAGFILETIME)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetProcessTimes", "handle", $HPROCESS[0], "struct*", $TFILETIME, "uint64*", 0, "uint64*", 0, "uint64*", 0)
		IF __CHECKERRORCLOSEHANDLE($ACALL, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET[3]
		$ARET[0] = $TFILETIME
		$ARET[1] = $ACALL[4]
		$ARET[2] = $ACALL[5]
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETPROCESSUSER($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $TSID, $HTOKEN, $ACALL
		LOCAL $IERROR = 0
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		DO
			$HTOKEN = _WINAPI_OPENPROCESSTOKEN(8, $HPROCESS[0])
			IF NOT $HTOKEN THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$TSID = DLLSTRUCTCREATE("ptr;byte[1024]")
			$ACALL = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "uint", 1, "struct*", $TSID, "dword", DLLSTRUCTGETSIZE($TSID), "dword*", 0)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("advapi32.dll", "bool", "LookupAccountSidW", "ptr", 0, "ptr", DLLSTRUCTGETDATA($TSID, 1), "wstr", "", "dword*", 2048, "wstr", "", "dword*", 2048, "uint*", 0)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
		UNTIL 1
		IF $HTOKEN THEN
			DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HTOKEN)
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		LOCAL $ARET[2]
		$ARET[0] = $ACALL[3]
		$ARET[1] = $ACALL[5]
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETPROCESSWORKINGDIRECTORY($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $ACALL, $IERROR = 0
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$HPROCESS = $HPROCESS[0]
		LOCAL $TPBI = DLLSTRUCTCREATE("ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId")
		LOCAL $TPEB = DLLSTRUCTCREATE("byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId")
		LOCAL $TUPP = DLLSTRUCTCREATE("ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5")
		LOCAL $TDIR
		DO
			$ACALL = DLLCALL("ntdll.dll", "long", "NtQueryInformationProcess", "handle", $HPROCESS, "ulong", 0, "struct*", $TPBI, "ulong", DLLSTRUCTGETSIZE($TPBI), "ulong*", 0)
			IF @ERROR OR($ACALL[0]) THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TPBI, "PebBaseAddress"), "struct*", $TPEB, "ulong_ptr", DLLSTRUCTGETSIZE($TPEB), "ulong_ptr*", 0)
			IF @ERROR OR(NOT $ACALL[0]) OR(NOT $ACALL[5]) THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TPEB, "ProcessParameters"), "struct*", $TUPP, "ulong_ptr", DLLSTRUCTGETSIZE($TUPP), "ulong_ptr*", 0)
			IF @ERROR OR(NOT $ACALL[0]) OR(NOT $ACALL[5]) THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			$TDIR = DLLSTRUCTCREATE("byte[" & DLLSTRUCTGETDATA($TUPP, "MaxLengthCurrentDirectory") & "]")
			IF @ERROR THEN
				$IERROR = @ERROR + 50
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TUPP, "CurrentDirectory"), "struct*", $TDIR, "ulong_ptr", DLLSTRUCTGETSIZE($TDIR), "ulong_ptr*", 0)
			IF @ERROR OR(NOT $ACALL[0]) OR(NOT $ACALL[5]) THEN
				$IERROR = @ERROR + 60
				EXITLOOP
			ENDIF
			$IERROR = 0
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
		RETURN _WINAPI_PATHREMOVEBACKSLASH(_WINAPI_GETSTRING(DLLSTRUCTGETPTR($TDIR)))
	ENDFUNC
	FUNC _WINAPI_GETTHREADDESKTOP($ITHREADID)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetThreadDesktop", "dword", $ITHREADID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETTHREADERRORMODE()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetThreadErrorMode")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWFILENAME($HWND)
		LOCAL $IPID = 0
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsWindow", "hwnd", $HWND)
		IF $ACALL[0] THEN
			$ACALL = DLLCALL("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $HWND, "dword*", 0)
			$IPID = $ACALL[2]
		ENDIF
		IF NOT $IPID THEN RETURN SETERROR(1, 0, "")
		LOCAL $SRESULT = _WINAPI_GETPROCESSFILENAME($IPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $SRESULT
	ENDFUNC
	FUNC _WINAPI_ISELEVATED()
		LOCAL $IELEV, $ACALL, $IERROR = 0
		LOCAL $HTOKEN = _WINAPI_OPENPROCESSTOKEN(8)
		IF NOT $HTOKEN THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		DO
			$ACALL = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "uint", 20, "uint*", 0, "dword", 4, "dword*", 0)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$IELEV = $ACALL[3]
			$ACALL = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "uint", 18, "uint*", 0, "dword", 4, "dword*", 0)
			IF @ERROR OR NOT $ACALL[0] THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HTOKEN)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, FALSE)
		RETURN SETEXTENDED($ACALL[0] - 1, $IELEV)
	ENDFUNC
	FUNC _WINAPI_ISPROCESSINJOB($HPROCESS, $HJOB = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "IsProcessInJob", "handle", $HPROCESS, "handle", $HJOB, "bool*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_OPENJOBOBJECT($SNAME, $IACCESS = $JOB_OBJECT_ALL_ACCESS, $BINHERIT = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "OpenJobObjectW", "dword", $IACCESS, "bool", $BINHERIT, "wstr", $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OPENMUTEX($SMUTEX, $IACCESS = $MUTEX_ALL_ACCESS, $BINHERIT = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "OpenMutexW", "dword", $IACCESS, "bool", $BINHERIT, "wstr", $SMUTEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OPENPROCESS($IACCESS, $BINHERIT, $IPID, $BDEBUGPRIV = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", $IACCESS, "bool", $BINHERIT, "dword", $IPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN $ACALL[0]
		IF NOT $BDEBUGPRIV THEN RETURN SETERROR(100, 0, 0)
		LOCAL $HTOKEN = _SECURITY__OPENTHREADTOKENEX(BITOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		_SECURITY__SETPRIVILEGE($HTOKEN, $SE_DEBUG_NAME, TRUE)
		LOCAL $IERROR = @ERROR
		LOCAL $IEXTENDED = @EXTENDED
		LOCAL $IRET = 0
		IF NOT @ERROR THEN
			$ACALL = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", $IACCESS, "bool", $BINHERIT, "dword", $IPID)
			$IERROR = @ERROR
			$IEXTENDED = @EXTENDED
			IF $ACALL[0] THEN $IRET = $ACALL[0]
			_SECURITY__SETPRIVILEGE($HTOKEN, $SE_DEBUG_NAME, FALSE)
			IF @ERROR THEN
				$IERROR = @ERROR + 20
				$IEXTENDED = @EXTENDED
			ENDIF
		ELSE
			$IERROR = @ERROR + 30
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HTOKEN)
		RETURN SETERROR($IERROR, $IEXTENDED, $IRET)
	ENDFUNC
	FUNC _WINAPI_OPENPROCESSTOKEN($IACCESS, $HPROCESS = 0)
		IF NOT $HPROCESS THEN
			$HPROCESS = DLLCALL("kernel32.dll", "handle", "GetCurrentProcess")
			$HPROCESS = $HPROCESS[0]
		ENDIF
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "OpenProcessToken", "handle", $HPROCESS, "dword", $IACCESS, "handle*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_OPENSEMAPHORE($SSEMAPHORE, $IACCESS = 2031619, $BINHERIT = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "OpenSemaphoreW", "dword", $IACCESS, "bool", $BINHERIT, "wstr", $SSEMAPHORE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_QUERYINFORMATIONJOBOBJECT($HJOB, $IJOBOBJECTINFOCLASS, BYREF $TJOBOBJECTINFO)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "QueryInformationJobObject", "handle", $HJOB, "int", $IJOBOBJECTINFOCLASS, "struct*", $TJOBOBJECTINFO, "dword", DLLSTRUCTGETSIZE($TJOBOBJECTINFO), "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[5]
	ENDFUNC
	FUNC _WINAPI_RELEASEMUTEX($HMUTEX)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "ReleaseMutex", "handle", $HMUTEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RELEASESEMAPHORE($HSEMAPHORE, $IINCREASE = 1)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "ReleaseSemaphore", "handle", $HSEMAPHORE, "long", $IINCREASE, "long*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_RESETEVENT($HEVENT)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "ResetEvent", "handle", $HEVENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETEVENT($HEVENT)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetEvent", "handle", $HEVENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETINFORMATIONJOBOBJECT($HJOB, $IJOBOBJECTINFOCLASS, $TJOBOBJECTINFO)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetInformationJobObject", "handle", $HJOB, "int", $IJOBOBJECTINFOCLASS, "struct*", $TJOBOBJECTINFO, "dword", DLLSTRUCTGETSIZE($TJOBOBJECTINFO))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETPRIORITYCLASS($IPRIORITY, $IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 1536 : 4608), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $IERROR = 0
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetPriorityClass", "handle", $HPROCESS[0], "dword", $IPRIORITY)
		IF @ERROR THEN $IERROR = @ERROR
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETPROCESSAFFINITYMASK($HPROCESS, $IMASK)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $HPROCESS, "ulong_ptr", $IMASK)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETTHREADDESKTOP($HDESKTOP)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetThreadDesktop", "handle", $HDESKTOP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETTHREADERRORMODE($IMODE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetThreadErrorMode", "dword", $IMODE, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_SETTHREADEXECUTIONSTATE($IFLAGS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "SetThreadExecutionState", "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_TERMINATEJOBOBJECT($HJOB, $IEXITCODE = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "TerminateJobObject", "handle", $HJOB, "uint", $IEXITCODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_TERMINATEPROCESS($HPROCESS, $IEXITCODE = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "TerminateProcess", "handle", $HPROCESS, "uint", $IEXITCODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_USERHANDLEGRANTACCESS($HOBJECT, $HJOB, $BGRANT)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "UserHandleGrantAccess", "handle", $HOBJECT, "handle", $HJOB, "bool", $BGRANT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WAITFORINPUTIDLE($HPROCESS, $ITIMEOUT = -1)
		LOCAL $ACALL = DLLCALL("user32.dll", "dword", "WaitForInputIdle", "handle", $HPROCESS, "dword", $ITIMEOUT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WAITFORMULTIPLEOBJECTS($ICOUNT, $PAHANDLES, $BWAITALL = FALSE, $ITIMEOUT = -1)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $ICOUNT, "struct*", $PAHANDLES, "bool", $BWAITALL, "dword", $ITIMEOUT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WAITFORSINGLEOBJECT($HHANDLE, $ITIMEOUT = -1)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "INT", "WaitForSingleObject", "handle", $HHANDLE, "dword", $ITIMEOUT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WRITECONSOLE($HCONSOLE, $STEXT)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "WriteConsoleW", "handle", $HCONSOLE, "wstr", $STEXT, "dword", STRINGLEN($STEXT), "dword*", 0, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
GLOBAL CONST $LINGUISTIC_IGNORECASE = 16
GLOBAL CONST $LINGUISTIC_IGNOREDIACRITIC = 32
GLOBAL CONST $NORM_IGNORECASE = 1
GLOBAL CONST $NORM_IGNOREKANATYPE = 65536
GLOBAL CONST $NORM_IGNORENONSPACE = 2
GLOBAL CONST $NORM_IGNORESYMBOLS = 4
GLOBAL CONST $NORM_IGNOREWIDTH = 131072
GLOBAL CONST $NORM_LINGUISTIC_CASING = 134217728
GLOBAL CONST $SORT_DIGITSASNUMBERS = 8
GLOBAL CONST $SORT_STRINGSORT = 4096
GLOBAL CONST $CSTR_LESS_THAN = 1
GLOBAL CONST $CSTR_EQUAL = 2
GLOBAL CONST $CSTR_GREATER_THAN = 3
GLOBAL CONST $MUI_LANGUAGE_ID = 4
GLOBAL CONST $MUI_LANGUAGE_NAME = 8
GLOBAL CONST $DATE_AUTOLAYOUT = 64
GLOBAL CONST $DATE_LONGDATE = 2
GLOBAL CONST $DATE_LTRREADING = 16
GLOBAL CONST $DATE_SHORTDATE = 1
GLOBAL CONST $DATE_RTLREADING = 32
GLOBAL CONST $DATE_USE_ALT_CALENDAR = 4
GLOBAL CONST $DATE_YEARMONTH = 8
GLOBAL CONST $GEO_NATION = 1
GLOBAL CONST $GEO_LATITUDE = 2
GLOBAL CONST $GEO_LONGITUDE = 3
GLOBAL CONST $GEO_ISO2 = 4
GLOBAL CONST $GEO_ISO3 = 5
GLOBAL CONST $GEO_RFC1766 = 6
GLOBAL CONST $GEO_LCID = 7
GLOBAL CONST $GEO_FRIENDLYNAME = 8
GLOBAL CONST $GEO_OFFICIALNAME = 9
GLOBAL CONST $GEO_TIMEZONES = 10
GLOBAL CONST $GEO_OFFICIALLANGUAGES = 11
GLOBAL CONST $GEO_ISO_UN_NUMBER = 12
GLOBAL CONST $GEO_PARENT = 13
GLOBAL CONST $LOCALE_ILANGUAGE = 1
GLOBAL CONST $LOCALE_SLANGUAGE = 2
GLOBAL CONST $LOCALE_SENGLANGUAGE = 4097
GLOBAL CONST $LOCALE_SABBREVLANGNAME = 3
GLOBAL CONST $LOCALE_SNATIVELANGNAME = 4
GLOBAL CONST $LOCALE_ICOUNTRY = 5
GLOBAL CONST $LOCALE_SCOUNTRY = 6
GLOBAL CONST $LOCALE_SENGCOUNTRY = 4098
GLOBAL CONST $LOCALE_SABBREVCTRYNAME = 7
GLOBAL CONST $LOCALE_SNATIVECTRYNAME = 8
GLOBAL CONST $LOCALE_IDEFAULTLANGUAGE = 9
GLOBAL CONST $LOCALE_IDEFAULTCOUNTRY = 10
GLOBAL CONST $LOCALE_IDEFAULTCODEPAGE = 11
GLOBAL CONST $LOCALE_IDEFAULTANSICODEPAGE = 4100
GLOBAL CONST $LOCALE_IDEFAULTMACCODEPAGE = 4113
GLOBAL CONST $LOCALE_SLIST = 12
GLOBAL CONST $LOCALE_IMEASURE = 13
GLOBAL CONST $LOCALE_SDECIMAL = 14
GLOBAL CONST $LOCALE_STHOUSAND = 15
GLOBAL CONST $LOCALE_SGROUPING = 16
GLOBAL CONST $LOCALE_IDIGITS = 17
GLOBAL CONST $LOCALE_ILZERO = 18
GLOBAL CONST $LOCALE_INEGNUMBER = 4112
GLOBAL CONST $LOCALE_SNATIVEDIGITS = 19
GLOBAL CONST $LOCALE_SCURRENCY = 20
GLOBAL CONST $LOCALE_SINTLSYMBOL = 21
GLOBAL CONST $LOCALE_SMONDECIMALSEP = 22
GLOBAL CONST $LOCALE_SMONTHOUSANDSEP = 23
GLOBAL CONST $LOCALE_SMONGROUPING = 24
GLOBAL CONST $LOCALE_ICURRDIGITS = 25
GLOBAL CONST $LOCALE_IINTLCURRDIGITS = 26
GLOBAL CONST $LOCALE_ICURRENCY = 27
GLOBAL CONST $LOCALE_INEGCURR = 28
GLOBAL CONST $LOCALE_SDATE = 29
GLOBAL CONST $LOCALE_STIME = 30
GLOBAL CONST $LOCALE_SSHORTDATE = 31
GLOBAL CONST $LOCALE_SLONGDATE = 32
GLOBAL CONST $LOCALE_STIMEFORMAT = 4099
GLOBAL CONST $LOCALE_IDATE = 33
GLOBAL CONST $LOCALE_ILDATE = 34
GLOBAL CONST $LOCALE_ITIME = 35
GLOBAL CONST $LOCALE_ITIMEMARKPOSN = 4101
GLOBAL CONST $LOCALE_ICENTURY = 36
GLOBAL CONST $LOCALE_ITLZERO = 37
GLOBAL CONST $LOCALE_IDAYLZERO = 38
GLOBAL CONST $LOCALE_IMONLZERO = 39
GLOBAL CONST $LOCALE_S1159 = 40
GLOBAL CONST $LOCALE_S2359 = 41
GLOBAL CONST $LOCALE_ICALENDARTYPE = 4105
GLOBAL CONST $LOCALE_IOPTIONALCALENDAR = 4107
GLOBAL CONST $LOCALE_IFIRSTDAYOFWEEK = 4108
GLOBAL CONST $LOCALE_IFIRSTWEEKOFYEAR = 4109
GLOBAL CONST $LOCALE_SDAYNAME1 = 42
GLOBAL CONST $LOCALE_SDAYNAME2 = 43
GLOBAL CONST $LOCALE_SDAYNAME3 = 44
GLOBAL CONST $LOCALE_SDAYNAME4 = 45
GLOBAL CONST $LOCALE_SDAYNAME5 = 46
GLOBAL CONST $LOCALE_SDAYNAME6 = 47
GLOBAL CONST $LOCALE_SDAYNAME7 = 48
GLOBAL CONST $LOCALE_SABBREVDAYNAME1 = 49
GLOBAL CONST $LOCALE_SABBREVDAYNAME2 = 50
GLOBAL CONST $LOCALE_SABBREVDAYNAME3 = 51
GLOBAL CONST $LOCALE_SABBREVDAYNAME4 = 52
GLOBAL CONST $LOCALE_SABBREVDAYNAME5 = 53
GLOBAL CONST $LOCALE_SABBREVDAYNAME6 = 54
GLOBAL CONST $LOCALE_SABBREVDAYNAME7 = 55
GLOBAL CONST $LOCALE_SMONTHNAME1 = 56
GLOBAL CONST $LOCALE_SMONTHNAME2 = 57
GLOBAL CONST $LOCALE_SMONTHNAME3 = 58
GLOBAL CONST $LOCALE_SMONTHNAME4 = 59
GLOBAL CONST $LOCALE_SMONTHNAME5 = 60
GLOBAL CONST $LOCALE_SMONTHNAME6 = 61
GLOBAL CONST $LOCALE_SMONTHNAME7 = 62
GLOBAL CONST $LOCALE_SMONTHNAME8 = 63
GLOBAL CONST $LOCALE_SMONTHNAME9 = 64
GLOBAL CONST $LOCALE_SMONTHNAME10 = 65
GLOBAL CONST $LOCALE_SMONTHNAME11 = 66
GLOBAL CONST $LOCALE_SMONTHNAME12 = 67
GLOBAL CONST $LOCALE_SMONTHNAME13 = 4110
GLOBAL CONST $LOCALE_SABBREVMONTHNAME1 = 68
GLOBAL CONST $LOCALE_SABBREVMONTHNAME2 = 69
GLOBAL CONST $LOCALE_SABBREVMONTHNAME3 = 70
GLOBAL CONST $LOCALE_SABBREVMONTHNAME4 = 71
GLOBAL CONST $LOCALE_SABBREVMONTHNAME5 = 72
GLOBAL CONST $LOCALE_SABBREVMONTHNAME6 = 73
GLOBAL CONST $LOCALE_SABBREVMONTHNAME7 = 74
GLOBAL CONST $LOCALE_SABBREVMONTHNAME8 = 75
GLOBAL CONST $LOCALE_SABBREVMONTHNAME9 = 76
GLOBAL CONST $LOCALE_SABBREVMONTHNAME10 = 77
GLOBAL CONST $LOCALE_SABBREVMONTHNAME11 = 78
GLOBAL CONST $LOCALE_SABBREVMONTHNAME12 = 79
GLOBAL CONST $LOCALE_SABBREVMONTHNAME13 = 4111
GLOBAL CONST $LOCALE_SPOSITIVESIGN = 80
GLOBAL CONST $LOCALE_SNEGATIVESIGN = 81
GLOBAL CONST $LOCALE_IPOSSIGNPOSN = 82
GLOBAL CONST $LOCALE_INEGSIGNPOSN = 83
GLOBAL CONST $LOCALE_IPOSSYMPRECEDES = 84
GLOBAL CONST $LOCALE_IPOSSEPBYSPACE = 85
GLOBAL CONST $LOCALE_INEGSYMPRECEDES = 86
GLOBAL CONST $LOCALE_INEGSEPBYSPACE = 87
GLOBAL CONST $LOCALE_FONTSIGNATURE = 88
GLOBAL CONST $LOCALE_SISO639LANGNAME = 89
GLOBAL CONST $LOCALE_SISO3166CTRYNAME = 90
GLOBAL CONST $LOCALE_IDEFAULTEBCDICCODEPAGE = 4114
GLOBAL CONST $LOCALE_IPAPERSIZE = 4106
GLOBAL CONST $LOCALE_SENGCURRNAME = 4103
GLOBAL CONST $LOCALE_SNATIVECURRNAME = 4104
GLOBAL CONST $LOCALE_SYEARMONTH = 4102
GLOBAL CONST $LOCALE_SSORTNAME = 4115
GLOBAL CONST $LOCALE_IDIGITSUBSTITUTION = 4116
GLOBAL CONST $LOCALE_CUSTOM_DEFAULT = 3072
GLOBAL CONST $LOCALE_CUSTOM_UI_DEFAULT = 5120
GLOBAL CONST $LOCALE_CUSTOM_UNSPECIFIED = 4096
GLOBAL CONST $LOCALE_INVARIANT = 127
GLOBAL CONST $LOCALE_SYSTEM_DEFAULT = 2048
GLOBAL CONST $LOCALE_USER_DEFAULT = 1024
GLOBAL CONST $TIME_FORCE24HOURFORMAT = 8
GLOBAL CONST $TIME_NOMINUTESORSECONDS = 1
GLOBAL CONST $TIME_NOSECONDS = 2
GLOBAL CONST $TIME_NOTIMEMARKER = 4
GLOBAL CONST $LCID_INSTALLED = 1
GLOBAL CONST $LCID_SUPPORTED = 2
GLOBAL CONST $RT_ACCELERATOR = 9
GLOBAL CONST $RT_ANICURSOR = 21
GLOBAL CONST $RT_ANIICON = 22
GLOBAL CONST $RT_BITMAP = 2
GLOBAL CONST $RT_CURSOR = 1
GLOBAL CONST $RT_DIALOG = 5
GLOBAL CONST $RT_DLGINCLUDE = 17
GLOBAL CONST $RT_FONT = 8
GLOBAL CONST $RT_FONTDIR = 7
GLOBAL CONST $RT_GROUP_CURSOR = 12
GLOBAL CONST $RT_GROUP_ICON = 14
GLOBAL CONST $RT_HTML = 23
GLOBAL CONST $RT_ICON = 3
GLOBAL CONST $RT_MANIFEST = 24
GLOBAL CONST $RT_MENU = 4
GLOBAL CONST $RT_MESSAGETABLE = 11
GLOBAL CONST $RT_PLUGPLAY = 19
GLOBAL CONST $RT_RCDATA = 10
GLOBAL CONST $RT_STRING = 6
GLOBAL CONST $RT_VERSION = 16
GLOBAL CONST $RT_VXD = 20
GLOBAL CONST $FILE_VER_GET_LOCALISED = 1
GLOBAL CONST $FILE_VER_GET_NEUTRAL = 2
GLOBAL CONST $FILE_VER_GET_PREFETCHED = 4
GLOBAL CONST $OBM_TRTYPE = 32732
GLOBAL CONST $OBM_LFARROWI = 32734
GLOBAL CONST $OBM_RGARROWI = 32735
GLOBAL CONST $OBM_DNARROWI = 32736
GLOBAL CONST $OBM_UPARROWI = 32737
GLOBAL CONST $OBM_COMBO = 32738
GLOBAL CONST $OBM_MNARROW = 32739
GLOBAL CONST $OBM_LFARROWD = 32740
GLOBAL CONST $OBM_RGARROWD = 32741
GLOBAL CONST $OBM_DNARROWD = 32742
GLOBAL CONST $OBM_UPARROWD = 32743
GLOBAL CONST $OBM_RESTORED = 32744
GLOBAL CONST $OBM_ZOOMD = 32745
GLOBAL CONST $OBM_REDUCED = 32746
GLOBAL CONST $OBM_RESTORE = 32747
GLOBAL CONST $OBM_ZOOM = 32748
GLOBAL CONST $OBM_REDUCE = 32749
GLOBAL CONST $OBM_LFARROW = 32750
GLOBAL CONST $OBM_RGARROW = 32751
GLOBAL CONST $OBM_DNARROW = 32752
GLOBAL CONST $OBM_UPARROW = 32753
GLOBAL CONST $OBM_CLOSE = 32754
GLOBAL CONST $OBM_OLD_RESTORE = 32755
GLOBAL CONST $OBM_OLD_ZOOM = 32756
GLOBAL CONST $OBM_OLD_REDUCE = 32757
GLOBAL CONST $OBM_BTNCORNERS = 32758
GLOBAL CONST $OBM_CHECKBOXES = 32759
GLOBAL CONST $OBM_CHECK = 32760
GLOBAL CONST $OBM_BTSIZE = 32761
GLOBAL CONST $OBM_OLD_LFARROW = 32762
GLOBAL CONST $OBM_OLD_RGARROW = 32763
GLOBAL CONST $OBM_OLD_DNARROW = 32764
GLOBAL CONST $OBM_OLD_UPARROW = 32765
GLOBAL CONST $OBM_SIZE = 32766
GLOBAL CONST $OBM_OLD_CLOSE = 32767
GLOBAL CONST $OIC_SAMPLE = 32512
GLOBAL CONST $OIC_HAND = 32513
GLOBAL CONST $OIC_QUES = 32514
GLOBAL CONST $OIC_BANG = 32515
GLOBAL CONST $OIC_NOTE = 32516
GLOBAL CONST $OIC_WINLOGO = 32517
GLOBAL CONST $OIC_WARNING = $OIC_BANG
GLOBAL CONST $OIC_ERROR = $OIC_HAND
GLOBAL CONST $OIC_INFORMATION = $OIC_NOTE
GLOBAL CONST $DONT_RESOLVE_DLL_REFERENCES = 1
GLOBAL CONST $LOAD_LIBRARY_AS_DATAFILE = 2
GLOBAL CONST $LOAD_WITH_ALTERED_SEARCH_PATH = 8
GLOBAL CONST $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 16
GLOBAL CONST $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 64
GLOBAL CONST $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 32
GLOBAL CONST $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 512
GLOBAL CONST $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 4096
GLOBAL CONST $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 256
GLOBAL CONST $LOAD_LIBRARY_SEARCH_SYSTEM32 = 2048
GLOBAL CONST $LOAD_LIBRARY_SEARCH_USER_DIRS = 1024
GLOBAL CONST $OCR_NORMAL = 32512
GLOBAL CONST $OCR_IBEAM = 32513
GLOBAL CONST $OCR_WAIT = 32514
GLOBAL CONST $OCR_CROSS = 32515
GLOBAL CONST $OCR_UP = 32516
GLOBAL CONST $OCR_SIZE = 32640
GLOBAL CONST $OCR_ICON = 32641
GLOBAL CONST $OCR_SIZENWSE = 32642
GLOBAL CONST $OCR_SIZENESW = 32643
GLOBAL CONST $OCR_SIZEWE = 32644
GLOBAL CONST $OCR_SIZENS = 32645
GLOBAL CONST $OCR_SIZEALL = 32646
GLOBAL CONST $OCR_ICOCUR = 32647
GLOBAL CONST $OCR_NO = 32648
GLOBAL CONST $OCR_HAND = 32649
GLOBAL CONST $OCR_APPSTARTING = 32650
GLOBAL CONST $OCR_HELP = 32651
GLOBAL CONST $VS_FF_DEBUG = 1
GLOBAL CONST $VS_FF_INFOINFERRED = 16
GLOBAL CONST $VS_FF_PATCHED = 4
GLOBAL CONST $VS_FF_PRERELEASE = 2
GLOBAL CONST $VS_FF_PRIVATEBUILD = 8
GLOBAL CONST $VS_FF_SPECIALBUILD = 32
GLOBAL CONST $VOS_DOS = 65536
GLOBAL CONST $VOS_NT = 262144
GLOBAL CONST $VOS__WINDOWS16 = 1
GLOBAL CONST $VOS__WINDOWS32 = 4
GLOBAL CONST $VOS_OS216 = 131072
GLOBAL CONST $VOS_OS232 = 196608
GLOBAL CONST $VOS__PM16 = 2
GLOBAL CONST $VOS__PM32 = 3
GLOBAL CONST $VOS_UNKNOWN = 0
GLOBAL CONST $VOS_DOS_WINDOWS16 = 65537
GLOBAL CONST $VOS_DOS_WINDOWS32 = 65540
GLOBAL CONST $VOS_NT_WINDOWS32 = 262148
GLOBAL CONST $VOS_OS216_PM16 = 131074
GLOBAL CONST $VOS_OS232_PM32 = 196611
GLOBAL CONST $VFT_APP = 1
GLOBAL CONST $VFT_DLL = 2
GLOBAL CONST $VFT_DRV = 3
GLOBAL CONST $VFT_FONT = 4
GLOBAL CONST $VFT_STATIC_LIB = 7
GLOBAL CONST $VFT_UNKNOWN = 0
GLOBAL CONST $VFT_VXD = 5
GLOBAL CONST $VFT2_DRV_COMM = 10
GLOBAL CONST $VFT2_DRV_DISPLAY = 4
GLOBAL CONST $VFT2_DRV_INSTALLABLE = 8
GLOBAL CONST $VFT2_DRV_KEYBOARD = 2
GLOBAL CONST $VFT2_DRV_LANGUAGE = 3
GLOBAL CONST $VFT2_DRV_MOUSE = 5
GLOBAL CONST $VFT2_DRV_NETWORK = 6
GLOBAL CONST $VFT2_DRV_PRINTER = 1
GLOBAL CONST $VFT2_DRV_SOUND = 9
GLOBAL CONST $VFT2_DRV_SYSTEM = 7
GLOBAL CONST $VFT2_DRV_VERSIONED_PRINTER = 12
GLOBAL CONST $VFT2_UNKNOWN = 0
GLOBAL CONST $VFT2_FONT_RASTER = 1
GLOBAL CONST $VFT2_FONT_TRUETYPE = 3
GLOBAL CONST $VFT2_FONT_VECTOR = 2
#Region Global Variables and Constants
	GLOBAL $__G_VVAL
	GLOBAL CONST $TAGVS_FIXEDFILEINFO = "dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BEGINUPDATERESOURCE($SFILEPATH, $BDELETE = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "BeginUpdateResourceW", "wstr", $SFILEPATH, "bool", $BDELETE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CLIPCURSOR($TRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ClipCursor", "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COPYCURSOR($HCURSOR)
		RETURN _WINAPI_COPYICON($HCURSOR)
	ENDFUNC
	FUNC _WINAPI_CREATECARET($HWND, $HBITMAP, $IWIDTH = 0, $IHEIGHT = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "CreateCaret", "hwnd", $HWND, "handle", $HBITMAP, "int", $IWIDTH, "int", $IHEIGHT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DESTROYCARET()
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DestroyCaret")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DESTROYCURSOR($HCURSOR)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DestroyCursor", "handle", $HCURSOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENDUPDATERESOURCE($HUPDATE, $BDISCARD = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "EndUpdateResourceW", "handle", $HUPDATE, "bool", $BDISCARD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENUMRESOURCELANGUAGES($HMODULE, $STYPE, $SNAME)
		LOCAL $ILIBRARY = 0, $STYPEOFTYPE = "int", $STYPEOFNAME = "int"
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, BITOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
				IF NOT $HMODULE THEN RETURN SETERROR(1, 0, 0)
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		DIM $__G_VENUM[101] = [0]
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumResLanguagesProc", "bool", "handle;ptr;ptr;word;long_ptr")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "EnumResourceLanguagesW", "handle", $HMODULE, $STYPEOFTYPE, $STYPE, $STYPEOFNAME, $SNAME, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "long_ptr", 0)
		IF @ERROR OR NOT $ACALL[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMRESOURCENAMES($HMODULE, $STYPE)
		LOCAL $ACALL, $HENUMPROC, $ILIBRARY = 0, $STYPEOFTYPE = "int"
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, BITOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
				IF NOT $HMODULE THEN RETURN SETERROR(1, 0, 0)
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		DIM $__G_VENUM[101] = [0]
		$HENUMPROC = DLLCALLBACKREGISTER("__EnumResNamesProc", "bool", "handle;ptr;ptr;long_ptr")
		$ACALL = DLLCALL("kernel32.dll", "bool", "EnumResourceNamesW", "handle", $HMODULE, $STYPEOFTYPE, $STYPE, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "long_ptr", 0)
		IF @ERROR OR NOT $ACALL[0] OR(NOT $__G_VENUM[0]) THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMRESOURCETYPES($HMODULE)
		LOCAL $ILIBRARY = 0
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, BITOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
				IF NOT $HMODULE THEN RETURN SETERROR(1, 0, 0)
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		DIM $__G_VENUM[101] = [0]
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumResTypesProc", "bool", "handle;ptr;long_ptr")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "EnumResourceTypesW", "handle", $HMODULE, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "long_ptr", 0)
		IF @ERROR OR NOT $ACALL[0] OR(NOT $__G_VENUM[0]) THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_FINDRESOURCE($HINSTANCE, $STYPE, $SNAME)
		LOCAL $STYPEOFTYPE = "int", $STYPEOFNAME = "int"
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "FindResourceW", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME, $STYPEOFTYPE, $STYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FINDRESOURCEEX($HINSTANCE, $STYPE, $SNAME, $ILANGUAGE)
		LOCAL $STYPEOFTYPE = "int", $STYPEOFNAME = "int"
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "FindResourceExW", "handle", $HINSTANCE, $STYPEOFTYPE, $STYPE, $STYPEOFNAME, $SNAME, "ushort", $ILANGUAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FREERESOURCE($HDATA)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "FreeResource", "handle", $HDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCARETBLINKTIME()
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "GetCaretBlinkTime")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCARETPOS()
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetCaretPos", "struct*", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		LOCAL $ARET[2]
		FOR $I = 0 TO 1
			$ARET[$I] = DLLSTRUCTGETDATA($TPOINT, $I + 1)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETCLIPCURSOR()
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetClipCursor", "struct*", $TRECT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETCURSOR()
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetCursor")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETFILEVERSIONINFO($SFILEPATH, BYREF $PBUFFER, $IFLAGS = 0)
		LOCAL $ACALL
		IF _WINAPI_GETVERSION() >= 6 THEN
			$ACALL = DLLCALL("version.dll", "dword", "GetFileVersionInfoSizeExW", "dword", BITAND($IFLAGS, 3), "wstr", $SFILEPATH, "ptr", 0)
		ELSE
			$ACALL = DLLCALL("version.dll", "dword", "GetFileVersionInfoSizeW", "wstr", $SFILEPATH, "ptr", 0)
		ENDIF
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$PBUFFER = __HEAPREALLOC($PBUFFER, $ACALL[0], 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 100, @EXTENDED, 0)
		LOCAL $INBBYTE = $ACALL[0]
		IF _WINAPI_GETVERSION() >= 6 THEN
			$ACALL = DLLCALL("version.dll", "bool", "GetFileVersionInfoExW", "dword", BITAND($IFLAGS, 7), "wstr", $SFILEPATH, "dword", 0, "dword", $INBBYTE, "ptr", $PBUFFER)
		ELSE
			$ACALL = DLLCALL("version.dll", "bool", "GetFileVersionInfoW", "wstr", $SFILEPATH, "dword", 0, "dword", $INBBYTE, "ptr", $PBUFFER)
		ENDIF
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $INBBYTE
	ENDFUNC
	FUNC _WINAPI_HIDECARET($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "HideCaret", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADBITMAP($HINSTANCE, $SBITMAP)
		LOCAL $SBITMAPTYPE = "int"
		IF ISSTRING($SBITMAP) THEN $SBITMAPTYPE = "wstr"
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "LoadBitmapW", "handle", $HINSTANCE, $SBITMAPTYPE, $SBITMAP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADCURSOR($HINSTANCE, $SNAME)
		LOCAL $STYPEOFNAME = "int"
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "LoadCursorW", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADCURSORFROMFILE($SFILEPATH)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "LoadCursorFromFileW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADINDIRECTSTRING($SSTRIN)
		LOCAL $ACALL = DLLCALL("shlwapi.dll", "uint", "SHLoadIndirectString", "wstr", $SSTRIN, "wstr", "", "uint", 4096, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_LOADSTRING($HINSTANCE, $ISTRINGID)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "LoadStringW", "handle", $HINSTANCE, "uint", $ISTRINGID, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN SETEXTENDED($ACALL[0], $ACALL[3])
	ENDFUNC
	FUNC _WINAPI_LOADLIBRARYEX($SFILENAME, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $SFILENAME, "ptr", 0, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADRESOURCE($HINSTANCE, $HRESOURCE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "handle", "LoadResource", "handle", $HINSTANCE, "handle", $HRESOURCE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOADSTRINGEX($HMODULE, $IID, $ILANGUAGE = $LOCALE_USER_DEFAULT)
		LOCAL $ILIBRARY = 0
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, BITOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
				IF NOT $HMODULE THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		LOCAL $SRESULT = ""
		LOCAL $PDATA = __RESLOAD($HMODULE, 6, FLOOR($IID / 16) + 1, $ILANGUAGE)
		IF NOT @ERROR THEN
			LOCAL $IOFFSET = 0
			FOR $I = 0 TO MOD($IID, 16) - 1
				$IOFFSET += 2 * (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ushort", $PDATA + $IOFFSET), 1) + 1)
			NEXT
			$SRESULT = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ushort;wchar[" & DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ushort", $PDATA + $IOFFSET), 1) & "]", $PDATA + $IOFFSET), 2)
			IF @ERROR THEN $SRESULT = ""
		ELSE
			RETURN SETERROR(10, 0, "")
		ENDIF
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		RETURN SETERROR(NUMBER(NOT $SRESULT), 0, $SRESULT)
	ENDFUNC
	FUNC _WINAPI_LOCKRESOURCE($HDATA)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "ptr", "LockResource", "handle", $HDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETCARETBLINKTIME($IDURATION)
		LOCAL $IPREV = _WINAPI_GETCARETBLINKTIME()
		IF NOT $IPREV THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetCaretBlinkTime", "uint", $IDURATION)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $IPREV
	ENDFUNC
	FUNC _WINAPI_SETCARETPOS($IX, $IY)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "SetCaretPos", "int", $IX, "int", $IY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETCURSOR($HCURSOR)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "SetCursor", "handle", $HCURSOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETSYSTEMCURSOR($HCURSOR, $IID, $BCOPY = FALSE)
		IF $BCOPY THEN
			$HCURSOR = _WINAPI_COPYCURSOR($HCURSOR)
		ENDIF
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetSystemCursor", "handle", $HCURSOR, "dword", $IID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHOWCARET($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ShowCaret", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHOWCURSOR($BSHOW)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "ShowCursor", "bool", $BSHOW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SIZEOFRESOURCE($HINSTANCE, $HRESOURCE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "SizeofResource", "handle", $HINSTANCE, "handle", $HRESOURCE)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UPDATERESOURCE($HUPDATE, $STYPE, $SNAME, $ILANGUAGE, $PDATA, $ISIZE)
		LOCAL $STYPEOFTYPE = "int", $STYPEOFNAME = "int"
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "UpdateResourceW", "handle", $HUPDATE, $STYPEOFTYPE, $STYPE, $STYPEOFNAME, $SNAME, "word", $ILANGUAGE, "ptr", $PDATA, "dword", $ISIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_VERQUERYROOT($PDATA)
		LOCAL $ACALL = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\", "ptr*", 0, "uint*", 0)
		IF @ERROR OR NOT $ACALL[0] OR NOT $ACALL[4] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TVFFI = DLLSTRUCTCREATE($TAGVS_FIXEDFILEINFO)
		IF NOT _WINAPI_MOVEMEMORY($TVFFI, $ACALL[3], $ACALL[4]) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		RETURN $TVFFI
	ENDFUNC
	FUNC _WINAPI_VERQUERYVALUE($PDATA, $SVALUES = "")
		$SVALUES = STRINGREGEXPREPLACE($SVALUES, "\A[\s\|]*|[\s\|]*\Z", "")
		IF NOT $SVALUES THEN
			$SVALUES = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
		ENDIF
		$SVALUES = STRINGSPLIT($SVALUES, "|", $STR_NOCOUNT)
		LOCAL $ACALL = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\VarFileInfo\Translation", "ptr*", 0, "uint*", 0)
		IF @ERROR OR NOT $ACALL[0] OR NOT $ACALL[4] THEN RETURN SETERROR(@ERROR + 10, 0, 0)
		LOCAL $ILENGTH = FLOOR($ACALL[4] / 4)
		LOCAL $TLANG = DLLSTRUCTCREATE("dword[" & $ILENGTH & "]", $ACALL[3])
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, 0, 0)
		LOCAL $SCP, $AINFO[101][UBOUND($SVALUES) + 1] = [[0]]
		FOR $I = 1 TO $ILENGTH
			__INC($AINFO)
			$AINFO[$AINFO[0][0]][0] = _WINAPI_LOWORD(DLLSTRUCTGETDATA($TLANG, 1, $I))
			$SCP = HEX(_WINAPI_MAKELONG(_WINAPI_HIWORD(DLLSTRUCTGETDATA($TLANG, 1, $I)), _WINAPI_LOWORD(DLLSTRUCTGETDATA($TLANG, 1, $I))), 8)
			FOR $J = 0 TO UBOUND($SVALUES) - 1
				$ACALL = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\StringFileInfo\" & $SCP & "\" & $SVALUES[$J], "ptr*", 0, "uint*", 0)
				IF NOT @ERROR AND $ACALL[0] AND $ACALL[4] THEN
					$AINFO[$AINFO[0][0]][$J + 1] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & $ACALL[4] & "]", $ACALL[3]), 1)
				ELSE
					$AINFO[$AINFO[0][0]][$J + 1] = ""
				ENDIF
			NEXT
		NEXT
		__INC($AINFO, -1)
		RETURN $AINFO
	ENDFUNC
	FUNC _WINAPI_VERQUERYVALUEEX($HMODULE, $SVALUES = "", $ILANGUAGE = 1024)
		$__G_VVAL = STRINGREGEXPREPLACE($SVALUES, "\A[\s\|]*|[\s\|]*\Z", "")
		IF NOT $__G_VVAL THEN
			$__G_VVAL = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
		ENDIF
		$__G_VVAL = STRINGSPLIT($__G_VVAL, "|")
		IF NOT ISARRAY($__G_VVAL) THEN RETURN SETERROR(1, 0, 0)
		LOCAL $ILIBRARY = 0
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, BITOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
				IF NOT $HMODULE THEN
					RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
				ENDIF
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		DIM $__G_VENUM[101][$__G_VVAL[0] + 1] = [[0]]
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumVerValuesProc", "bool", "ptr;ptr;ptr;word;long_ptr")
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "EnumResourceLanguagesW", "handle", $HMODULE, "int", 16, "int", 1, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "long_ptr", $ILANGUAGE)
		DO
			IF @ERROR THEN
				$__G_VENUM = @ERROR + 20
			ELSE
				IF NOT $ACALL[0] THEN
					SWITCH _WINAPI_GETLASTERROR()
						CASE 0, 15106
							EXITLOOP
						CASE ELSE
							$__G_VENUM = 20
					ENDSWITCH
				ELSE
					EXITLOOP
				ENDIF
			ENDIF
		UNTIL 1
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF NOT $__G_VENUM[0][0] THEN $__G_VENUM = 230
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __ENUMRESLANGUAGESPROC($HMODULE, $ITYPE, $INAME, $ILANGUAGE, $LPARAM)
		#forceref $HMODULE, $ITYPE, $INAME, $LPARAM
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0]] = $ILANGUAGE
		RETURN 1
	ENDFUNC
	FUNC __ENUMRESNAMESPROC($HMODULE, $ITYPE, $INAME, $LPARAM)
		#forceref $HMODULE, $ITYPE, $LPARAM
		LOCAL $ILENGTH = _WINAPI_STRLEN($INAME)
		__INC($__G_VENUM)
		IF $ILENGTH THEN
			$__G_VENUM[$__G_VENUM[0]] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH + 1) & "]", $INAME), 1)
		ELSE
			$__G_VENUM[$__G_VENUM[0]] = NUMBER($INAME)
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMRESTYPESPROC($HMODULE, $ITYPE, $LPARAM)
		#forceref $HMODULE, $LPARAM
		LOCAL $ILENGTH = _WINAPI_STRLEN($ITYPE)
		__INC($__G_VENUM)
		IF $ILENGTH THEN
			$__G_VENUM[$__G_VENUM[0]] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH + 1) & "]", $ITYPE), 1)
		ELSE
			$__G_VENUM[$__G_VENUM[0]] = NUMBER($ITYPE)
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMVERVALUESPROC($HMODULE, $ITYPE, $INAME, $ILANGUAGE, $IDEFAULT)
		LOCAL $ACALL, $IENUM = 1, $IERROR = 0
		SWITCH $IDEFAULT
			CASE -1
			CASE 1024
				$ILANGUAGE = 1024
				$IENUM = 0
			CASE ELSE
				IF $ILANGUAGE <> $IDEFAULT THEN
					RETURN 1
				ENDIF
				$IENUM = 0
		ENDSWITCH
		DO
			LOCAL $PDATA = __RESLOAD($HMODULE, $ITYPE, $INAME, $ILANGUAGE)
			IF @ERROR THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\VarFileInfo\Translation", "ptr*", 0, "uint*", 0)
			IF @ERROR OR NOT $ACALL[0] OR NOT $ACALL[4] THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			LOCAL $TDATA = DLLSTRUCTCREATE("ushort;ushort", $ACALL[3])
			IF @ERROR THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
		UNTIL 1
		IF NOT $IERROR THEN
			__INC($__G_VENUM)
			$__G_VENUM[$__G_VENUM[0][0]][0] = DLLSTRUCTGETDATA($TDATA, 1)
			LOCAL $SCP = HEX(_WINAPI_MAKELONG(DLLSTRUCTGETDATA($TDATA, 2), DLLSTRUCTGETDATA($TDATA, 1)), 8)
			FOR $I = 1 TO $__G_VVAL[0]
				$ACALL = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\StringFileInfo\" & $SCP & "\" & $__G_VVAL[$I], "ptr*", 0, "uint*", 0)
				IF NOT @ERROR AND $ACALL[0] AND $ACALL[4] THEN
					$__G_VENUM[$__G_VENUM[0][0]][$I] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & $ACALL[4] & "]", $ACALL[3]), 1)
				ELSE
					$__G_VENUM[$__G_VENUM[0][0]][$I] = ""
				ENDIF
			NEXT
		ELSE
			$__G_VENUM = @ERROR + 40
		ENDIF
		IF $__G_VENUM THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $IENUM
	ENDFUNC
	FUNC __RESLOAD($HINSTANCE, $STYPE, $SNAME, $ILANGUAGE)
		LOCAL $HINFO = _WINAPI_FINDRESOURCEEX($HINSTANCE, $STYPE, $SNAME, $ILANGUAGE)
		IF NOT $HINFO THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ISIZE = _WINAPI_SIZEOFRESOURCE($HINSTANCE, $HINFO)
		IF NOT $ISIZE THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $HDATA = _WINAPI_LOADRESOURCE($HINSTANCE, $HINFO)
		IF NOT $HDATA THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		LOCAL $PDATA = _WINAPI_LOCKRESOURCE($HDATA)
		IF NOT $PDATA THEN RETURN SETERROR(@ERROR + 40, @EXTENDED, 0)
		RETURN SETEXTENDED($ISIZE, $PDATA)
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $KLF_ACTIVATE = 1
GLOBAL CONST $KLF_NOTELLSHELL = 128
GLOBAL CONST $KLF_REORDER = 8
GLOBAL CONST $KLF_REPLACELANG = 16
GLOBAL CONST $KLF_RESET = 1073741824
GLOBAL CONST $KLF_SETFORPROCESS = 256
GLOBAL CONST $KLF_SHIFTLOCK = 65536
GLOBAL CONST $KLF_SUBSTITUTE_OK = 2
GLOBAL CONST $HKL_NEXT = 1
GLOBAL CONST $HKL_PREV = 0
GLOBAL CONST $AW_ACTIVATE = 131072
GLOBAL CONST $AW_BLEND = 524288
GLOBAL CONST $AW_CENTER = 16
GLOBAL CONST $AW_HIDE = 65536
GLOBAL CONST $AW_HOR_NEGATIVE = 2
GLOBAL CONST $AW_HOR_POSITIVE = 1
GLOBAL CONST $AW_SLIDE = 262144
GLOBAL CONST $AW_VER_NEGATIVE = 8
GLOBAL CONST $AW_VER_POSITIVE = 4
GLOBAL CONST $BSF_ALLOWSFW = 128
GLOBAL CONST $BSF_FLUSHDISK = 4
GLOBAL CONST $BSF_FORCEIFHUNG = 32
GLOBAL CONST $BSF_IGNORECURRENTTASK = 2
GLOBAL CONST $BSF_NOHANG = 8
GLOBAL CONST $BSF_NOTIMEOUTIFNOTHUNG = 64
GLOBAL CONST $BSF_POSTMESSAGE = 16
GLOBAL CONST $BSF_QUERY = 1
GLOBAL CONST $BSF_SENDNOTIFYMESSAGE = 256
GLOBAL CONST $BSM_ALLCOMPONENTS = 0
GLOBAL CONST $BSM_ALLDESKTOPS = 8
GLOBAL CONST $BSM_APPLICATIONS = 16
GLOBAL CONST $BSM_INSTALLABLEDRIVERS = 4
GLOBAL CONST $BSM_NETDRIVER = 2
GLOBAL CONST $BSM_VXDS = 1
GLOBAL CONST $MDITILE_HORIZONTAL = 1
GLOBAL CONST $MDITILE_SKIPDISABLED = 2
GLOBAL CONST $MDITILE_VERTICAL = 0
GLOBAL CONST $MDITILE_ZORDER = 4
GLOBAL CONST $MSGFLT_ALLOW = 1
GLOBAL CONST $MSGFLT_DISALLOW = 2
GLOBAL CONST $MSGFLT_RESET = 0
GLOBAL CONST $MSGFLTINFO_ALLOWED_HIGHER = 3
GLOBAL CONST $MSGFLTINFO_ALREADYALLOWED_FORWND = 1
GLOBAL CONST $MSGFLTINFO_ALREADYDISALLOWED_FORWND = 2
GLOBAL CONST $MSGFLTINFO_NONE = 0
GLOBAL CONST $CWP_ALL = 0
GLOBAL CONST $CWP_SKIPINVISIBLE = 1
GLOBAL CONST $CWP_SKIPDISABLED = 2
GLOBAL CONST $CWP_SKIPTRANSPARENT = 4
GLOBAL CONST $COMPRESSION_FORMAT_NONE = 0
GLOBAL CONST $COMPRESSION_FORMAT_DEFAULT = 1
GLOBAL CONST $COMPRESSION_FORMAT_LZNT1 = 2
GLOBAL CONST $COMPRESSION_FORMAT_XPRESS = 3
GLOBAL CONST $COMPRESSION_FORMAT_XPRESS_HUFF = 4
GLOBAL CONST $COMPRESSION_ENGINE_STANDARD = 0
GLOBAL CONST $COMPRESSION_ENGINE_MAXIMUM = 256
GLOBAL CONST $COMPRESSION_ENGINE_HIBER = 512
GLOBAL CONST $WINSTA_ACCESSCLIPBOARD = 4
GLOBAL CONST $WINSTA_ACCESSGLOBALATOMS = 32
GLOBAL CONST $WINSTA_CREATEDESKTOP = 8
GLOBAL CONST $WINSTA_ENUMDESKTOPS = 1
GLOBAL CONST $WINSTA_ENUMERATE = 256
GLOBAL CONST $WINSTA_EXITWINDOWS = 64
GLOBAL CONST $WINSTA_READATTRIBUTES = 2
GLOBAL CONST $WINSTA_READSCREEN = 512
GLOBAL CONST $WINSTA_WRITEATTRIBUTES = 16
GLOBAL CONST $WINSTA_ALL_ACCESS = BITOR($WINSTA_ACCESSCLIPBOARD, $WINSTA_ACCESSGLOBALATOMS, $WINSTA_CREATEDESKTOP, $WINSTA_ENUMDESKTOPS, $WINSTA_ENUMERATE, $WINSTA_EXITWINDOWS, $WINSTA_READATTRIBUTES, $WINSTA_READSCREEN, $WINSTA_WRITEATTRIBUTES)
GLOBAL CONST $CWF_CREATE_ONLY = 1
GLOBAL CONST $GCL_CBCLSEXTRA = -20
GLOBAL CONST $GCL_CBWNDEXTRA = -18
GLOBAL CONST $GCL_HBRBACKGROUND = -10
GLOBAL CONST $GCL_HCURSOR = -12
GLOBAL CONST $GCL_HICON = -14
GLOBAL CONST $GCL_HICONSM = -34
GLOBAL CONST $GCL_HMODULE = -16
GLOBAL CONST $GCL_MENUNAME = -8
GLOBAL CONST $GCL_STYLE = -26
GLOBAL CONST $GCL_WNDPROC = -24
GLOBAL CONST $DOCKINFO_DOCKED = 2
GLOBAL CONST $DOCKINFO_UNDOCKED = 1
GLOBAL CONST $DOCKINFO_USER_SUPPLIED = 4
GLOBAL CONST $DOCKINFO_USER_DOCKED = 5
GLOBAL CONST $DOCKINFO_USER_UNDOCKED = 6
GLOBAL CONST $GUI_CARETBLINKING = 1
GLOBAL CONST $GUI_INMENUMODE = 4
GLOBAL CONST $GUI_INMOVESIZE = 2
GLOBAL CONST $GUI_POPUPMENUMODE = 16
GLOBAL CONST $GUI_SYSTEMMENUMODE = 8
GLOBAL CONST $HANDLE_FLAG_INHERIT = 1
GLOBAL CONST $HANDLE_FLAG_PROTECT_FROM_CLOSE = 2
GLOBAL CONST $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 4
GLOBAL CONST $GET_MODULE_HANDLE_EX_FLAG_PIN = 1
GLOBAL CONST $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 2
GLOBAL CONST $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0
GLOBAL CONST $PROCESSOR_ARCHITECTURE_AMD64 = 9
GLOBAL CONST $PROCESSOR_ARCHITECTURE_IA64 = 6
GLOBAL CONST $PROCESSOR_ARCHITECTURE_INTEL = 0
GLOBAL CONST $PROCESSOR_ARCHITECTURE_UNKNOWN = 65535
GLOBAL CONST $PROCESSOR_INTEL_386 = 386
GLOBAL CONST $PROCESSOR_INTEL_486 = 486
GLOBAL CONST $PROCESSOR_INTEL_PENTIUM = 586
GLOBAL CONST $PROCESSOR_INTEL_IA64 = 2200
GLOBAL CONST $PROCESSOR_AMD_X8664 = 8664
GLOBAL CONST $UOI_FLAGS = 1
GLOBAL CONST $UOI_HEAPSIZE = 5
GLOBAL CONST $UOI_IO = 6
GLOBAL CONST $UOI_NAME = 2
GLOBAL CONST $UOI_TYPE = 3
GLOBAL CONST $UOI_USER_SID = 4
GLOBAL CONST $DF_ALLOWOTHERACCOUNTHOOK = 1
GLOBAL CONST $WSF_VISIBLE = 1
GLOBAL CONST $VER_SUITE_BACKOFFICE = 4
GLOBAL CONST $VER_SUITE_BLADE = 1024
GLOBAL CONST $VER_SUITE_COMPUTE_SERVER = 16384
GLOBAL CONST $VER_SUITE_DATACENTER = 128
GLOBAL CONST $VER_SUITE_ENTERPRISE = 2
GLOBAL CONST $VER_SUITE_EMBEDDEDNT = 64
GLOBAL CONST $VER_SUITE_PERSONAL = 512
GLOBAL CONST $VER_SUITE_SINGLEUSERTS = 256
GLOBAL CONST $VER_SUITE_SMALLBUSINESS = 1
GLOBAL CONST $VER_SUITE_SMALLBUSINESS_RESTRICTED = 32
GLOBAL CONST $VER_SUITE_STORAGE_SERVER = 8192
GLOBAL CONST $VER_SUITE_TERMINAL = 16
GLOBAL CONST $VER_SUITE_WH_SERVER = 32768
GLOBAL CONST $VER_NT_DOMAIN_CONTROLLER = 2
GLOBAL CONST $VER_NT_SERVER = 3
GLOBAL CONST $VER_NT_WORKSTATION = 1
GLOBAL CONST $WDA_MONITOR = 1
GLOBAL CONST $WDA_NONE = 0
GLOBAL CONST $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
GLOBAL CONST $PF_CHANNELS_ENABLED = 16
GLOBAL CONST $PF_COMPARE_EXCHANGE_DOUBLE = 2
GLOBAL CONST $PF_COMPARE_EXCHANGE128 = 14
GLOBAL CONST $PF_COMPARE64_EXCHANGE128 = 15
GLOBAL CONST $PF_FLOATING_POINT_EMULATED = 1
GLOBAL CONST $PF_FLOATING_POINT_PRECISION_ERRATA = 0
GLOBAL CONST $PF_MMX_INSTRUCTIONS_AVAILABLE = 3
GLOBAL CONST $PF_NX_ENABLED = 12
GLOBAL CONST $PF_PAE_ENABLED = 9
GLOBAL CONST $PF_RDTSC_INSTRUCTION_AVAILABLE = 8
GLOBAL CONST $PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
GLOBAL CONST $PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
GLOBAL CONST $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
GLOBAL CONST $PF_XSAVE_ENABLED = 17
GLOBAL CONST $KEYEVENTF_EXTENDEDKEY = 1
GLOBAL CONST $KEYEVENTF_KEYUP = 2
GLOBAL CONST $LIM_SMALL = 0
GLOBAL CONST $LIM_LARGE = 1
GLOBAL CONST $MAPVK_VK_TO_CHAR = 2
GLOBAL CONST $MAPVK_VK_TO_VSC = 0
GLOBAL CONST $MAPVK_VK_TO_VSC_EX = 4
GLOBAL CONST $MAPVK_VSC_TO_VK = 1
GLOBAL CONST $MAPVK_VSC_TO_VK_EX = 3
GLOBAL CONST $MOD_ALT = 1
GLOBAL CONST $MOD_CONTROL = 2
GLOBAL CONST $MOD_NOREPEAT = 16384
GLOBAL CONST $MOD_SHIFT = 4
GLOBAL CONST $MOD_WIN = 8
GLOBAL CONST $GUID_ACDC_POWER_SOURCE = "{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}"
GLOBAL CONST $GUID_BATTERY_PERCENTAGE_REMAINING = "{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}"
GLOBAL CONST $GUID_IDLE_BACKGROUND_TASK = "{515C31D8-F734-163D-A0FD-11A08C91E8F1}"
GLOBAL CONST $GUID_MONITOR_POWER_ON = "{02731015-4510-4526-99E6-E5A17EBD1AEA}"
GLOBAL CONST $GUID_POWERSCHEME_PERSONALITY = "{245D8541-3943-4422-B025-13A784F679B7}"
GLOBAL CONST $GUID_SYSTEM_AWAYMODE = "{98A7F580-01F7-48AA-9C0F-44352C29E5C0}"
GLOBAL CONST $GUID_MIN_POWER_SAVINGS = "{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}"
GLOBAL CONST $GUID_MAX_POWER_SAVINGS = "{A1841308-3541-4FAB-BC81-F71556F20B4A}"
GLOBAL CONST $GUID_TYPICAL_POWER_SAVINGS = "{381B4222-F694-41F0-9685-FF5BB260DF2E}"
GLOBAL CONST $HSHELL_WINDOWCREATED = 1
GLOBAL CONST $HSHELL_WINDOWDESTROYED = 2
GLOBAL CONST $HSHELL_ACTIVATESHELLWINDOW = 3
GLOBAL CONST $HSHELL_WINDOWACTIVATED = 4
GLOBAL CONST $HSHELL_GETMINRECT = 5
GLOBAL CONST $HSHELL_REDRAW = 6
GLOBAL CONST $HSHELL_TASKMAN = 7
GLOBAL CONST $HSHELL_LANGUAGE = 8
GLOBAL CONST $HSHELL_SYSMENU = 9
GLOBAL CONST $HSHELL_ENDTASK = 10
GLOBAL CONST $HSHELL_ACCESSIBILITYSTATE = 11
GLOBAL CONST $HSHELL_APPCOMMAND = 12
GLOBAL CONST $HSHELL_WINDOWREPLACED = 13
GLOBAL CONST $HSHELL_WINDOWREPLACING = 14
GLOBAL CONST $HSHELL_RUDEAPPACTIVATED = 32772
GLOBAL CONST $HSHELL_FLASH = 32774
GLOBAL CONST $HWND_BROADCAST = 65535
GLOBAL CONST $SMTO_BLOCK = 1
GLOBAL CONST $SMTO_NORMAL = 0
GLOBAL CONST $SMTO_ABORTIFHUNG = 2
GLOBAL CONST $SMTO_NOTIMEOUTIFNOTHUNG = 8
GLOBAL CONST $SMTO_ERRORONEXIT = 32
GLOBAL CONST $INPUTLANGCHANGE_BACKWARD = 4
GLOBAL CONST $INPUTLANGCHANGE_FORWARD = 2
GLOBAL CONST $INPUTLANGCHANGE_SYSCHARSET = 1
GLOBAL CONST $EVENT_MIN = 1
GLOBAL CONST $EVENT_SYSTEM_SOUND = 1
GLOBAL CONST $EVENT_SYSTEM_ALERT = 2
GLOBAL CONST $EVENT_SYSTEM_FOREGROUND = 3
GLOBAL CONST $EVENT_SYSTEM_MENUSTART = 4
GLOBAL CONST $EVENT_SYSTEM_MENUEND = 5
GLOBAL CONST $EVENT_SYSTEM_MENUPOPUPSTART = 6
GLOBAL CONST $EVENT_SYSTEM_MENUPOPUPEND = 7
GLOBAL CONST $EVENT_SYSTEM_CAPTURESTART = 8
GLOBAL CONST $EVENT_SYSTEM_CAPTUREEND = 9
GLOBAL CONST $EVENT_SYSTEM_MOVESIZESTART = 10
GLOBAL CONST $EVENT_SYSTEM_MOVESIZEEND = 11
GLOBAL CONST $EVENT_SYSTEM_CONTEXTHELPSTART = 12
GLOBAL CONST $EVENT_SYSTEM_CONTEXTHELPEND = 13
GLOBAL CONST $EVENT_SYSTEM_DRAGDROPSTART = 14
GLOBAL CONST $EVENT_SYSTEM_DRAGDROPEND = 15
GLOBAL CONST $EVENT_SYSTEM_DIALOGSTART = 16
GLOBAL CONST $EVENT_SYSTEM_DIALOGEND = 17
GLOBAL CONST $EVENT_SYSTEM_SCROLLINGSTART = 18
GLOBAL CONST $EVENT_SYSTEM_SCROLLINGEND = 19
GLOBAL CONST $EVENT_SYSTEM_SWITCHSTART = 20
GLOBAL CONST $EVENT_SYSTEM_SWITCHEND = 21
GLOBAL CONST $EVENT_SYSTEM_MINIMIZESTART = 22
GLOBAL CONST $EVENT_SYSTEM_MINIMIZEEND = 23
GLOBAL CONST $EVENT_SYSTEM_DESKTOPSWITCH = 32
GLOBAL CONST $EVENT_OBJECT_CREATE = 32768
GLOBAL CONST $EVENT_OBJECT_DESTROY = 32769
GLOBAL CONST $EVENT_OBJECT_SHOW = 32770
GLOBAL CONST $EVENT_OBJECT_HIDE = 32771
GLOBAL CONST $EVENT_OBJECT_REORDER = 32772
GLOBAL CONST $EVENT_OBJECT_FOCUS = 32773
GLOBAL CONST $EVENT_OBJECT_SELECTION = 32774
GLOBAL CONST $EVENT_OBJECT_SELECTIONADD = 32775
GLOBAL CONST $EVENT_OBJECT_SELECTIONREMOVE = 32776
GLOBAL CONST $EVENT_OBJECT_SELECTIONWITHIN = 32777
GLOBAL CONST $EVENT_OBJECT_STATECHANGE = 32778
GLOBAL CONST $EVENT_OBJECT_LOCATIONCHANGE = 32779
GLOBAL CONST $EVENT_OBJECT_NAMECHANGE = 32780
GLOBAL CONST $EVENT_OBJECT_DESCRIPTIONCHANGE = 32781
GLOBAL CONST $EVENT_OBJECT_VALUECHANGE = 32782
GLOBAL CONST $EVENT_OBJECT_PARENTCHANGE = 32783
GLOBAL CONST $EVENT_OBJECT_HELPCHANGE = 32784
GLOBAL CONST $EVENT_OBJECT_DEFACTIONCHANGE = 32785
GLOBAL CONST $EVENT_OBJECT_ACCELERATORCHANGE = 32786
GLOBAL CONST $EVENT_OBJECT_INVOKED = 32787
GLOBAL CONST $EVENT_OBJECT_TEXTSELECTIONCHANGED = 32788
GLOBAL CONST $EVENT_OBJECT_CONTENTSCROLLED = 32789
GLOBAL CONST $EVENT_MAX = 2147483647
GLOBAL CONST $WINEVENT_INCONTEXT = 4
GLOBAL CONST $WINEVENT_OUTOFCONTEXT = 0
GLOBAL CONST $WINEVENT_SKIPOWNPROCESS = 2
GLOBAL CONST $WINEVENT_SKIPOWNTHREAD = 1
GLOBAL CONST $TME_CANCEL = -2147483648
GLOBAL CONST $TME_HOVER = 1
GLOBAL CONST $TME_LEAVE = 2
GLOBAL CONST $TME_NONCLIENT = 16
GLOBAL CONST $TME_QUERY = 1073741824
GLOBAL CONST $DESKTOP_CREATEMENU = 4
GLOBAL CONST $DESKTOP_CREATEWINDOW = 2
GLOBAL CONST $DESKTOP_ENUMERATE = 64
GLOBAL CONST $DESKTOP_HOOKCONTROL = 8
GLOBAL CONST $DESKTOP_JOURNALPLAYBACK = 32
GLOBAL CONST $DESKTOP_JOURNALRECORD = 16
GLOBAL CONST $DESKTOP_READOBJECTS = 1
GLOBAL CONST $DESKTOP_SWITCHDESKTOP = 256
GLOBAL CONST $DESKTOP_WRITEOBJECTS = 128
GLOBAL CONST $DESKTOP_ALL_ACCESS = BITOR($DESKTOP_CREATEMENU, $DESKTOP_CREATEWINDOW, $DESKTOP_ENUMERATE, $DESKTOP_HOOKCONTROL, $DESKTOP_JOURNALPLAYBACK, $DESKTOP_JOURNALRECORD, $DESKTOP_READOBJECTS, $DESKTOP_SWITCHDESKTOP, $DESKTOP_WRITEOBJECTS)
GLOBAL CONST $RIDEV_APPKEYS = 1024
GLOBAL CONST $RIDEV_CAPTUREMOUSE = 512
GLOBAL CONST $RIDEV_DEVNOTIFY = 8192
GLOBAL CONST $RIDEV_EXCLUDE = 16
GLOBAL CONST $RIDEV_EXINPUTSINK = 4096
GLOBAL CONST $RIDEV_INPUTSINK = 256
GLOBAL CONST $RIDEV_NOHOTKEYS = 512
GLOBAL CONST $RIDEV_NOLEGACY = 48
GLOBAL CONST $RIDEV_PAGEONLY = 32
GLOBAL CONST $RIDEV_REMOVE = 1
GLOBAL CONST $RID_HEADER = 268435461
GLOBAL CONST $RID_INPUT = 268435459
GLOBAL CONST $RIM_TYPEHID = 2
GLOBAL CONST $RIM_TYPEKEYBOARD = 1
GLOBAL CONST $RIM_TYPEMOUSE = 0
GLOBAL CONST $RIDI_DEVICENAME = 536870919
GLOBAL CONST $RIDI_DEVICEINFO = 536870923
GLOBAL CONST $RIDI_PREPARSEDDATA = 536870917
GLOBAL CONST $MOUSE_ATTRIBUTES_CHANGED = 4
GLOBAL CONST $MOUSE_MOVE_ABSOLUTE = 1
GLOBAL CONST $MOUSE_MOVE_RELATIVE = 0
GLOBAL CONST $MOUSE_VIRTUAL_DESKTOP = 2
GLOBAL CONST $RI_MOUSE_LEFT_BUTTON_DOWN = 1
GLOBAL CONST $RI_MOUSE_LEFT_BUTTON_UP = 2
GLOBAL CONST $RI_MOUSE_MIDDLE_BUTTON_DOWN = 16
GLOBAL CONST $RI_MOUSE_MIDDLE_BUTTON_UP = 32
GLOBAL CONST $RI_MOUSE_RIGHT_BUTTON_DOWN = 4
GLOBAL CONST $RI_MOUSE_RIGHT_BUTTON_UP = 8
GLOBAL CONST $RI_MOUSE_BUTTON_1_DOWN = $RI_MOUSE_LEFT_BUTTON_DOWN
GLOBAL CONST $RI_MOUSE_BUTTON_1_UP = $RI_MOUSE_LEFT_BUTTON_UP
GLOBAL CONST $RI_MOUSE_BUTTON_2_DOWN = $RI_MOUSE_RIGHT_BUTTON_DOWN
GLOBAL CONST $RI_MOUSE_BUTTON_2_UP = $RI_MOUSE_RIGHT_BUTTON_UP
GLOBAL CONST $RI_MOUSE_BUTTON_3_DOWN = $RI_MOUSE_MIDDLE_BUTTON_DOWN
GLOBAL CONST $RI_MOUSE_BUTTON_3_UP = $RI_MOUSE_MIDDLE_BUTTON_UP
GLOBAL CONST $RI_MOUSE_BUTTON_4_DOWN = 64
GLOBAL CONST $RI_MOUSE_BUTTON_4_UP = 128
GLOBAL CONST $RI_MOUSE_BUTTON_5_DOWN = 256
GLOBAL CONST $RI_MOUSE_BUTTON_5_UP = 512
GLOBAL CONST $RI_MOUSE_WHEEL = 1024
GLOBAL CONST $RI_KEY_BREAK = 1
GLOBAL CONST $RI_KEY_E0 = 2
GLOBAL CONST $RI_KEY_E1 = 4
GLOBAL CONST $RI_KEY_MAKE = 0
#Region Global Variables and Constants
	GLOBAL $__G_AINPROCESS_WINAPI[64][2] = [[0, 0]]
	GLOBAL $__G_AWINLIST_WINAPI[64][2] = [[0, 0]]
	GLOBAL CONST $GW_HWNDFIRST = 0
	GLOBAL CONST $GW_HWNDLAST = 1
	GLOBAL CONST $GW_HWNDNEXT = 2
	GLOBAL CONST $GW_HWNDPREV = 3
	GLOBAL CONST $GW_OWNER = 4
	GLOBAL CONST $GW_CHILD = 5
	GLOBAL CONST $GW_ENABLEDPOPUP = 6
	GLOBAL CONST $GWL_WNDPROC = -4
	GLOBAL CONST $GWL_HINSTANCE = -6
	GLOBAL CONST $GWL_HWNDPARENT = -8
	GLOBAL CONST $GWL_ID = -12
	GLOBAL CONST $GWL_STYLE = -16
	GLOBAL CONST $GWL_EXSTYLE = -20
	GLOBAL CONST $GWL_USERDATA = -21
	GLOBAL CONST $__WINAPICONSTANT_WM_SETFONT = 48
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CREATEWINDOWEX($IEXSTYLE, $SCLASS, $SNAME, $ISTYLE, $IX, $IY, $IWIDTH, $IHEIGHT, $HPARENT, $HMENU = 0, $HINSTANCE = 0, $PPARAM = 0)
		IF $HINSTANCE = 0 THEN $HINSTANCE = _WINAPI_GETMODULEHANDLE("")
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "CreateWindowExW", "dword", $IEXSTYLE, "wstr", $SCLASS, "wstr", $SNAME, "dword", $ISTYLE, "int", $IX, "int", $IY, "int", $IWIDTH, "int", $IHEIGHT, "hwnd", $HPARENT, "handle", $HMENU, "handle", $HINSTANCE, "struct*", $PPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCLIENTRECT($HWND)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetClientRect", "hwnd", $HWND, "struct*", $TRECT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETDESKTOPWINDOW()
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetDesktopWindow")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DESTROYWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DestroyWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENABLEWINDOW($HWND, $BENABLE = TRUE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EnableWindow", "hwnd", $HWND, "bool", $BENABLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENUMWINDOWS($BVISIBLE = TRUE, $HWND = DEFAULT)
		__WINAPI_ENUMWINDOWSINIT()
		IF $HWND = DEFAULT THEN $HWND = _WINAPI_GETDESKTOPWINDOW()
		__WINAPI_ENUMWINDOWSCHILD($HWND, $BVISIBLE)
		RETURN $__G_AWINLIST_WINAPI
	ENDFUNC
	FUNC _WINAPI_ENUMWINDOWSPOPUP()
		__WINAPI_ENUMWINDOWSINIT()
		LOCAL $HWND = _WINAPI_GETWINDOW(_WINAPI_GETDESKTOPWINDOW(), $GW_CHILD)
		LOCAL $SCLASS
		WHILE $HWND <> 0
			IF _WINAPI_ISWINDOWVISIBLE($HWND) THEN
				$SCLASS = _WINAPI_GETCLASSNAME($HWND)
				IF $SCLASS = "#32768" THEN
					__WINAPI_ENUMWINDOWSADD($HWND)
				ELSEIF $SCLASS = "ToolbarWindow32" THEN
					__WINAPI_ENUMWINDOWSADD($HWND)
				ELSEIF $SCLASS = "ToolTips_Class32" THEN
					__WINAPI_ENUMWINDOWSADD($HWND)
				ELSEIF $SCLASS = "BaseBar" THEN
					__WINAPI_ENUMWINDOWSCHILD($HWND)
				ENDIF
			ENDIF
			$HWND = _WINAPI_GETWINDOW($HWND, $GW_HWNDNEXT)
		WEND
		RETURN $__G_AWINLIST_WINAPI
	ENDFUNC
	FUNC _WINAPI_ENUMWINDOWSTOP()
		__WINAPI_ENUMWINDOWSINIT()
		LOCAL $HWND = _WINAPI_GETWINDOW(_WINAPI_GETDESKTOPWINDOW(), $GW_CHILD)
		WHILE $HWND <> 0
			IF _WINAPI_ISWINDOWVISIBLE($HWND) THEN __WINAPI_ENUMWINDOWSADD($HWND)
			$HWND = _WINAPI_GETWINDOW($HWND, $GW_HWNDNEXT)
		WEND
		RETURN $__G_AWINLIST_WINAPI
	ENDFUNC
	FUNC _WINAPI_GETCLASSNAME($HWND)
		IF NOT ISHWND($HWND) THEN $HWND = GUICTRLGETHANDLE($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "GetClassNameW", "hwnd", $HWND, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ACALL[0], $ACALL[2])
	ENDFUNC
	FUNC _WINAPI_GETFOCUS()
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetFocus")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETPARENT($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetParent", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETSYSCOLOR($IINDEX)
		LOCAL $ACALL = DLLCALL("user32.dll", "INT", "GetSysColor", "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMMETRICS($IINDEX)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "GetSystemMetrics", "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOW($HWND, $ICMD)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetWindow", "hwnd", $HWND, "uint", $ICMD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWHEIGHT($HWND)
		LOCAL $TRECT = _WINAPI_GETWINDOWRECT($HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TRECT, "Bottom") - DLLSTRUCTGETDATA($TRECT, "Top")
	ENDFUNC
	FUNC _WINAPI_GETWINDOWLONG($HWND, $IINDEX)
		LOCAL $SFUNCNAME = "GetWindowLongW"
		IF @AUTOITX64 THEN $SFUNCNAME = "GetWindowLongPtrW"
		LOCAL $ACALL = DLLCALL("user32.dll", "long_ptr", $SFUNCNAME, "hwnd", $HWND, "int", $IINDEX)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWRECT($HWND)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetWindowRect", "hwnd", $HWND, "struct*", $TRECT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETWINDOWTEXT($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "GetWindowTextW", "hwnd", $HWND, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN SETEXTENDED($ACALL[0], $ACALL[2])
	ENDFUNC
	FUNC _WINAPI_GETWINDOWTHREADPROCESSID($HWND, BYREF $IPID)
		LOCAL $ACALL = DLLCALL("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $HWND, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$IPID = $ACALL[2]
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWWIDTH($HWND)
		LOCAL $TRECT = _WINAPI_GETWINDOWRECT($HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TRECT, "Right") - DLLSTRUCTGETDATA($TRECT, "Left")
	ENDFUNC
	FUNC _WINAPI_INPROCESS($HWND, BYREF $HLASTWND)
		IF $HWND = $HLASTWND THEN RETURN TRUE
		FOR $II = $__G_AINPROCESS_WINAPI[0][0] TO 1 STEP -1
			IF $HWND = $__G_AINPROCESS_WINAPI[$II][0] THEN
				IF $__G_AINPROCESS_WINAPI[$II][1] THEN
					$HLASTWND = $HWND
					RETURN TRUE
				ELSE
					RETURN FALSE
				ENDIF
			ENDIF
		NEXT
		LOCAL $IPID
		_WINAPI_GETWINDOWTHREADPROCESSID($HWND, $IPID)
		LOCAL $ICOUNT = $__G_AINPROCESS_WINAPI[0][0] + 1
		IF $ICOUNT >= 64 THEN $ICOUNT = 1
		$__G_AINPROCESS_WINAPI[0][0] = $ICOUNT
		$__G_AINPROCESS_WINAPI[$ICOUNT][0] = $HWND
		$__G_AINPROCESS_WINAPI[$ICOUNT][1] = ($IPID = @AUTOITPID)
		RETURN $__G_AINPROCESS_WINAPI[$ICOUNT][1]
	ENDFUNC
	FUNC _WINAPI_INVALIDATERECT($HWND, $TRECT = 0, $BERASE = TRUE)
		IF NOT ISHWND($HWND) THEN $HWND = GUICTRLGETHANDLE($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "InvalidateRect", "hwnd", $HWND, "struct*", $TRECT, "bool", $BERASE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISCLASSNAME($HWND, $SCLASSNAME)
		LOCAL $SSEPARATOR = OPT("GUIDataSeparatorChar")
		LOCAL $ACLASSNAME = STRINGSPLIT($SCLASSNAME, $SSEPARATOR)
		IF NOT ISHWND($HWND) THEN $HWND = GUICTRLGETHANDLE($HWND)
		LOCAL $SCLASSCHECK = _WINAPI_GETCLASSNAME($HWND)
		FOR $X = 1 TO UBOUND($ACLASSNAME) - 1
			IF STRINGUPPER(STRINGMID($SCLASSCHECK, 1, STRINGLEN($ACLASSNAME[$X]))) = STRINGUPPER($ACLASSNAME[$X]) THEN RETURN TRUE
		NEXT
		RETURN FALSE
	ENDFUNC
	FUNC _WINAPI_ISWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISWINDOWVISIBLE($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsWindowVisible", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MOVEWINDOW($HWND, $IX, $IY, $IWIDTH, $IHEIGHT, $BREPAINT = TRUE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "MoveWindow", "hwnd", $HWND, "int", $IX, "int", $IY, "int", $IWIDTH, "int", $IHEIGHT, "bool", $BREPAINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETFOCUS($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "SetFocus", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETFONT($HWND, $HFONT, $BREDRAW = TRUE)
		_SENDMESSAGE($HWND, $__WINAPICONSTANT_WM_SETFONT, $HFONT, $BREDRAW, 0, "hwnd")
	ENDFUNC
	FUNC _WINAPI_SETPARENT($HWNDCHILD, $HWNDPARENT)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "SetParent", "hwnd", $HWNDCHILD, "hwnd", $HWNDPARENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWPOS($HWND, $HAFTER, $IX, $IY, $ICX, $ICY, $IFLAGS)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetWindowPos", "hwnd", $HWND, "hwnd", $HAFTER, "int", $IX, "int", $IY, "int", $ICX, "int", $ICY, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWTEXT($HWND, $STEXT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetWindowTextW", "hwnd", $HWND, "wstr", $STEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHOWWINDOW($HWND, $ICMDSHOW = 5)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ShowWindow", "hwnd", $HWND, "int", $ICMDSHOW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UPDATEWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UpdateWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __WINAPI_ENUMWINDOWSADD($HWND, $SCLASS = "")
		IF $SCLASS = "" THEN $SCLASS = _WINAPI_GETCLASSNAME($HWND)
		$__G_AWINLIST_WINAPI[0][0] += 1
		LOCAL $ICOUNT = $__G_AWINLIST_WINAPI[0][0]
		IF $ICOUNT >= $__G_AWINLIST_WINAPI[0][1] THEN
			REDIM $__G_AWINLIST_WINAPI[$ICOUNT + 64][2]
			$__G_AWINLIST_WINAPI[0][1] += 64
		ENDIF
		$__G_AWINLIST_WINAPI[$ICOUNT][0] = $HWND
		$__G_AWINLIST_WINAPI[$ICOUNT][1] = $SCLASS
	ENDFUNC
	FUNC __WINAPI_ENUMWINDOWSCHILD($HWND, $BVISIBLE = TRUE)
		$HWND = _WINAPI_GETWINDOW($HWND, $GW_CHILD)
		WHILE $HWND <> 0
			IF(NOT $BVISIBLE) OR _WINAPI_ISWINDOWVISIBLE($HWND) THEN
				__WINAPI_ENUMWINDOWSADD($HWND)
				__WINAPI_ENUMWINDOWSCHILD($HWND, $BVISIBLE)
			ENDIF
			$HWND = _WINAPI_GETWINDOW($HWND, $GW_HWNDNEXT)
		WEND
	ENDFUNC
	FUNC __WINAPI_ENUMWINDOWSINIT()
		REDIM $__G_AWINLIST_WINAPI[64][2]
		$__G_AWINLIST_WINAPI[0][0] = 0
		$__G_AWINLIST_WINAPI[0][1] = 64
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL CONST $FLASHW_CAPTION = 1
	GLOBAL CONST $FLASHW_TRAY = 2
	GLOBAL CONST $FLASHW_TIMER = 4
	GLOBAL CONST $FLASHW_TIMERNOFG = 12
	GLOBAL CONST $TAGUPDATELAYEREDWINDOWINFO = "dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom"
	GLOBAL CONST $TAGWINDOWINFO = "dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;word atomWindowType;word CreatorVersion"
	GLOBAL CONST $TAGWNDCLASS = "uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName"
	GLOBAL CONST $TAGWNDCLASSEX = "uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
GLOBAL CONST $TAGFLASHWINFO = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
#Region Public Functions
	FUNC _WINAPI_ADJUSTWINDOWRECTEX(BYREF $TRECT, $ISTYLE, $IEXSTYLE = 0, $BMENU = FALSE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "AdjustWindowRectEx", "struct*", $TRECT, "dword", $ISTYLE, "bool", $BMENU, "dword", $IEXSTYLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ANIMATEWINDOW($HWND, $IFLAGS, $IDURATION = 1000)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "AnimateWindow", "hwnd", $HWND, "dword", $IDURATION, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BEGINDEFERWINDOWPOS($IAMOUNT = 1)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "BeginDeferWindowPos", "int", $IAMOUNT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BRINGWINDOWTOTOP($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "BringWindowToTop", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_BROADCASTSYSTEMMESSAGE($IMSG, $WPARAM = 0, $LPARAM = 0, $IFLAGS = 0, $IRECIPIENTS = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "long", "BroadcastSystemMessageW", "dword", $IFLAGS, "dword*", $IRECIPIENTS, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR OR($ACALL[0] = -1) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN SETEXTENDED($ACALL[2], $ACALL[0])
	ENDFUNC
	FUNC _WINAPI_CALLWINDOWPROC($PPREVWNDFUNC, $HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ACALL = DLLCALL("user32.dll", "lresult", "CallWindowProc", "ptr", $PPREVWNDFUNC, "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CALLWINDOWPROCW($PPREVWNDPROC, $HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ACALL = DLLCALL("user32.dll", "lresult", "CallWindowProcW", "ptr", $PPREVWNDPROC, "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CASCADEWINDOWS($AWNDS, $TRECT = 0, $HPARENT = 0, $IFLAGS = 0, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($AWNDS, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ICOUNT = $IEND - $ISTART + 1
		LOCAL $TWNDS = DLLSTRUCTCREATE("hwnd[" & $ICOUNT & "]")
		$ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			DLLSTRUCTSETDATA($TWNDS, 1, $AWNDS[$I], $ICOUNT)
			$ICOUNT += 1
		NEXT
		LOCAL $ACALL = DLLCALL("user32.dll", "word", "CascadeWindows", "hwnd", $HPARENT, "uint", $IFLAGS, "struct*", $TRECT, "uint", $ICOUNT - 1, "struct*", $TWNDS)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CHANGEWINDOWMESSAGEFILTEREX($HWND, $IMSG, $IACTION)
		LOCAL $TCFS, $ACALL
		IF $HWND AND(_WINAPI_GETVERSION() > 6) THEN
			LOCAL CONST $TAGCHANGEFILTERSTRUCT = "dword cbSize; dword ExtStatus"
			$TCFS = DLLSTRUCTCREATE($TAGCHANGEFILTERSTRUCT)
			DLLSTRUCTSETDATA($TCFS, 1, DLLSTRUCTGETSIZE($TCFS))
			$ACALL = DLLCALL("user32.dll", "bool", "ChangeWindowMessageFilterEx", "hwnd", $HWND, "uint", $IMSG, "dword", $IACTION, "struct*", $TCFS)
		ELSE
			$TCFS = 0
			$ACALL = DLLCALL("user32.dll", "bool", "ChangeWindowMessageFilter", "uint", $IMSG, "dword", $IACTION)
		ENDIF
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN SETEXTENDED(DLLSTRUCTGETDATA($TCFS, 2), 1)
	ENDFUNC
	FUNC _WINAPI_CHILDWINDOWFROMPOINTEX($HWND, $TPOINT, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "ChildWindowFromPointEx", "hwnd", $HWND, "struct", $TPOINT, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "CloseWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DEFERWINDOWPOS($HINFO, $HWND, $HAFTER, $IX, $IY, $IWIDTH, $IHEIGHT, $IFLAGS)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "DeferWindowPos", "handle", $HINFO, "hwnd", $HWND, "hwnd", $HAFTER, "int", $IX, "int", $IY, "int", $IWIDTH, "int", $IHEIGHT, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DEFWINDOWPROC($HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ACALL = DLLCALL("user32.dll", "lresult", "DefWindowProc", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DEFWINDOWPROCW($HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ACALL = DLLCALL("user32.dll", "lresult", "DefWindowProcW", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DEREGISTERSHELLHOOKWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "DeregisterShellHookWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DRAGACCEPTFILES($HWND, $BACCEPT = TRUE)
		DLLCALL("shell32.dll", "none", "DragAcceptFiles", "hwnd", $HWND, "bool", $BACCEPT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAGFINISH($HDROP)
		DLLCALL("shell32.dll", "none", "DragFinish", "handle", $HDROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAGQUERYFILEEX($HDROP, $IFLAG = 0)
		LOCAL $ACALL = DLLCALL("shell32.dll", "uint", "DragQueryFileW", "handle", $HDROP, "uint", -1, "ptr", 0, "uint", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, 0, 0)
		LOCAL $ICOUNT = $ACALL[0], $IVALIDROW = 0
		LOCAL $ARET[$ICOUNT + 1]
		FOR $I = 0 TO $ICOUNT - 1
			$ACALL = DLLCALL("shell32.dll", "uint", "DragQueryFileW", "handle", $HDROP, "uint", $I, "wstr", "", "uint", 4096)
			IF NOT $ACALL[0] THEN RETURN SETERROR(11, 0, 0)
			IF $IFLAG THEN
				LOCAL $BDIR = _WINAPI_PATHISDIRECTORY($ACALL[3])
				IF(($IFLAG = 1) AND $BDIR) OR(($IFLAG = 2) AND NOT $BDIR) THEN
					CONTINUELOOP
				ENDIF
			ENDIF
			$IVALIDROW += 1
			$ARET[$IVALIDROW] = $ACALL[3]
			$ARET[0] += 1
		NEXT
		IF NOT $ARET[0] THEN RETURN SETERROR(12, 0, 0)
		__INC($ARET, -1)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_DRAGQUERYPOINT($HDROP)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ACALL = DLLCALL("shell32.dll", "bool", "DragQueryPoint", "handle", $HDROP, "struct*", $TPOINT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_ENDDEFERWINDOWPOS($HINFO)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EndDeferWindowPos", "handle", $HINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ENUMCHILDWINDOWS($HWND, $BVISIBLE = TRUE)
		IF NOT _WINAPI_GETWINDOW($HWND, 5) THEN RETURN SETERROR(2, 0, 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumWindowsProc", "bool", "hwnd;lparam")
		DIM $__G_VENUM[101][2] = [[0]]
		DLLCALL("user32.dll", "bool", "EnumChildWindows", "hwnd", $HWND, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", $BVISIBLE)
		IF @ERROR OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_FINDWINDOW($SCLASSNAME, $SWINDOWNAME)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "FindWindowW", "wstr", $SCLASSNAME, "wstr", $SWINDOWNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FLASHWINDOW($HWND, $BINVERT = TRUE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "FlashWindow", "hwnd", $HWND, "bool", $BINVERT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_FLASHWINDOWEX($HWND, $IFLAGS = 3, $ICOUNT = 3, $ITIMEOUT = 0)
		LOCAL $TFLASH = DLLSTRUCTCREATE($TAGFLASHWINFO)
		LOCAL $IFLASH = DLLSTRUCTGETSIZE($TFLASH)
		LOCAL $IMODE = 0
		IF BITAND($IFLAGS, 1) <> 0 THEN $IMODE = BITOR($IMODE, $FLASHW_CAPTION)
		IF BITAND($IFLAGS, 2) <> 0 THEN $IMODE = BITOR($IMODE, $FLASHW_TRAY)
		IF BITAND($IFLAGS, 4) <> 0 THEN $IMODE = BITOR($IMODE, $FLASHW_TIMER)
		IF BITAND($IFLAGS, 8) <> 0 THEN $IMODE = BITOR($IMODE, $FLASHW_TIMERNOFG)
		DLLSTRUCTSETDATA($TFLASH, "Size", $IFLASH)
		DLLSTRUCTSETDATA($TFLASH, "hWnd", $HWND)
		DLLSTRUCTSETDATA($TFLASH, "Flags", $IMODE)
		DLLSTRUCTSETDATA($TFLASH, "Count", $ICOUNT)
		DLLSTRUCTSETDATA($TFLASH, "Timeout", $ITIMEOUT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "FlashWindowEx", "struct*", $TFLASH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETANCESTOR($HWND, $IFLAGS = 1)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetAncestor", "hwnd", $HWND, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCLASSINFOEX($SCLASS, $HINSTANCE = 0)
		LOCAL $STYPEOFCLASS = "wstr"
		IF NOT ISSTRING($SCLASS) THEN $STYPEOFCLASS = "ptr"
		LOCAL $TWNDCLASSEX = DLLSTRUCTCREATE($TAGWNDCLASSEX)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetClassInfoExW", "handle", $HINSTANCE, $STYPEOFCLASS, $SCLASS, "struct*", $TWNDCLASSEX)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TWNDCLASSEX
	ENDFUNC
	FUNC _WINAPI_GETCLASSLONGEX($HWND, $IINDEX)
		LOCAL $ACALL
		IF @AUTOITX64 THEN
			$ACALL = DLLCALL("user32.dll", "ulong_ptr", "GetClassLongPtrW", "hwnd", $HWND, "int", $IINDEX)
		ELSE
			$ACALL = DLLCALL("user32.dll", "dword", "GetClassLongW", "hwnd", $HWND, "int", $IINDEX)
		ENDIF
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCLIENTHEIGHT($HWND)
		LOCAL $TRECT = _WINAPI_GETCLIENTRECT($HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TRECT, "Bottom") - DLLSTRUCTGETDATA($TRECT, "Top")
	ENDFUNC
	FUNC _WINAPI_GETCLIENTWIDTH($HWND)
		LOCAL $TRECT = _WINAPI_GETCLIENTRECT($HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TRECT, "Right") - DLLSTRUCTGETDATA($TRECT, "Left")
	ENDFUNC
	FUNC _WINAPI_GETDLGITEM($HWND, $IITEMID)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetDlgItem", "hwnd", $HWND, "int", $IITEMID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETFOREGROUNDWINDOW()
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetForegroundWindow")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETGUITHREADINFO($ITHREADID)
		LOCAL CONST $TAGGUITHREADINFO = "dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;struct rcCaret;long left;long top;long right;long bottom;endstruct"
		LOCAL $TGTI = DLLSTRUCTCREATE($TAGGUITHREADINFO)
		DLLSTRUCTSETDATA($TGTI, 1, DLLSTRUCTGETSIZE($TGTI))
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetGUIThreadInfo", "dword", $ITHREADID, "struct*", $TGTI)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[11]
		FOR $I = 0 TO 10
			$ARET[$I] = DLLSTRUCTGETDATA($TGTI, $I + 2)
		NEXT
		FOR $I = 9 TO 10
			$ARET[$I] -= $ARET[$I - 2]
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETLASTACTIVEPOPUP($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetLastActivePopup", "hwnd", $HWND)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF $ACALL[0] = $HWND THEN RETURN SETERROR(1, 0, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETLAYEREDWINDOWATTRIBUTES($HWND, BYREF $ITRANSCOLOR, BYREF $ITRANSGUI, $BCOLORREF = FALSE)
		$ITRANSCOLOR = -1
		$ITRANSGUI = -1
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $HWND, "INT*", $ITRANSCOLOR, "byte*", $ITRANSGUI, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $BCOLORREF THEN
			$ACALL[2] = INT(BINARYMID($ACALL[2], 3, 1) & BINARYMID($ACALL[2], 2, 1) & BINARYMID($ACALL[2], 1, 1))
		ENDIF
		$ITRANSCOLOR = $ACALL[2]
		$ITRANSGUI = $ACALL[3]
		RETURN $ACALL[4]
	ENDFUNC
	FUNC _WINAPI_GETMESSAGEEXTRAINFO()
		LOCAL $ACALL = DLLCALL("user32.dll", "lparam", "GetMessageExtraInfo")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETSHELLWINDOW()
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetShellWindow")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETTOPWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetTopWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWDISPLAYAFFINITY($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetWindowDisplayAffinity", "hwnd", $HWND, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWINFO($HWND)
		LOCAL $TWINDOWINFO = DLLSTRUCTCREATE($TAGWINDOWINFO)
		DLLSTRUCTSETDATA($TWINDOWINFO, "Size", DLLSTRUCTGETSIZE($TWINDOWINFO))
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetWindowInfo", "hwnd", $HWND, "struct*", $TWINDOWINFO)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TWINDOWINFO
	ENDFUNC
	FUNC _WINAPI_GETWINDOWPLACEMENT($HWND)
		LOCAL $TWINDOWPLACEMENT = DLLSTRUCTCREATE($TAGWINDOWPLACEMENT)
		DLLSTRUCTSETDATA($TWINDOWPLACEMENT, "length", DLLSTRUCTGETSIZE($TWINDOWPLACEMENT))
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetWindowPlacement", "hwnd", $HWND, "struct*", $TWINDOWPLACEMENT)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TWINDOWPLACEMENT
	ENDFUNC
	FUNC _WINAPI_ISCHILD($HWND, $HWNDPARENT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsChild", "hwnd", $HWNDPARENT, "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISHUNGAPPWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsHungAppWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISICONIC($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsIconic", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISWINDOWUNICODE($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsWindowUnicode", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISZOOMED($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsZoomed", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_KILLTIMER($HWND, $ITIMERID)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "KillTimer", "hwnd", $HWND, "uint_ptr", $ITIMERID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OPENICON($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "OpenIcon", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_POSTMESSAGE($HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "PostMessage", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERCLASS($TWNDCLASS)
		LOCAL $ACALL = DLLCALL("user32.dll", "word", "RegisterClassW", "struct*", $TWNDCLASS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERCLASSEX($TWNDCLASSEX)
		LOCAL $ACALL = DLLCALL("user32.dll", "word", "RegisterClassExW", "struct*", $TWNDCLASSEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERSHELLHOOKWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "RegisterShellHookWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERWINDOWMESSAGE($SMESSAGE)
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $SMESSAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SENDMESSAGETIMEOUT($HWND, $IMSG, $WPARAM = 0, $LPARAM = 0, $ITIMEOUT = 1000, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "lresult", "SendMessageTimeoutW", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM, "uint", $IFLAGS, "uint", $ITIMEOUT, "dword_ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), -1)
		RETURN $ACALL[7]
	ENDFUNC
	FUNC _WINAPI_SETCLASSLONGEX($HWND, $IINDEX, $INEWLONG)
		LOCAL $ACALL
		IF @AUTOITX64 THEN
			$ACALL = DLLCALL("user32.dll", "ulong_ptr", "SetClassLongPtrW", "hwnd", $HWND, "int", $IINDEX, "long_ptr", $INEWLONG)
		ELSE
			$ACALL = DLLCALL("user32.dll", "dword", "SetClassLongW", "hwnd", $HWND, "int", $IINDEX, "long", $INEWLONG)
		ENDIF
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETFOREGROUNDWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetForegroundWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETLAYEREDWINDOWATTRIBUTES($HWND, $ITRANSCOLOR, $ITRANSGUI = 255, $IFLAGS = 3, $BCOLORREF = FALSE)
		IF $IFLAGS = DEFAULT OR $IFLAGS = "" OR $IFLAGS < 0 THEN $IFLAGS = 3
		IF NOT $BCOLORREF THEN
			$ITRANSCOLOR = INT(BINARYMID($ITRANSCOLOR, 3, 1) & BINARYMID($ITRANSCOLOR, 2, 1) & BINARYMID($ITRANSCOLOR, 1, 1))
		ENDIF
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $HWND, "INT", $ITRANSCOLOR, "byte", $ITRANSGUI, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETMESSAGEEXTRAINFO($LPARAM)
		LOCAL $ACALL = DLLCALL("user32.dll", "lparam", "SetMessageExtraInfo", "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETSYSCOLORS($VELEMENTS, $VCOLORS)
		LOCAL $BISEARRAY = ISARRAY($VELEMENTS), $BISCARRAY = ISARRAY($VCOLORS)
		LOCAL $IELEMENTNUM
		IF NOT $BISCARRAY AND NOT $BISEARRAY THEN
			$IELEMENTNUM = 1
		ELSEIF $BISCARRAY OR $BISEARRAY THEN
			IF NOT $BISCARRAY OR NOT $BISEARRAY THEN RETURN SETERROR(-1, -1, FALSE)
			IF UBOUND($VELEMENTS) <> UBOUND($VCOLORS) THEN RETURN SETERROR(-1, -1, FALSE)
			$IELEMENTNUM = UBOUND($VELEMENTS)
		ENDIF
		LOCAL $TELEMENTS = DLLSTRUCTCREATE("int Element[" & $IELEMENTNUM & "]")
		LOCAL $TCOLORS = DLLSTRUCTCREATE("INT NewColor[" & $IELEMENTNUM & "]")
		IF NOT $BISEARRAY THEN
			DLLSTRUCTSETDATA($TELEMENTS, "Element", $VELEMENTS, 1)
		ELSE
			FOR $X = 0 TO $IELEMENTNUM - 1
				DLLSTRUCTSETDATA($TELEMENTS, "Element", $VELEMENTS[$X], $X + 1)
			NEXT
		ENDIF
		IF NOT $BISCARRAY THEN
			DLLSTRUCTSETDATA($TCOLORS, "NewColor", $VCOLORS, 1)
		ELSE
			FOR $X = 0 TO $IELEMENTNUM - 1
				DLLSTRUCTSETDATA($TCOLORS, "NewColor", $VCOLORS[$X], $X + 1)
			NEXT
		ENDIF
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetSysColors", "int", $IELEMENTNUM, "struct*", $TELEMENTS, "struct*", $TCOLORS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETTIMER($HWND, $ITIMERID, $IELAPSE, $PTIMERFUNC)
		LOCAL $ACALL = DLLCALL("user32.dll", "uint_ptr", "SetTimer", "hwnd", $HWND, "uint_ptr", $ITIMERID, "uint", $IELAPSE, "ptr", $PTIMERFUNC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWDISPLAYAFFINITY($HWND, $IAFFINITY)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetWindowDisplayAffinity", "hwnd", $HWND, "dword", $IAFFINITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWLONG($HWND, $IINDEX, $IVALUE)
		_WINAPI_SETLASTERROR(0)
		LOCAL $SFUNCNAME = "SetWindowLongW"
		IF @AUTOITX64 THEN $SFUNCNAME = "SetWindowLongPtrW"
		LOCAL $ACALL = DLLCALL("user32.dll", "long_ptr", $SFUNCNAME, "hwnd", $HWND, "int", $IINDEX, "long_ptr", $IVALUE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWPLACEMENT($HWND, $TWINDOWPLACEMENT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetWindowPlacement", "hwnd", $HWND, "struct*", $TWINDOWPLACEMENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHOWOWNEDPOPUPS($HWND, $BSHOW)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ShowOwnedPopups", "hwnd", $HWND, "bool", $BSHOW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SWITCHTOTHISWINDOW($HWND, $BALTTAB = FALSE)
		DLLCALL("user32.dll", "none", "SwitchToThisWindow", "hwnd", $HWND, "bool", $BALTTAB)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_TILEWINDOWS($AWNDS, $TRECT = 0, $HPARENT = 0, $IFLAGS = 0, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($AWNDS, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ICOUNT = $IEND - $ISTART + 1
		LOCAL $TWNDS = DLLSTRUCTCREATE("hwnd[" & $ICOUNT & "]")
		$ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			DLLSTRUCTSETDATA($TWNDS, 1, $AWNDS[$I], $ICOUNT)
			$ICOUNT += 1
		NEXT
		LOCAL $ACALL = DLLCALL("user32.dll", "word", "TileWindows", "hwnd", $HPARENT, "uint", $IFLAGS, "struct*", $TRECT, "uint", $ICOUNT - 1, "struct*", $TWNDS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNREGISTERCLASS($SCLASS, $HINSTANCE = 0)
		LOCAL $STYPEOFCLASS = "wstr"
		IF NOT ISSTRING($SCLASS) THEN $STYPEOFCLASS = "ptr"
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UnregisterClassW", $STYPEOFCLASS, $SCLASS, "handle", $HINSTANCE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UPDATELAYEREDWINDOW($HWND, $HDESTDC, $TPTDEST, $TSIZE, $HSRCDC, $TPTSRCE, $IRGB, $TBLEND, $IFLAGS)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $HWND, "handle", $HDESTDC, "struct*", $TPTDEST, "struct*", $TSIZE, "handle", $HSRCDC, "struct*", $TPTSRCE, "dword", $IRGB, "struct*", $TBLEND, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UPDATELAYEREDWINDOWEX($HWND, $IX, $IY, $HBITMAP, $IOPACITY = 255, $BDELETE = FALSE)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HWND)
		LOCAL $HDC = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		LOCAL $HDESTDC = $ACALL[0]
		$ACALL = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HBITMAP)
		LOCAL $HDESTSV = $ACALL[0]
		LOCAL $TPOINT
		IF($IX = -1) AND($IY = -1) THEN
			$TPOINT = DLLSTRUCTCREATE("int;int")
		ELSE
			$TPOINT = DLLSTRUCTCREATE("int;int;int;int")
			DLLSTRUCTSETDATA($TPOINT, 3, $IX)
			DLLSTRUCTSETDATA($TPOINT, 4, $IY)
		ENDIF
		DLLSTRUCTSETDATA($TPOINT, 1, 0)
		DLLSTRUCTSETDATA($TPOINT, 2, 0)
		LOCAL $TBLENDFUNCTION = DLLSTRUCTCREATE($TAGBLENDFUNCTION)
		DLLSTRUCTSETDATA($TBLENDFUNCTION, 1, 0)
		DLLSTRUCTSETDATA($TBLENDFUNCTION, 2, 0)
		DLLSTRUCTSETDATA($TBLENDFUNCTION, 3, $IOPACITY)
		DLLSTRUCTSETDATA($TBLENDFUNCTION, 4, 1)
		LOCAL CONST $TAGBITMAP = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
		LOCAL $TOBJ = DLLSTRUCTCREATE($TAGBITMAP)
		DLLCALL("gdi32.dll", "int", "GetObject", "handle", $HBITMAP, "int", DLLSTRUCTGETSIZE($TOBJ), "struct*", $TOBJ)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE, DLLSTRUCTGETPTR($TOBJ, "bmWidth"))
		$ACALL = DLLCALL("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $HWND, "handle", $HDC, "ptr", DLLSTRUCTGETPTR($TPOINT, 3), "struct*", $TSIZE, "handle", $HDESTDC, "struct*", $TPOINT, "dword", 0, "struct*", $TBLENDFUNCTION, "dword", 2)
		LOCAL $IERROR = @ERROR
		DLLCALL("user32.dll", "bool", "ReleaseDC", "hwnd", $HWND, "handle", $HDC)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HDESTSV)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HDESTDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, FALSE)
		IF $BDELETE THEN
			DLLCALL("gdi32.dll", "bool", "DeleteObject", "handle", $HBITMAP)
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UPDATELAYEREDWINDOWINDIRECT($HWND, $TULWINFO)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UpdateLayeredWindowIndirect", "hwnd", $HWND, "struct*", $TULWINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_WINDOWFROMPOINT(BYREF $TPOINT)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "WindowFromPoint", "struct", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __ENUMDEFAULTPROC($PDATA, $LPARAM)
		#forceref $LPARAM
		LOCAL $ILENGTH = _WINAPI_STRLEN($PDATA)
		__INC($__G_VENUM)
		IF $ILENGTH THEN
			$__G_VENUM[$__G_VENUM[0]] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH + 1) & "]", $PDATA), 1)
		ELSE
			$__G_VENUM[$__G_VENUM[0]] = ""
		ENDIF
		RETURN 1
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL CONST $TAGOSVERSIONINFOEX = $TAGOSVERSIONINFO & ";ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved"
	GLOBAL CONST $TAGRAWINPUTDEVICE = "struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct"
	GLOBAL CONST $TAGRAWINPUTHEADER = "struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct"
	GLOBAL CONST $TAGRAWMOUSE = "ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;"
	GLOBAL CONST $TAGRAWKEYBOARD = "ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;"
	GLOBAL CONST $TAGRAWHID = "dword SizeHid;dword Count;"
	GLOBAL CONST $TAGRAWINPUTMOUSE = $TAGRAWINPUTHEADER & ";" & $TAGRAWMOUSE
	GLOBAL CONST $TAGRAWINPUTKEYBOARD = $TAGRAWINPUTHEADER & ";" & $TAGRAWKEYBOARD
	GLOBAL CONST $TAGRAWINPUTHID = $TAGRAWINPUTHEADER & ";" & $TAGRAWHID
	GLOBAL CONST $TAGRID_DEVICE_INFO_MOUSE = "struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc"
	GLOBAL CONST $TAGRID_DEVICE_INFO_KEYBOARD = "struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruct"
	GLOBAL CONST $TAGRID_DEVICE_INFO_HID = "struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc"
	GLOBAL CONST $TAGRID_INFO_MOUSE = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_MOUSE & ";dword Unused[2];"
	GLOBAL CONST $TAGRID_INFO_KEYBOARD = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_KEYBOARD
	GLOBAL CONST $TAGRID_INFO_HID = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_HID & ";dword Unused[2]"
	GLOBAL CONST $TAGUSEROBJECTFLAGS = "int Inherit;int Reserved;dword Flags"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_ACTIVATEKEYBOARDLAYOUT($HLOCALE, $IFLAG = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "ActivateKeyboardLayout", "handle", $HLOCALE, "uint", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ADDCLIPBOARDFORMATLISTENER($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "AddClipboardFormatListener", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CALLNEXTHOOKEX($HHOOK, $ICODE, $WPARAM, $LPARAM)
		LOCAL $ACALL = DLLCALL("user32.dll", "lresult", "CallNextHookEx", "handle", $HHOOK, "int", $ICODE, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEDESKTOP($HDESKTOP)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "CloseDesktop", "handle", $HDESKTOP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEWINDOWSTATION($HSTATION)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "CloseWindowStation", "handle", $HSTATION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_COMPRESSBUFFER($PUNCOMPRESSEDBUFFER, $IUNCOMPRESSEDSIZE, $PCOMPRESSEDBUFFER, $ICOMPRESSEDSIZE, $IFORMATANDENGINE = 2)
		LOCAL $ACALL, $PWORKSPACE = 0, $IERROR = 0
		DO
			$ACALL = DLLCALL("ntdll.dll", "uint", "RtlGetCompressionWorkSpaceSize", "ushort", $IFORMATANDENGINE, "ulong*", 0, "ulong*", 0)
			IF @ERROR OR $ACALL[0] THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			$PWORKSPACE = __HEAPALLOC($ACALL[2])
			IF @ERROR THEN
				$IERROR = @ERROR + 100
				EXITLOOP
			ENDIF
			$ACALL = DLLCALL("ntdll.dll", "uint", "RtlCompressBuffer", "ushort", $IFORMATANDENGINE, "struct*", $PUNCOMPRESSEDBUFFER, "ulong", $IUNCOMPRESSEDSIZE, "struct*", $PCOMPRESSEDBUFFER, "ulong", $ICOMPRESSEDSIZE, "ulong", 4096, "ulong*", 0, "ptr", $PWORKSPACE)
			IF @ERROR OR $ACALL[0] OR NOT $ACALL[7] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
		UNTIL 1
		__HEAPFREE($PWORKSPACE)
		IF $IERROR THEN
			IF ISARRAY($ACALL) THEN
				RETURN SETERROR(10, $ACALL[0], 0)
			ELSE
				RETURN SETERROR($IERROR, 0, 0)
			ENDIF
		ENDIF
		RETURN $ACALL[7]
	ENDFUNC
	FUNC _WINAPI_COMPUTECRC32($PMEMORY, $ILENGTH)
		IF _WINAPI_ISBADREADPTR($PMEMORY, $ILENGTH) THEN RETURN SETERROR(1, @EXTENDED, 0)
		LOCAL $ACALL = DLLCALL("ntdll.dll", "dword", "RtlComputeCrc32", "dword", 0, "struct*", $PMEMORY, "int", $ILENGTH)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDESKTOP($SNAME, $IACCESS = 2, $IFLAGS = 0, $IHEAP = 0, $TSECURITY = 0)
		LOCAL $ACALL
		IF $IHEAP THEN
			$ACALL = DLLCALL("user32.dll", "handle", "CreateDesktopExW", "wstr", $SNAME, "ptr", 0, "ptr", 0, "dword", $IFLAGS, "dword", $IACCESS, "struct*", $TSECURITY, "ulong", $IHEAP, "ptr", 0)
		ELSE
			$ACALL = DLLCALL("user32.dll", "handle", "CreateDesktopW", "wstr", $SNAME, "ptr", 0, "ptr", 0, "dword", $IFLAGS, "dword", $IACCESS, "struct*", $TSECURITY)
		ENDIF
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_CREATEWINDOWSTATION($SNAME = "", $IACCESS = 0, $IFLAGS = 0, $TSECURITY = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "CreateWindowStationW", "wstr", $SNAME, "dword", $IFLAGS, "dword", $IACCESS, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_DECOMPRESSBUFFER($PUNCOMPRESSEDBUFFER, $IUNCOMPRESSEDSIZE, $PCOMPRESSEDBUFFER, $ICOMPRESSEDSIZE, $IFORMAT = 2)
		LOCAL $ACALL = DLLCALL("ntdll.dll", "long", "RtlDecompressBuffer", "ushort", $IFORMAT, "struct*", $PUNCOMPRESSEDBUFFER, "ulong", $IUNCOMPRESSEDSIZE, "struct*", $PCOMPRESSEDBUFFER, "ulong", $ICOMPRESSEDSIZE, "ulong*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN $ACALL[6]
	ENDFUNC
	FUNC _WINAPI_DEFRAWINPUTPROC($PARAWINPUT, $IINPUT)
		LOCAL $ACALL = DLLCALL("user32.dll", "lresult", "DefRawInputProc", "ptr", $PARAWINPUT, "int", $IINPUT, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTHEADER)))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] THEN RETURN SETERROR(10, $ACALL[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ENUMDESKTOPS($HSTATION)
		IF STRINGCOMPARE(_WINAPI_GETUSEROBJECTINFORMATION($HSTATION, 3), "WindowStation") THEN RETURN SETERROR(1, 0, 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumDefaultProc", "bool", "ptr;lparam")
		DIM $__G_VENUM[101] = [0]
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EnumDesktopsW", "handle", $HSTATION, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", 0)
		IF @ERROR OR NOT $ACALL[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMDESKTOPWINDOWS($HDESKTOP, $BVISIBLE = TRUE)
		IF STRINGCOMPARE(_WINAPI_GETUSEROBJECTINFORMATION($HDESKTOP, 3), "Desktop") THEN RETURN SETERROR(1, 0, 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumWindowsProc", "bool", "hwnd;lparam")
		DIM $__G_VENUM[101][2] = [[0]]
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EnumDesktopWindows", "handle", $HDESKTOP, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", $BVISIBLE)
		IF @ERROR OR NOT $ACALL[0] OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMPAGEFILES()
		LOCAL $AINFO = _WINAPI_GETSYSTEMINFO()
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumPageFilesProc", "bool", "lparam;ptr;ptr")
		DIM $__G_VENUM[101][4] = [[0]]
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumPageFilesW", "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", $AINFO[1])
		IF @ERROR OR NOT $ACALL[0] OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMRAWINPUTDEVICES()
		LOCAL CONST $TAGRAWINPUTDEVICELIST = "struct;handle hDevice;dword Type;endstruct"
		LOCAL $TRIDL, $ILENGTH = DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTDEVICELIST))
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "GetRawInputDeviceList", "ptr", 0, "uint*", 0, "uint", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF($ACALL[0] = 4294967295) OR(NOT $ACALL[2]) THEN RETURN SETERROR(10, -1, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & ($ACALL[2] * $ILENGTH) & "]")
		LOCAL $PDATA = DLLSTRUCTGETPTR($TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, 0, 0)
		$ACALL = DLLCALL("user32.dll", "uint", "GetRawInputDeviceList", "ptr", $PDATA, "uint*", $ACALL[2], "uint", $ILENGTH)
		IF($ACALL[0] = 4294967295) OR(NOT $ACALL[0]) THEN RETURN SETERROR(1, -1, 0)
		LOCAL $ARET[$ACALL[2] + 1][2] = [[$ACALL[2]]]
		FOR $I = 1 TO $ACALL[2]
			$TRIDL = DLLSTRUCTCREATE("ptr;dword", $PDATA + $ILENGTH * ($I - 1))
			FOR $J = 0 TO 1
				$ARET[$I][$J] = DLLSTRUCTGETDATA($TRIDL, $J + 1)
			NEXT
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_ENUMWINDOWSTATIONS()
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumDefaultProc", "bool", "ptr;lparam")
		DIM $__G_VENUM[101] = [0]
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "EnumWindowStationsW", "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", 0)
		IF @ERROR OR NOT $ACALL[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_EXPANDENVIRONMENTSTRINGS($SSTRING)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $SSTRING, "wstr", "", "dword", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETACTIVEWINDOW()
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "GetActiveWindow")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETASYNCKEYSTATE($IKEY)
		LOCAL $ACALL = DLLCALL("user32.dll", "short", "GetAsyncKeyState", "int", $IKEY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCLIPBOARDSEQUENCENUMBER()
		LOCAL $ACALL = DLLCALL("user32.dll", "dword", "GetClipboardSequenceNumber")
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTHWPROFILE()
		LOCAL $TAGHW_PROFILE_INFO = "dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]"
		LOCAL $THWPI = DLLSTRUCTCREATE($TAGHW_PROFILE_INFO)
		LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "GetCurrentHwProfileW", "struct*", $THWPI)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[3]
		FOR $I = 0 TO 2
			$ARET[$I] = DLLSTRUCTGETDATA($THWPI, $I + 1)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETDEFAULTPRINTER()
		LOCAL $ACALL = DLLCALL("winspool.drv", "bool", "GetDefaultPrinterW", "wstr", "", "dword*", 2048)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF NOT $ACALL[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_GETDLLDIRECTORY()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetDllDirectoryW", "dword", 4096, "wstr", "")
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETEFFECTIVECLIENTRECT($HWND, $ACTRL, $ISTART = 0, $IEND = -1)
		IF NOT ISARRAY($ACTRL) THEN
			LOCAL $ICTRL = $ACTRL
			DIM $ACTRL[1] = [$ICTRL]
			$ISTART = 0
			$IEND = 0
		ENDIF
		IF __CHECKERRORARRAYBOUNDS($ACTRL, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ICOUNT = $IEND - $ISTART + 1
		LOCAL $TCTRL = DLLSTRUCTCREATE("uint64[" & ($ICOUNT + 2) & "]")
		$ICOUNT = 2
		FOR $I = $ISTART TO $IEND
			IF ISHWND($ACTRL[$I]) THEN
				$ACTRL[$I] = _WINAPI_GETDLGCTRLID($ACTRL[$I])
			ENDIF
			DLLSTRUCTSETDATA($TCTRL, 1, _WINAPI_MAKEQWORD(1, $ACTRL[$I]), $ICOUNT)
			$ICOUNT += 1
		NEXT
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLCALL("comctl32.dll", "none", "GetEffectiveClientRect", "hwnd", $HWND, "struct*", $TRECT, "struct*", $TCTRL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETHANDLEINFORMATION($HOBJECT)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetHandleInformation", "handle", $HOBJECT, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETIDLETIME()
		LOCAL $TLASTINPUTINFO = DLLSTRUCTCREATE("uint;dword")
		DLLSTRUCTSETDATA($TLASTINPUTINFO, 1, DLLSTRUCTGETSIZE($TLASTINPUTINFO))
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetLastInputInfo", "struct*", $TLASTINPUTINFO)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN _WINAPI_GETTICKCOUNT() - DLLSTRUCTGETDATA($TLASTINPUTINFO, 2)
	ENDFUNC
	FUNC _WINAPI_GETKEYBOARDLAYOUT($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $HWND, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		$ACALL = DLLCALL("user32.dll", "handle", "GetKeyboardLayout", "dword", $ACALL[0])
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETKEYBOARDLAYOUTLIST()
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "GetKeyboardLayoutList", "int", 0, "ptr", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("handle[" & $ACALL[0] & "]")
		$ACALL = DLLCALL("user32.dll", "uint", "GetKeyboardLayoutList", "int", $ACALL[0], "struct*", $TDATA)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ALIST[$ACALL[0] + 1] = [$ACALL[0]]
		FOR $I = 1 TO $ALIST[0]
			$ALIST[$I] = DLLSTRUCTGETDATA($TDATA, 1, $I)
		NEXT
		RETURN $ALIST
	ENDFUNC
	FUNC _WINAPI_GETKEYBOARDSTATE()
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[256]")
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetKeyboardState", "struct*", $TDATA)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TDATA
	ENDFUNC
	FUNC _WINAPI_GETKEYBOARDTYPE($ITYPE)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "GetKeyboardType", "int", $ITYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETKEYNAMETEXT($LPARAM)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "GetKeyNameTextW", "long", $LPARAM, "wstr", "", "int", 128)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_GETKEYSTATE($VKEY)
		LOCAL $ACALL = DLLCALL("user32.dll", "short", "GetKeyState", "int", $VKEY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETMODULEHANDLEEX($SMODULE, $IFLAGS = 0)
		IF STRINGSTRIPWS($SMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) = "" THEN $SMODULE = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetModuleHandleExW", "dword", $IFLAGS, "wstr", $SMODULE, "ptr*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[3]
	ENDFUNC
	FUNC _WINAPI_GETMUILANGUAGE()
		LOCAL $ACALL = DLLCALL("comctl32.dll", "word", "GetMUILanguage")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETPERFORMANCEINFO()
		LOCAL $TPI = DLLSTRUCTCREATE("dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword")
		LOCAL $ACALL = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "GetPerformanceInfo", "struct*", $TPI, "dword", DLLSTRUCTGETSIZE($TPI))
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[13]
		FOR $I = 0 TO 12
			$ARET[$I] = DLLSTRUCTGETDATA($TPI, $I + 2)
		NEXT
		FOR $I = 0 TO 8
			$ARET[$I] *= $ARET[9]
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETPROCADDRESS($HMODULE, $VNAME)
		LOCAL $STYPE = "str"
		IF ISNUMBER($VNAME) THEN $STYPE = "word"
		LOCAL $ACALL = DLLCALL("kernel32.dll", "ptr", "GetProcAddress", "handle", $HMODULE, $STYPE, $VNAME)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETPHYSICALLYINSTALLEDSYSTEMMEMORY()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetPhysicallyInstalledSystemMemory", "uint64*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_GETPROCESSSHUTDOWNPARAMETERS()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetProcessShutdownParameters", "dword*", 0, "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN SETEXTENDED(NUMBER(NOT $ACALL[2]), $ACALL[1])
	ENDFUNC
	FUNC _WINAPI_GETPROCESSWINDOWSTATION()
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "GetProcessWindowStation")
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETPWRCAPABILITIES()
		IF NOT __DLL("powrprof.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $TSPC = DLLSTRUCTCREATE("byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]")
		LOCAL $ACALL = DLLCALL("powrprof.dll", "boolean", "GetPwrCapabilities", "struct*", $TSPC)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[25]
		FOR $I = 0 TO 17
			$ARET[$I] = DLLSTRUCTGETDATA($TSPC, 1, $I + 1)
		NEXT
		$ARET[18] = DLLSTRUCTGETDATA($TSPC, 3)
		FOR $I = 19 TO 20
			$ARET[$I] = DLLSTRUCTGETDATA($TSPC, 5, $I - 18)
		NEXT
		FOR $I = 21 TO 24
			$ARET[$I] = DLLSTRUCTGETDATA($TSPC, 7, $I - 20)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETRAWINPUTBUFFER($PBUFFER, $ILENGTH)
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "GetRawInputBuffer", "struct*", $PBUFFER, "uint*", $ILENGTH, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTHEADER)))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF($ACALL[0] = 4294967295) OR(NOT $ACALL[1]) THEN RETURN SETERROR(10, -1, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETRAWINPUTBUFFERLENGTH()
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "GetRawInputBuffer", "ptr", 0, "uint*", 0, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTHEADER)))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = 4294967295 THEN RETURN SETERROR(10, -1, 0)
		RETURN $ACALL[2] * 8
	ENDFUNC
	FUNC _WINAPI_GETRAWINPUTDATA($HRAWINPUT, $PBUFFER, $ILENGTH, $IFLAG)
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "GetRawInputData", "handle", $HRAWINPUT, "uint", $IFLAG, "struct*", $PBUFFER, "uint*", $ILENGTH, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTHEADER)))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = 4294967295 THEN RETURN SETERROR(10, -1, 0)
		RETURN($ACALL[3] ? $ACALL[0] : $ACALL[4])
	ENDFUNC
	FUNC _WINAPI_GETRAWINPUTDEVICEINFO($HDEVICE, $PBUFFER, $ILENGTH, $IFLAG)
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "GetRawInputDeviceInfoW", "handle", $HDEVICE, "uint", $IFLAG, "struct*", $PBUFFER, "uint*", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = 4294967295 THEN RETURN SETERROR(10, -1, 0)
		RETURN($ACALL[3] ? $ACALL[0] : $ACALL[4])
	ENDFUNC
	FUNC _WINAPI_GETREGISTEREDRAWINPUTDEVICES($PBUFFER, $ILENGTH)
		LOCAL $ILENGTHRAW = DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTDEVICE))
		LOCAL $ACALL = DLLCALL("user32.dll", "uint", "GetRegisteredRawInputDevices", "struct*", $PBUFFER, "uint*", FLOOR($ILENGTH / $ILENGTHRAW), "uint", $ILENGTHRAW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ACALL[0] = 4294967295 THEN
			LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
			IF $ILASTERROR = 122 THEN RETURN SETEXTENDED($ILASTERROR, $ACALL[2] * $ILENGTHRAW)
			RETURN SETERROR(10, $ILASTERROR, 0)
		ENDIF
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETSTARTUPINFO()
		LOCAL $TSI = DLLSTRUCTCREATE($TAGSTARTUPINFO)
		DLLCALL("kernel32.dll", "none", "GetStartupInfoW", "struct*", $TSI)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $TSI
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMDEPPOLICY()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "uint", "GetSystemDEPPolicy")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMINFO()
		LOCAL $SPROC
		IF _WINAPI_ISWOW64PROCESS() THEN
			$SPROC = "GetNativeSystemInfo"
		ELSE
			$SPROC = "GetSystemInfo"
		ENDIF
		LOCAL CONST $TAGSYSTEMINFO = "struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;" & "ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;" & "dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision"
		LOCAL $TSYSTEMINFO = DLLSTRUCTCREATE($TAGSYSTEMINFO)
		DLLCALL("kernel32.dll", "none", $SPROC, "struct*", $TSYSTEMINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET[10]
		$ARET[0] = DLLSTRUCTGETDATA($TSYSTEMINFO, 1)
		FOR $I = 1 TO 9
			$ARET[$I] = DLLSTRUCTGETDATA($TSYSTEMINFO, $I + 2)
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMPOWERSTATUS()
		LOCAL $TAGSYSTEM_POWER_STATUS = "byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;" & "int BatteryLifeTime;int BatteryFullLifeTime"
		LOCAL $TSYSTEM_POWER_STATUS = DLLSTRUCTCREATE($TAGSYSTEM_POWER_STATUS)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetSystemPowerStatus", "struct*", $TSYSTEM_POWER_STATUS)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[5]
		$ARET[0] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 1)
		$ARET[1] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 2)
		$ARET[2] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 3)
		$ARET[3] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 5)
		$ARET[4] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 6)
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMTIMES()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetSystemTimes", "uint64*", 0, "uint64*", 0, "uint64*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET[3]
		FOR $I = 0 TO 2
			$ARET[$I] = $ACALL[$I + 1]
		NEXT
		RETURN $ARET
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMWOW64DIRECTORY()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "uint", "GetSystemWow64DirectoryW", "wstr", "", "uint", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, _WINAPI_GETLASTERROR(), "")
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_GETTICKCOUNT()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "dword", "GetTickCount")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETTICKCOUNT64()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "uint64", "GetTickCount64")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_GETUSEROBJECTINFORMATION($HOBJECT, $IINDEX)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "GetUserObjectInformationW", "handle", $HOBJECT, "int", $IINDEX, "ptr", 0, "dword", 0, "dword*", 0)
		IF @ERROR OR NOT $ACALL[5] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TDATA
		SWITCH $IINDEX
			CASE 1
				$TDATA = DLLSTRUCTCREATE($TAGUSEROBJECTFLAGS)
			CASE 5, 6
				$TDATA = DLLSTRUCTCREATE("uint")
			CASE 2, 3
				$TDATA = DLLSTRUCTCREATE("wchar[" & $ACALL[5] & "]")
			CASE 4
				$TDATA = DLLSTRUCTCREATE("byte[" & $ACALL[5] & "]")
			CASE ELSE
				RETURN SETERROR(20, 0, 0)
		ENDSWITCH
		$ACALL = DLLCALL("user32.dll", "bool", "GetUserObjectInformationW", "handle", $HOBJECT, "int", $IINDEX, "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA), "dword*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		SWITCH $IINDEX
			CASE 1, 4
				RETURN $TDATA
			CASE ELSE
				RETURN DLLSTRUCTGETDATA($TDATA, 1)
		ENDSWITCH
	ENDFUNC
	FUNC _WINAPI_GETVERSIONEX()
		LOCAL $TOSVERSIONINFOEX = DLLSTRUCTCREATE($TAGOSVERSIONINFOEX)
		DLLSTRUCTSETDATA($TOSVERSIONINFOEX, "OSVersionInfoSize", DLLSTRUCTGETSIZE($TOSVERSIONINFOEX))
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "GetVersionExW", "struct*", $TOSVERSIONINFOEX)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TOSVERSIONINFOEX
	ENDFUNC
	FUNC _WINAPI_GETWORKAREA()
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "SystemParametersInfo", "uint", 48, "uint", 0, "struct*", $TRECT, "uint", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_INITMUILANGUAGE($ILANGUAGE)
		DLLCALL("comctl32.dll", "none", "InitMUILanguage", "word", $ILANGUAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ISLOADKBLAYOUT($ILANGUAGE)
		LOCAL $ALAYOUT = _WINAPI_GETKEYBOARDLAYOUTLIST()
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		FOR $I = 1 TO $ALAYOUT[0]
			IF $ALAYOUT[$I] = $ILANGUAGE THEN RETURN TRUE
		NEXT
		RETURN FALSE
	ENDFUNC
	FUNC _WINAPI_ISPROCESSORFEATUREPRESENT($IFEATURE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "IsProcessorFeaturePresent", "dword", $IFEATURE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_ISWINDOWENABLED($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "IsWindowEnabled", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_KEYBD_EVENT($VKEY, $IFLAGS, $ISCANCODE = 0, $IEXTRAINFO = 0)
		DLLCALL("user32.dll", "none", "keybd_event", "byte", $VKEY, "byte", $ISCANCODE, "dword", $IFLAGS, "ulong_ptr", $IEXTRAINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_LOADKEYBOARDLAYOUT($ILANGUAGE, $IFLAG = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "LoadKeyboardLayoutW", "wstr", HEX($ILANGUAGE, 8), "uint", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_LOCKWORKSTATION()
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "LockWorkStation")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MAPVIRTUALKEY($ICODE, $ITYPE, $HLOCALE = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "INT", "MapVirtualKeyExW", "uint", $ICODE, "uint", $ITYPE, "uint_ptr", $HLOCALE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_MOUSE_EVENT($IFLAGS, $IX = 0, $IY = 0, $IDATA = 0, $IEXTRAINFO = 0)
		DLLCALL("user32.dll", "none", "mouse_event", "dword", $IFLAGS, "dword", $IX, "dword", $IY, "dword", $IDATA, "ulong_ptr", $IEXTRAINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED)
	ENDFUNC
	FUNC _WINAPI_OPENDESKTOP($SNAME, $IACCESS = 0, $IFLAGS = 0, $BINHERIT = FALSE)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "OpenDesktopW", "wstr", $SNAME, "dword", $IFLAGS, "bool", $BINHERIT, "dword", $IACCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OPENINPUTDESKTOP($IACCESS = 0, $IFLAGS = 0, $BINHERIT = FALSE)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "OpenInputDesktop", "dword", $IFLAGS, "bool", $BINHERIT, "dword", $IACCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_OPENWINDOWSTATION($SNAME, $IACCESS = 0, $BINHERIT = FALSE)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "OpenWindowStationW", "wstr", $SNAME, "bool", $BINHERIT, "dword", $IACCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_QUERYPERFORMANCECOUNTER()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "QueryPerformanceCounter", "int64*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_QUERYPERFORMANCEFREQUENCY()
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "QueryPerformanceFrequency", "int64*", 0)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ACALL[1]
	ENDFUNC
	FUNC _WINAPI_REGISTERHOTKEY($HWND, $IID, $IMODIFIERS, $VKEY)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "RegisterHotKey", "hwnd", $HWND, "int", $IID, "uint", $IMODIFIERS, "uint", $VKEY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERPOWERSETTINGNOTIFICATION($HWND, $SGUID)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		LOCAL $ACALL = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR OR $ACALL[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		$ACALL = DLLCALL("user32.dll", "handle", "RegisterPowerSettingNotification", "handle", $HWND, "struct*", $TGUID, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERRAWINPUTDEVICES($PADEVICE, $ICOUNT = 1)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "RegisterRawInputDevices", "struct*", $PADEVICE, "uint", $ICOUNT, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTDEVICE)))
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_RELEASECAPTURE()
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ReleaseCapture")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_REMOVECLIPBOARDFORMATLISTENER($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "RemoveClipboardFormatListener", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETACTIVEWINDOW($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "SetActiveWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETCAPTURE($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "hwnd", "SetCapture", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETDEFAULTPRINTER($SPRINTER)
		LOCAL $ACALL = DLLCALL("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $SPRINTER)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETDLLDIRECTORY($SDIRPATH = DEFAULT)
		IF $SDIRPATH = DEFAULT THEN $SDIRPATH = NULL
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetDllDirectoryW", "wstr", $SDIRPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETKEYBOARDLAYOUT($HWND, $ILANGUAGE, $IFLAGS = 0)
		IF NOT _WINAPI_ISWINDOW($HWND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $HLOCALE = 0
		IF $ILANGUAGE THEN
			$HLOCALE = _WINAPI_LOADKEYBOARDLAYOUT($ILANGUAGE)
			IF NOT $HLOCALE THEN RETURN SETERROR(10, 0, 0)
		ENDIF
		LOCAL CONST $WM_INPUTLANGCHANGEREQUEST = 80
		DLLCALL("user32.dll", "none", "SendMessage", "hwnd", $HWND, "uint", $WM_INPUTLANGCHANGEREQUEST, "uint", $IFLAGS, "uint_ptr", $HLOCALE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETKEYBOARDSTATE(BYREF $TSTATE)
		LOCAL $ACALL = DLLCALL("user32.dll", "int", "SetKeyboardState", "struct*", $TSTATE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETPROCESSSHUTDOWNPARAMETERS($ILEVEL, $BDIALOG = FALSE)
		LOCAL $ACALL = DLLCALL("kernel32.dll", "bool", "SetProcessShutdownParameters", "dword", $ILEVEL, "dword", NOT $BDIALOG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETPROCESSWINDOWSTATION($HSTATION)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetProcessWindowStation", "handle", $HSTATION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETUSEROBJECTINFORMATION($HOBJECT, $IINDEX, BYREF $TDATA)
		IF $IINDEX <> 1 THEN RETURN SETERROR(10, 0, FALSE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SetUserObjectInformationW", "handle", $HOBJECT, "int", 1, "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWSHOOKEX($IHOOK, $PPROC, $HDLL, $ITHREADID = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "SetWindowsHookEx", "int", $IHOOK, "ptr", $PPROC, "handle", $HDLL, "dword", $ITHREADID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SETWINEVENTHOOK($IEVENTMIN, $IEVENTMAX, $PEVENTPROC, $IPID = 0, $ITHREADID = 0, $IFLAGS = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "handle", "SetWinEventHook", "uint", $IEVENTMIN, "uint", $IEVENTMAX, "ptr", 0, "ptr", $PEVENTPROC, "dword", $IPID, "dword", $ITHREADID, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHUTDOWNBLOCKREASONCREATE($HWND, $STEXT)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ShutdownBlockReasonCreate", "hwnd", $HWND, "wstr", $STEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHUTDOWNBLOCKREASONDESTROY($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ShutdownBlockReasonDestroy", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SHUTDOWNBLOCKREASONQUERY($HWND)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "ShutdownBlockReasonQuery", "hwnd", $HWND, "wstr", "", "dword*", 4096)
		IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ACALL[2]
	ENDFUNC
	FUNC _WINAPI_SWITCHDESKTOP($HDESKTOP)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SwitchDesktop", "handle", $HDESKTOP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_SYSTEMPARAMETERSINFO($IACTION, $IPARAM = 0, $VPARAM = 0, $IWININI = 0)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "SystemParametersInfoW", "uint", $IACTION, "uint", $IPARAM, "struct*", $VPARAM, "uint", $IWININI)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_TRACKMOUSEEVENT($HWND, $IFLAGS, $ITIME = -1)
		LOCAL $TTME = DLLSTRUCTCREATE("dword;dword;hwnd;dword")
		DLLSTRUCTSETDATA($TTME, 1, DLLSTRUCTGETSIZE($TTME))
		DLLSTRUCTSETDATA($TTME, 2, $IFLAGS)
		DLLSTRUCTSETDATA($TTME, 3, $HWND)
		DLLSTRUCTSETDATA($TTME, 4, $ITIME)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "TrackMouseEvent", "struct*", $TTME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNHOOKWINDOWSHOOKEX($HHOOK)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $HHOOK)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNHOOKWINEVENT($HEVENTHOOK)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UnhookWinEvent", "handle", $HEVENTHOOK)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNLOADKEYBOARDLAYOUT($HLOCALE)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UnloadKeyboardLayout", "handle", $HLOCALE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNREGISTERHOTKEY($HWND, $IID)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UnregisterHotKey", "hwnd", $HWND, "int", $IID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC _WINAPI_UNREGISTERPOWERSETTINGNOTIFICATION($HNOTIFY)
		LOCAL $ACALL = DLLCALL("user32.dll", "bool", "UnregisterPowerSettingNotification", "handle", $HNOTIFY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ACALL[0]
	ENDFUNC
	FUNC __ENUMPAGEFILESPROC($ISIZE, $PINFO, $PFILE)
		LOCAL $TEPFI = DLLSTRUCTCREATE("dword;dword;ulong_ptr;ulong_ptr;ulong_ptr", $PINFO)
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0][0]][0] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & (_WINAPI_STRLEN($PFILE) + 1) & "]", $PFILE), 1)
		FOR $I = 1 TO 3
			$__G_VENUM[$__G_VENUM[0][0]][$I] = DLLSTRUCTGETDATA($TEPFI, $I + 2) * $ISIZE
		NEXT
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
	GLOBAL $_G_ARRAYDISPLAY_HLISTVIEW
	GLOBAL $_G_ARRAYDISPLAY_ITRANSPOSE
	GLOBAL $_G_ARRAYDISPLAY_IDISPLAYROW
	GLOBAL $_G_ARRAYDISPLAY_AARRAY
	GLOBAL $_G_ARRAYDISPLAY_IDIMS
	GLOBAL $_G_ARRAYDISPLAY_NROWS
	GLOBAL $_G_ARRAYDISPLAY_NCOLS
	GLOBAL $_G_ARRAYDISPLAY_IITEM_START
	GLOBAL $_G_ARRAYDISPLAY_IITEM_END
	GLOBAL $_G_ARRAYDISPLAY_ISUBITEM_START
	GLOBAL $_G_ARRAYDISPLAY_ISUBITEM_END
	GLOBAL $_G_ARRAYDISPLAY_AINDEX
	GLOBAL $_G_ARRAYDISPLAY_AINDEXES[1]
	GLOBAL $_G_ARRAYDISPLAY_ISORTDIR
	GLOBAL $_G_ARRAYDISPLAY_ASHEADER
	GLOBAL $_G_ARRAYDISPLAY_ANUMERICSORT
	GLOBAL $ARRAYDISPLAY_ROWPREFIX = "#"
	GLOBAL $ARRAYDISPLAY_NUMERICSORT = "*"
	GLOBAL CONST $ARRAYDISPLAY_COLALIGNLEFT = 0
	GLOBAL CONST $ARRAYDISPLAY_TRANSPOSE = 1
	GLOBAL CONST $ARRAYDISPLAY_COLALIGNRIGHT = 2
	GLOBAL CONST $ARRAYDISPLAY_COLALIGNCENTER = 4
	GLOBAL CONST $ARRAYDISPLAY_VERBOSE = 8
	GLOBAL CONST $ARRAYDISPLAY_NOROW = 64
	GLOBAL CONST $ARRAYDISPLAY_CHECKERROR = 128
	GLOBAL CONST $_ARRAYCONSTANT_TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
FUNC __ARRAYDISPLAY_SHARE(CONST BYREF $AARRAY, $STITLE = DEFAULT, $SARRAYRANGE = DEFAULT, $IFLAGS = DEFAULT, $VUSER_SEPARATOR = DEFAULT, $SHEADER = DEFAULT, $IMAX_COLWIDTH = DEFAULT, $HUSER_FUNCTION = DEFAULT, $BDEBUG = TRUE, CONST $_ISCRIPTLINENUMBER = @SCRIPTLINENUMBER, CONST $_ICALLERERROR = @ERROR, CONST $_ICALLEREXTENDED = @EXTENDED)
	LOCAL $SMSGBOXTITLE = (($BDEBUG) ? ("_DebugArrayDisplay") : ("_ArrayDisplay"))
	IF $STITLE = DEFAULT THEN $STITLE = $SMSGBOXTITLE
	IF $SARRAYRANGE = DEFAULT THEN $SARRAYRANGE = ""
	IF $IFLAGS = DEFAULT THEN $IFLAGS = 0
	IF $VUSER_SEPARATOR = DEFAULT THEN $VUSER_SEPARATOR = ""
	IF $SHEADER = DEFAULT THEN $SHEADER = ""
	IF $IMAX_COLWIDTH = DEFAULT THEN $IMAX_COLWIDTH = 350
	IF $IMAX_COLWIDTH > 4095 THEN $IMAX_COLWIDTH = 4095
	IF $HUSER_FUNCTION = DEFAULT THEN $HUSER_FUNCTION = 0
	$_G_ARRAYDISPLAY_ITRANSPOSE = BITAND($IFLAGS, $ARRAYDISPLAY_TRANSPOSE)
	LOCAL $ICOLALIGN = BITAND($IFLAGS, 6)
	LOCAL $IVERBOSE = INT(BITAND($IFLAGS, $ARRAYDISPLAY_VERBOSE))
	$_G_ARRAYDISPLAY_IDISPLAYROW = INT(BITAND($IFLAGS, $ARRAYDISPLAY_NOROW) = 0)
	LOCAL $IBUTTONBORDER = (($BDEBUG) ? (40) : (20))
	#Region Check valid array
		LOCAL $SMSG = "", $IRET = 1
		LOCAL $FTIMER = 0
		IF ISARRAY($AARRAY) THEN
			$_G_ARRAYDISPLAY_AARRAY = $AARRAY
			$_G_ARRAYDISPLAY_IDIMS = UBOUND($_G_ARRAYDISPLAY_AARRAY, $UBOUND_DIMENSIONS)
			IF $_G_ARRAYDISPLAY_IDIMS = 1 THEN $_G_ARRAYDISPLAY_ITRANSPOSE = 0
			$_G_ARRAYDISPLAY_NROWS = UBOUND($_G_ARRAYDISPLAY_AARRAY, $UBOUND_ROWS)
			$_G_ARRAYDISPLAY_NCOLS = ($_G_ARRAYDISPLAY_IDIMS = 2) ? UBOUND($_G_ARRAYDISPLAY_AARRAY, $UBOUND_COLUMNS) : 1
			DIM $_G_ARRAYDISPLAY_ANUMERICSORT[$_G_ARRAYDISPLAY_NCOLS]
			IF $_G_ARRAYDISPLAY_IDIMS > 2 THEN
				$SMSG = "Larger than 2D array passed to function"
				$IRET = 2
			ENDIF
			IF $_ICALLERERROR THEN
				IF $BDEBUG THEN
					IF ISDECLARED("__g_sReportCallBack_DebugReport_Debug") THEN
						$SMSG = "@@ Debug( " & $_ISCRIPTLINENUMBER & ") : @error = " & $_ICALLERERROR & " in " & $SMSGBOXTITLE & "( '" & $STITLE & "' )"
						EXECUTE('$__g_sReportCallBack_DebugReport_Debug("' & $SMSG & '")')
					ENDIF
					$IRET = 3
				ELSEIF BITAND($IFLAGS, $ARRAYDISPLAY_CHECKERROR) THEN
					$SMSG = "@error = " & $_ICALLERERROR & " when calling the function"
					IF $_ISCRIPTLINENUMBER > 0 THEN $SMSG &= " at line " & $_ISCRIPTLINENUMBER
					$IRET = 3
				ENDIF
			ENDIF
		ELSE
			$SMSG = "No array variable passed to function"
		ENDIF
		IF $SMSG THEN
			IF $IVERBOSE AND MSGBOX($MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO, $SMSGBOXTITLE & "() Error: " & $STITLE, $SMSG & @CRLF & @CRLF & "Exit the script?") = $IDYES THEN
				EXIT
			ELSE
				RETURN SETERROR($IRET, 0, 0)
			ENDIF
		ENDIF
	#EndRegion Check valid array
	#Region Check array range
		LOCAL $ICW_COLWIDTH = NUMBER($VUSER_SEPARATOR)
		LOCAL $SCURR_SEPARATOR = OPT("GUIDataSeparatorChar")
		IF $VUSER_SEPARATOR = "" THEN $VUSER_SEPARATOR = $SCURR_SEPARATOR
		$_G_ARRAYDISPLAY_IITEM_START = 0
		$_G_ARRAYDISPLAY_IITEM_END = $_G_ARRAYDISPLAY_NROWS - 1
		$_G_ARRAYDISPLAY_ISUBITEM_START = 0
		$_G_ARRAYDISPLAY_ISUBITEM_END = (($_G_ARRAYDISPLAY_IDIMS = 2) ? ($_G_ARRAYDISPLAY_NCOLS - 1) : (0))
		LOCAL $AVRANGESPLIT
		IF $SARRAYRANGE THEN
			LOCAL $VTMP, $AARRAY_RANGE = STRINGREGEXP($SARRAYRANGE & "||", "(?U)(.*)\|", $STR_REGEXPARRAYGLOBALMATCH)
			IF $AARRAY_RANGE[0] THEN
				$AVRANGESPLIT = STRINGSPLIT($AARRAY_RANGE[0], ":")
				IF @ERROR THEN
					$_G_ARRAYDISPLAY_IITEM_END = NUMBER($AARRAY_RANGE[0])
				ELSE
					$_G_ARRAYDISPLAY_IITEM_START = NUMBER($AVRANGESPLIT[1])
					IF $AVRANGESPLIT[2] <> "" THEN
						$_G_ARRAYDISPLAY_IITEM_END = NUMBER($AVRANGESPLIT[2])
					ENDIF
				ENDIF
			ENDIF
			IF $_G_ARRAYDISPLAY_IITEM_START < 0 THEN $_G_ARRAYDISPLAY_IITEM_START = 0
			IF $_G_ARRAYDISPLAY_IITEM_END >= $_G_ARRAYDISPLAY_NROWS THEN $_G_ARRAYDISPLAY_IITEM_END = $_G_ARRAYDISPLAY_NROWS - 1
			IF($_G_ARRAYDISPLAY_IITEM_START > $_G_ARRAYDISPLAY_IITEM_END) AND($_G_ARRAYDISPLAY_IITEM_END > 0) THEN
				$VTMP = $_G_ARRAYDISPLAY_IITEM_START
				$_G_ARRAYDISPLAY_IITEM_START = $_G_ARRAYDISPLAY_IITEM_END
				$_G_ARRAYDISPLAY_IITEM_END = $VTMP
			ENDIF
			IF $_G_ARRAYDISPLAY_IDIMS = 2 AND $AARRAY_RANGE[1] THEN
				$AVRANGESPLIT = STRINGSPLIT($AARRAY_RANGE[1], ":")
				IF @ERROR THEN
					$_G_ARRAYDISPLAY_ISUBITEM_END = NUMBER($AARRAY_RANGE[1])
				ELSE
					$_G_ARRAYDISPLAY_ISUBITEM_START = NUMBER($AVRANGESPLIT[1])
					IF $AVRANGESPLIT[2] <> "" THEN
						$_G_ARRAYDISPLAY_ISUBITEM_END = NUMBER($AVRANGESPLIT[2])
					ENDIF
				ENDIF
				IF $_G_ARRAYDISPLAY_ISUBITEM_START > $_G_ARRAYDISPLAY_ISUBITEM_END THEN
					$VTMP = $_G_ARRAYDISPLAY_ISUBITEM_START
					$_G_ARRAYDISPLAY_ISUBITEM_START = $_G_ARRAYDISPLAY_ISUBITEM_END
					$_G_ARRAYDISPLAY_ISUBITEM_END = $VTMP
				ENDIF
				IF $_G_ARRAYDISPLAY_ISUBITEM_START < 0 THEN $_G_ARRAYDISPLAY_ISUBITEM_START = 0
				IF $_G_ARRAYDISPLAY_ISUBITEM_END >= $_G_ARRAYDISPLAY_NCOLS THEN $_G_ARRAYDISPLAY_ISUBITEM_END = $_G_ARRAYDISPLAY_NCOLS - 1
			ENDIF
		ENDIF
		LOCAL $SDISPLAYDATA = "[" & $_G_ARRAYDISPLAY_NROWS & "]"
		IF $_G_ARRAYDISPLAY_IDIMS = 2 THEN
			$SDISPLAYDATA &= " [" & $_G_ARRAYDISPLAY_NCOLS & "]"
		ENDIF
		LOCAL $STIPDATA = ""
		IF $SARRAYRANGE THEN
			IF $STIPDATA THEN $STIPDATA &= " - "
			$STIPDATA &= "Range set " & $SARRAYRANGE
		ENDIF
		IF $_G_ARRAYDISPLAY_ITRANSPOSE THEN
			IF $STIPDATA THEN $STIPDATA &= " - "
			$STIPDATA &= "Transposed"
		ENDIF
		IF $SARRAYRANGE OR $_G_ARRAYDISPLAY_ITRANSPOSE THEN $_G_ARRAYDISPLAY_AARRAY = __ARRAYDISPLAY_CREATESUBARRAY()
	#EndRegion Check array range
	#Region Check custom header
		$_G_ARRAYDISPLAY_ASHEADER = STRINGSPLIT($SHEADER, $SCURR_SEPARATOR, $STR_NOCOUNT)
		IF UBOUND($_G_ARRAYDISPLAY_ASHEADER) = 0 THEN DIM $_G_ARRAYDISPLAY_ASHEADER[1] = [""]
		$SHEADER = "Row"
		LOCAL $IINDEX = $_G_ARRAYDISPLAY_ISUBITEM_START
		IF $_G_ARRAYDISPLAY_ITRANSPOSE THEN
			$SHEADER = "Row"
			FOR $J = 0 TO $_G_ARRAYDISPLAY_NCOLS - 1
				$SHEADER &= $SCURR_SEPARATOR & $ARRAYDISPLAY_ROWPREFIX & " " & $J + $_G_ARRAYDISPLAY_ISUBITEM_START
			NEXT
		ELSE
			IF $_G_ARRAYDISPLAY_ASHEADER[0] THEN
				FOR $IINDEX = $_G_ARRAYDISPLAY_ISUBITEM_START TO $_G_ARRAYDISPLAY_ISUBITEM_END
					IF $IINDEX >= UBOUND($_G_ARRAYDISPLAY_ASHEADER) THEN EXITLOOP
					IF STRINGRIGHT($_G_ARRAYDISPLAY_ASHEADER[$IINDEX], 1) = $ARRAYDISPLAY_NUMERICSORT THEN
						$_G_ARRAYDISPLAY_ASHEADER[$IINDEX] = STRINGTRIMRIGHT($_G_ARRAYDISPLAY_ASHEADER[$IINDEX], 1)
						$_G_ARRAYDISPLAY_ANUMERICSORT[$IINDEX - $_G_ARRAYDISPLAY_ISUBITEM_START] = 1
					ENDIF
					$SHEADER &= $SCURR_SEPARATOR & $_G_ARRAYDISPLAY_ASHEADER[$IINDEX]
				NEXT
			ENDIF
			FOR $J = $IINDEX TO $_G_ARRAYDISPLAY_ISUBITEM_END
				$SHEADER &= $SCURR_SEPARATOR & "Col " & $J
			NEXT
		ENDIF
		IF NOT $_G_ARRAYDISPLAY_IDISPLAYROW THEN $SHEADER = STRINGTRIMLEFT($SHEADER, 4)
	#EndRegion Check custom header
	#Region Generate Sort index for columns
		__ARRAYDISPLAY_SORTINDEXES(0, -1)
		LOCAL $HTIMER = TIMERINIT()
		__ARRAYDISPLAY_SORTINDEXES(1, 1)
		$FTIMER = TIMERDIFF($HTIMER)
		IF $FTIMER * $_G_ARRAYDISPLAY_NCOLS < 1000 THEN
			__ARRAYDISPLAY_SORTINDEXES(2, $_G_ARRAYDISPLAY_NCOLS)
			IF $BDEBUG THEN CONSOLEWRITE("Sorting all indexes = " & TIMERDIFF($HTIMER) & @CRLF & @CRLF)
		ELSE
			IF $BDEBUG THEN CONSOLEWRITE("Sorting one index = " & TIMERDIFF($HTIMER) & @CRLF)
		ENDIF
	#EndRegion Generate Sort index for columns
	#Region GUI and Listview generation
		IF $IVERBOSE AND($_G_ARRAYDISPLAY_NROWS * $_G_ARRAYDISPLAY_NCOLS) > 1000 THEN
			SPLASHTEXTON($SMSGBOXTITLE, "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
		ENDIF
		LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 64
		LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKBORDERS = 102
		LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 512
		LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKLEFT = 2
		LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKRIGHT = 4
		LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKHCENTER = 8
		LOCAL CONST $_ARRAYCONSTANT_GUI_EVENT_CLOSE = -3
		LOCAL CONST $_ARRAYCONSTANT_GUI_EVENT_ARRAY = 1
		LOCAL CONST $_ARRAYCONSTANT_GUI_FOCUS = 256
		LOCAL CONST $_ARRAYCONSTANT_SS_CENTER = 1
		LOCAL CONST $_ARRAYCONSTANT_SS_CENTERIMAGE = 512
		LOCAL CONST $_ARRAYCONSTANT_LVM_GETITEMRECT = (4096 + 14)
		LOCAL CONST $_ARRAYCONSTANT_LVM_GETITEMSTATE = (4096 + 44)
		LOCAL CONST $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT = (4096 + 50)
		LOCAL CONST $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE = (4096 + 54)
		LOCAL CONST $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 1
		LOCAL CONST $_ARRAYCONSTANT_LVIS_SELECTED = 2
		LOCAL CONST $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 8
		LOCAL CONST $_ARRAYCONSTANT_LVS_OWNERDATA = 4096
		LOCAL CONST $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 32
		LOCAL CONST $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER = 65536
		LOCAL CONST $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 512
		LOCAL CONST $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 65536
		LOCAL CONST $_ARRAYCONSTANT_WS_MINIMIZEBOX = 131072
		LOCAL CONST $_ARRAYCONSTANT_WS_SIZEBOX = 262144
		LOCAL $ICOORDMODE = OPT("GUICoordMode", 1)
		LOCAL $IORGWIDTH = 210, $IHEIGHT = 200, $IMINSIZE = 250
		LOCAL $HGUI = GUICREATE($STITLE, $IORGWIDTH, $IHEIGHT, DEFAULT, DEFAULT, BITOR($_ARRAYCONSTANT_WS_SIZEBOX, $_ARRAYCONSTANT_WS_MINIMIZEBOX, $_ARRAYCONSTANT_WS_MAXIMIZEBOX))
		LOCAL $AIGUISIZE = WINGETCLIENTSIZE($HGUI)
		LOCAL $IDLISTVIEW = GUICTRLCREATELISTVIEW($SHEADER, 0, 0, $AIGUISIZE[0], $AIGUISIZE[1] - $IBUTTONBORDER, BITOR($_ARRAYCONSTANT_LVS_SHOWSELALWAYS, $_ARRAYCONSTANT_LVS_OWNERDATA))
		$_G_ARRAYDISPLAY_HLISTVIEW = GUICTRLGETHANDLE($IDLISTVIEW)
		GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_GRIDLINES, $_ARRAYCONSTANT_LVS_EX_GRIDLINES)
		GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
		GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER, $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER)
		GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
		LOCAL $HHEADER = HWND(GUICTRLSENDMSG($IDLISTVIEW, (4096 + 31), 0, 0))
		GUICTRLSETRESIZING($IDLISTVIEW, $_ARRAYCONSTANT_GUI_DOCKBORDERS)
		LOCAL $ICOLFILL = $_G_ARRAYDISPLAY_NCOLS + $_G_ARRAYDISPLAY_IDISPLAYROW
		IF $ICOLALIGN THEN
			FOR $I = 0 TO $ICOLFILL - 1
				__ARRAYDISPLAY_JUSTIFYCOLUMN($IDLISTVIEW, $I, $ICOLALIGN / 2)
			NEXT
		ENDIF
		GUICTRLSENDMSG($IDLISTVIEW, (4096 + 47), $_G_ARRAYDISPLAY_NROWS, 0)
		LOCAL $TRECT = DLLSTRUCTCREATE("struct; long Left;long Top;long Right;long Bottom; endstruct")
		DLLCALL("user32.dll", "struct*", "SendMessageW", "hwnd", $_G_ARRAYDISPLAY_HLISTVIEW, "uint", $_ARRAYCONSTANT_LVM_GETITEMRECT, "wparam", 0, "struct*", $TRECT)
		LOCAL $AIWIN_POS = WINGETPOS($HGUI)
		LOCAL $AILV_POS = CONTROLGETPOS($HGUI, "", $IDLISTVIEW)
		$IHEIGHT = (($_G_ARRAYDISPLAY_NROWS + 3) * (DLLSTRUCTGETDATA($TRECT, "Bottom") - DLLSTRUCTGETDATA($TRECT, "Top"))) + $AIWIN_POS[3] - $AILV_POS[3]
		IF $IHEIGHT > @DESKTOPHEIGHT - 100 THEN
			$IHEIGHT = @DESKTOPHEIGHT - 100
		ELSEIF $IHEIGHT < $IMINSIZE THEN
			$IHEIGHT = $IMINSIZE
		ENDIF
		IF $IVERBOSE THEN SPLASHOFF()
		$_G_ARRAYDISPLAY_ISORTDIR = 1024
		LOCAL $ICOLUMN = 0, $ICOLUMNPREV = -1
		IF $_G_ARRAYDISPLAY_IDISPLAYROW THEN
			$ICOLUMNPREV = $ICOLUMN
			__ARRAYDISPLAY_HEADERSETITEMFORMAT($HHEADER, $ICOLUMN, 16384 + $_G_ARRAYDISPLAY_ISORTDIR + $ICOLALIGN / 2)
		ENDIF
		$_G_ARRAYDISPLAY_AINDEX = $_G_ARRAYDISPLAY_AINDEXES[0]
	#EndRegion GUI and Listview generation
	LOCAL $P__ARRAYDISPLAY_NOTIFYHANDLER = DLLCALLBACKGETPTR(DLLCALLBACKREGISTER("__ArrayDisplay_NotifyHandler", "lresult", "hwnd;uint;wparam;lparam;uint_ptr;dword_ptr"))
	DLLCALL("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $HGUI, "ptr", $P__ARRAYDISPLAY_NOTIFYHANDLER, "uint_ptr", 0, "dword_ptr", 0)
	#Region Adjust dialog width
		LOCAL $IWIDTH = 40, $ICOLWIDTH = 0, $AICOLWIDTH[$ICOLFILL], $IMIN_COLWIDTH = 55
		LOCAL $ICOLWIDTHHEADER
		FOR $I = 0 TO $ICOLFILL - 1
			GUICTRLSENDMSG($IDLISTVIEW, (4096 + 30), $I, -1)
			$ICOLWIDTH = GUICTRLSENDMSG($IDLISTVIEW, (4096 + 29), $I, 0)
			IF $SHEADER <> "" THEN
				IF $ICOLWIDTH = 0 THEN EXITLOOP
				GUICTRLSENDMSG($IDLISTVIEW, (4096 + 30), $I, -2)
				$ICOLWIDTHHEADER = GUICTRLSENDMSG($IDLISTVIEW, (4096 + 29), $I, 0)
				IF $ICOLWIDTH < $IMIN_COLWIDTH AND $ICOLWIDTHHEADER < $IMIN_COLWIDTH THEN
					GUICTRLSENDMSG($IDLISTVIEW, (4096 + 30), $I, $IMIN_COLWIDTH)
					$ICOLWIDTH = $IMIN_COLWIDTH
				ELSEIF $ICOLWIDTHHEADER < $ICOLWIDTH THEN
					GUICTRLSENDMSG($IDLISTVIEW, (4096 + 30), $I, $ICOLWIDTH)
				ELSE
					$ICOLWIDTH = $ICOLWIDTHHEADER
				ENDIF
			ELSE
				IF $ICOLWIDTH < $IMIN_COLWIDTH THEN
					GUICTRLSENDMSG($IDLISTVIEW, (4096 + 30), $I, $IMIN_COLWIDTH)
					$ICOLWIDTH = $IMIN_COLWIDTH
				ENDIF
			ENDIF
			$IWIDTH += $ICOLWIDTH
			$AICOLWIDTH[$I] = $ICOLWIDTH
		NEXT
		IF $IWIDTH > @DESKTOPWIDTH - 100 THEN
			$IWIDTH = 40
			FOR $I = 0 TO $ICOLFILL - 1
				IF $AICOLWIDTH[$I] > $IMAX_COLWIDTH THEN
					GUICTRLSENDMSG($IDLISTVIEW, (4096 + 30), $I, $IMAX_COLWIDTH)
					$IWIDTH += $IMAX_COLWIDTH
				ELSE
					$IWIDTH += $AICOLWIDTH[$I]
				ENDIF
				IF $I < 20 AND $BDEBUG THEN CONSOLEWRITE("@@ Debug(" & @SCRIPTLINENUMBER & ") : $iWidth = " & $IWIDTH & " $i = " & $I & @CRLF)
			NEXT
		ENDIF
		IF $IWIDTH > @DESKTOPWIDTH - 100 THEN
			$IWIDTH = @DESKTOPWIDTH - 100
		ELSEIF $IWIDTH < $IMINSIZE THEN
			$IWIDTH = $IMINSIZE
		ENDIF
	#EndRegion Adjust dialog width
	LOCAL $ISCROLLBARSIZE = 0
	IF $IHEIGHT = (@DESKTOPHEIGHT - 100) THEN $ISCROLLBARSIZE = 15
	WINMOVE($HGUI, "", (@DESKTOPWIDTH - $IWIDTH + $ISCROLLBARSIZE) / 2, (@DESKTOPHEIGHT - $IHEIGHT) / 2, $IWIDTH + $ISCROLLBARSIZE, $IHEIGHT)
	$AIGUISIZE = WINGETCLIENTSIZE($HGUI)
	GUICTRLSETPOS($IDLISTVIEW, 0, 0, $IWIDTH, $AIGUISIZE[1] - $IBUTTONBORDER)
	#Region Create bottom infos
		LOCAL $IBUTTONWIDTH_1 = $AIGUISIZE[0] / 2
		LOCAL $IBUTTONWIDTH_2 = $AIGUISIZE[0] / 3
		LOCAL $IDCOPY_ID = 9999, $IDCOPY_DATA = 99999, $IDDATA_LABEL = 99999, $IDUSER_FUNC = 99999, $IDEXIT_SCRIPT = 99999
		IF $BDEBUG THEN
			$IDCOPY_ID = GUICTRLCREATEBUTTON("Copy Data && Hdr/Row", 0, $AIGUISIZE[1] - $IBUTTONBORDER, $IBUTTONWIDTH_1, 20)
			$IDCOPY_DATA = GUICTRLCREATEBUTTON("Copy Data Only", $IBUTTONWIDTH_1, $AIGUISIZE[1] - $IBUTTONBORDER, $IBUTTONWIDTH_1, 20)
			LOCAL $IBUTTONWIDTH_VAR = $IBUTTONWIDTH_1
			LOCAL $IOFFSET = $IBUTTONWIDTH_1
			IF ISFUNC($HUSER_FUNCTION) THEN
				$IDUSER_FUNC = GUICTRLCREATEBUTTON("Run User Func", $IBUTTONWIDTH_2, $AIGUISIZE[1] - 20, $IBUTTONWIDTH_2, 20)
				$IBUTTONWIDTH_VAR = $IBUTTONWIDTH_2
				$IOFFSET = $IBUTTONWIDTH_2 * 2
			ENDIF
			$IDEXIT_SCRIPT = GUICTRLCREATEBUTTON("Exit Script", $IOFFSET, $AIGUISIZE[1] - 20, $IBUTTONWIDTH_VAR, 20)
			$IDDATA_LABEL = GUICTRLCREATELABEL($SDISPLAYDATA, 0, $AIGUISIZE[1] - 20, $IBUTTONWIDTH_VAR, 18, BITOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
		ELSE
			$IDDATA_LABEL = GUICTRLCREATELABEL($SDISPLAYDATA, 0, $AIGUISIZE[1] - 20, $AIGUISIZE[0], 18, BITOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
		ENDIF
		IF $_G_ARRAYDISPLAY_ITRANSPOSE OR $SARRAYRANGE THEN
			GUICTRLSETCOLOR($IDDATA_LABEL, 16711680)
			GUICTRLSETTIP($IDDATA_LABEL, $STIPDATA)
		ENDIF
		GUICTRLSETRESIZING($IDCOPY_ID, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
		GUICTRLSETRESIZING($IDCOPY_DATA, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
		GUICTRLSETRESIZING($IDDATA_LABEL, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
		GUICTRLSETRESIZING($IDUSER_FUNC, $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
		GUICTRLSETRESIZING($IDEXIT_SCRIPT, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
	#EndRegion Create bottom infos
	GUISETSTATE(@SW_SHOW, $HGUI)
	IF $FTIMER > 1000 AND NOT $SARRAYRANGE THEN
		BEEP(750, 250)
		TOOLTIP("Sorting Action can take as long as " & CEILING($FTIMER / 1000) & " sec" & @CRLF & @CRLF & "Please be patient when you click to sort a column", 50, 50, $SMSGBOXTITLE, $TIP_WARNINGICON, $TIP_BALLOON)
		SLEEP(3000)
		TOOLTIP("")
	ENDIF
	#Region GUI Handling events
		LOCAL $IONEVENTMODE = OPT("GUIOnEventMode", 0), $AMSG
		WHILE 1
			$AMSG = GUIGETMSG($_ARRAYCONSTANT_GUI_EVENT_ARRAY)
			IF $AMSG[1] = $HGUI THEN
				SWITCH $AMSG[0]
					CASE $_ARRAYCONSTANT_GUI_EVENT_CLOSE
						EXITLOOP
					CASE $IDCOPY_ID, $IDCOPY_DATA
						LOCAL $ISEL_COUNT = GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT, 0, 0)
						IF $IVERBOSE AND(NOT $ISEL_COUNT) AND($_G_ARRAYDISPLAY_IITEM_END - $_G_ARRAYDISPLAY_IITEM_START) * ($_G_ARRAYDISPLAY_ISUBITEM_END - $_G_ARRAYDISPLAY_ISUBITEM_START) > 10000 THEN
							SPLASHTEXTON($SMSGBOXTITLE, "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
						ENDIF
						LOCAL $SCLIP = "", $SITEM, $ASPLIT, $IFIRSTCOL = 0
						IF $AMSG[0] = $IDCOPY_DATA AND $_G_ARRAYDISPLAY_IDISPLAYROW THEN $IFIRSTCOL = 1
						FOR $I = 0 TO GUICTRLSENDMSG($IDLISTVIEW, 4100, 0, 0) - 1
							IF $ISEL_COUNT AND NOT(GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $I, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) THEN
								CONTINUELOOP
							ENDIF
							$SITEM = __ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED($IDLISTVIEW, $I, $IFIRSTCOL)
							IF $AMSG[0] = $IDCOPY_ID AND NOT $_G_ARRAYDISPLAY_IDISPLAYROW THEN
								$SITEM = $ARRAYDISPLAY_ROWPREFIX & " " & ($I + $_G_ARRAYDISPLAY_IITEM_START) & $SCURR_SEPARATOR & $SITEM
							ENDIF
							IF $ICW_COLWIDTH THEN
								$ASPLIT = STRINGSPLIT($SITEM, $SCURR_SEPARATOR)
								$SITEM = ""
								FOR $J = 1 TO $ASPLIT[0]
									$SITEM &= STRINGFORMAT("%-" & $ICW_COLWIDTH + 1 & "s", STRINGLEFT($ASPLIT[$J], $ICW_COLWIDTH))
								NEXT
							ELSE
								$SITEM = STRINGREPLACE($SITEM, $SCURR_SEPARATOR, $VUSER_SEPARATOR)
							ENDIF
							$SCLIP &= $SITEM & @CRLF
						NEXT
						$SITEM = $SHEADER
						IF $AMSG[0] = $IDCOPY_ID THEN
							$SITEM = $SHEADER
							IF NOT $_G_ARRAYDISPLAY_IDISPLAYROW THEN
								$SITEM = "Row" & $SCURR_SEPARATOR & $SITEM
							ENDIF
							IF $ICW_COLWIDTH THEN
								$ASPLIT = STRINGSPLIT($SITEM, $SCURR_SEPARATOR)
								$SITEM = ""
								FOR $J = 1 TO $ASPLIT[0]
									$SITEM &= STRINGFORMAT("%-" & $ICW_COLWIDTH + 1 & "s", STRINGLEFT($ASPLIT[$J], $ICW_COLWIDTH))
								NEXT
							ELSE
								$SITEM = STRINGREPLACE($SITEM, $SCURR_SEPARATOR, $VUSER_SEPARATOR)
							ENDIF
							$SCLIP = $SITEM & @CRLF & $SCLIP
						ENDIF
						CLIPPUT($SCLIP)
						SPLASHOFF()
						GUICTRLSETSTATE($IDLISTVIEW, $_ARRAYCONSTANT_GUI_FOCUS)
					CASE $IDLISTVIEW
						$ICOLUMN = GUICTRLGETSTATE($IDLISTVIEW)
						IF NOT ISARRAY($_G_ARRAYDISPLAY_AINDEXES[$ICOLUMN + NOT $_G_ARRAYDISPLAY_IDISPLAYROW]) THEN
							__ARRAYDISPLAY_SORTINDEXES($ICOLUMN + NOT $_G_ARRAYDISPLAY_IDISPLAYROW)
						ENDIF
						IF $ICOLUMN <> $ICOLUMNPREV THEN
							__ARRAYDISPLAY_HEADERSETITEMFORMAT($HHEADER, $ICOLUMNPREV, 16384 + $ICOLALIGN / 2)
							IF $_G_ARRAYDISPLAY_IDISPLAYROW AND $ICOLUMN = 0 THEN
								$_G_ARRAYDISPLAY_AINDEX = $_G_ARRAYDISPLAY_AINDEXES[0]
							ELSE
								$_G_ARRAYDISPLAY_AINDEX = $_G_ARRAYDISPLAY_AINDEXES[$ICOLUMN + NOT $_G_ARRAYDISPLAY_IDISPLAYROW]
							ENDIF
						ENDIF
						$_G_ARRAYDISPLAY_ISORTDIR = ($ICOLUMN = $ICOLUMNPREV) ? $_G_ARRAYDISPLAY_ISORTDIR = 1024 ? 512 : 1024 : 1024
						__ARRAYDISPLAY_HEADERSETITEMFORMAT($HHEADER, $ICOLUMN, 16384 + $_G_ARRAYDISPLAY_ISORTDIR + $ICOLALIGN / 2)
						GUICTRLSENDMSG($IDLISTVIEW, (4096 + 140), $ICOLUMN, 0)
						GUICTRLSENDMSG($IDLISTVIEW, (4096 + 47), $_G_ARRAYDISPLAY_NROWS, 0)
						$ICOLUMNPREV = $ICOLUMN
					CASE $IDUSER_FUNC
						LOCAL $AISELITEMS[1] = [0]
						FOR $I = 0 TO GUICTRLSENDMSG($IDLISTVIEW, 4100, 0, 0) - 1
							IF(GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $I, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) THEN
								$AISELITEMS[0] += 1
								REDIM $AISELITEMS[$AISELITEMS[0] + 1]
								$AISELITEMS[$AISELITEMS[0]] = $I + $_G_ARRAYDISPLAY_IITEM_START
							ENDIF
						NEXT
						$HUSER_FUNCTION($_G_ARRAYDISPLAY_AARRAY, $AISELITEMS)
						GUICTRLSETSTATE($IDLISTVIEW, $_ARRAYCONSTANT_GUI_FOCUS)
					CASE $IDEXIT_SCRIPT
						GUIDELETE($HGUI)
						EXIT
				ENDSWITCH
			ENDIF
		WEND
	#EndRegion GUI Handling events
	DLLCALL("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $HGUI, "ptr", $P__ARRAYDISPLAY_NOTIFYHANDLER, "uint_ptr", 0)
	$_G_ARRAYDISPLAY_AINDEX = 0
	DIM $_G_ARRAYDISPLAY_AINDEXES[1]
	GUIDELETE($HGUI)
	OPT("GUICoordMode", $ICOORDMODE)
	OPT("GUIOnEventMode", $IONEVENTMODE)
	RETURN SETERROR($_ICALLERERROR, $_ICALLEREXTENDED, 1)
ENDFUNC
FUNC __ARRAYDISPLAY_NOTIFYHANDLER($HWND, $IMSG, $WPARAM, $LPARAM, $ISUBCLASSID, $PDATA)
	IF $IMSG <> 78 THEN RETURN DLLCALL("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)[0]
	LOCAL STATIC $TAGNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
	LOCAL STATIC $TAGNMLVDISPINFO = $TAGNMHDR & ";" & $_ARRAYCONSTANT_TAGLVITEM
	LOCAL $TNMLVDISPINFO = DLLSTRUCTCREATE($TAGNMLVDISPINFO, $LPARAM)
	SWITCH HWND(DLLSTRUCTGETDATA($TNMLVDISPINFO, "hWndFrom"))
		CASE $_G_ARRAYDISPLAY_HLISTVIEW
			SWITCH DLLSTRUCTGETDATA($TNMLVDISPINFO, "Code")
				CASE -177
					LOCAL STATIC $TTEXT = DLLSTRUCTCREATE("wchar[4096]"), $PTEXT = DLLSTRUCTGETPTR($TTEXT)
					LOCAL $IITEM = DLLSTRUCTGETDATA($TNMLVDISPINFO, "Item")
					LOCAL $IROW = ($_G_ARRAYDISPLAY_ISORTDIR = 1024) ? $_G_ARRAYDISPLAY_AINDEX[$IITEM] : $_G_ARRAYDISPLAY_AINDEX[$_G_ARRAYDISPLAY_NROWS - 1 - $IITEM]
					LOCAL $ICOL = DLLSTRUCTGETDATA($TNMLVDISPINFO, "SubItem")
					LOCAL $STEMP
					IF $_G_ARRAYDISPLAY_IDISPLAYROW = 0 THEN
						IF $_G_ARRAYDISPLAY_IDIMS = 2 THEN
							$STEMP = $_G_ARRAYDISPLAY_AARRAY[$IROW][$ICOL]
						ELSE
							$STEMP = $_G_ARRAYDISPLAY_AARRAY[$IROW]
						ENDIF
						SWITCH VARGETTYPE($STEMP)
							CASE "Array"
								$STEMP = "{Array}"
							CASE "Map"
								$STEMP = "{Map}"
						ENDSWITCH
						IF STRINGLEN($STEMP) > 4095 THEN $STEMP = STRINGLEFT($STEMP, 4095)
						DLLSTRUCTSETDATA($TTEXT, 1, $STEMP)
						DLLSTRUCTSETDATA($TNMLVDISPINFO, "Text", $PTEXT)
					ELSE
						IF $ICOL = 0 THEN
							IF $_G_ARRAYDISPLAY_ITRANSPOSE THEN
								LOCAL $SCAPTIONCPLT = ""
								IF $IROW + $_G_ARRAYDISPLAY_IITEM_START < UBOUND($_G_ARRAYDISPLAY_ASHEADER) AND STRINGSTRIPWS($_G_ARRAYDISPLAY_ASHEADER[$IROW + $_G_ARRAYDISPLAY_IITEM_START], 1 + 2) <> "" THEN
									$SCAPTIONCPLT = " (" & STRINGSTRIPWS($_G_ARRAYDISPLAY_ASHEADER[$IROW + $_G_ARRAYDISPLAY_IITEM_START], 1 + 2)
									IF STRINGRIGHT($SCAPTIONCPLT, 1) = $ARRAYDISPLAY_NUMERICSORT THEN $SCAPTIONCPLT = STRINGTRIMRIGHT($SCAPTIONCPLT, 1)
									$SCAPTIONCPLT &= ")"
								ENDIF
								DLLSTRUCTSETDATA($TTEXT, 1, "Col " & ($IROW + $_G_ARRAYDISPLAY_IITEM_START) & $SCAPTIONCPLT)
							ELSE
								DLLSTRUCTSETDATA($TTEXT, 1, $ARRAYDISPLAY_ROWPREFIX & " " & $IROW + $_G_ARRAYDISPLAY_IITEM_START)
							ENDIF
							DLLSTRUCTSETDATA($TNMLVDISPINFO, "Text", $PTEXT)
						ELSE
							IF $_G_ARRAYDISPLAY_IDIMS = 2 THEN
								$STEMP = $_G_ARRAYDISPLAY_AARRAY[$IROW][$ICOL - 1]
							ELSE
								$STEMP = $_G_ARRAYDISPLAY_AARRAY[$IROW]
							ENDIF
							SWITCH VARGETTYPE($STEMP)
								CASE "Array"
									$STEMP = "{Array}"
								CASE "Map"
									$STEMP = "{Map}"
							ENDSWITCH
							IF STRINGLEN($STEMP) > 4095 THEN $STEMP = STRINGLEFT($STEMP, 4095)
							DLLSTRUCTSETDATA($TTEXT, 1, $STEMP)
							DLLSTRUCTSETDATA($TNMLVDISPINFO, "Text", $PTEXT)
						ENDIF
					ENDIF
					RETURN
			ENDSWITCH
	ENDSWITCH
	RETURN DLLCALL("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)[0]
	#forceref $ISUBCLASSID, $PDATA
ENDFUNC
FUNC __ARRAYDISPLAY_SORTINDEXES($ICOLSTART, $ICOLEND = $ICOLSTART)
	DIM $_G_ARRAYDISPLAY_AINDEX[$_G_ARRAYDISPLAY_NROWS]
	IF $ICOLEND = -1 THEN
		DIM $_G_ARRAYDISPLAY_AINDEXES[$_G_ARRAYDISPLAY_NCOLS + $_G_ARRAYDISPLAY_IDISPLAYROW + 1]
		FOR $I = 0 TO $_G_ARRAYDISPLAY_NROWS - 1
			$_G_ARRAYDISPLAY_AINDEX[$I] = $I
		NEXT
		$_G_ARRAYDISPLAY_AINDEXES[0] = $_G_ARRAYDISPLAY_AINDEX
	ENDIF
	IF $ICOLSTART = -1 THEN
		$ICOLSTART = 1
		$ICOLEND = $_G_ARRAYDISPLAY_NCOLS
	ENDIF
	IF $ICOLSTART THEN
		LOCAL $TINDEX
		FOR $I = $ICOLSTART TO $ICOLEND
			$TINDEX = __ARRAYDISPLAY_GETSORTCOLSTRUCT($_G_ARRAYDISPLAY_AARRAY, $I - 1)
			FOR $J = 0 TO $_G_ARRAYDISPLAY_NROWS - 1
				$_G_ARRAYDISPLAY_AINDEX[$J] = DLLSTRUCTGETDATA($TINDEX, 1, $J + 1)
			NEXT
			$_G_ARRAYDISPLAY_AINDEXES[$I] = $_G_ARRAYDISPLAY_AINDEX
		NEXT
	ENDIF
ENDFUNC
FUNC __ARRAYDISPLAY_GETSORTCOLSTRUCT(CONST BYREF $AARRAY, $ICOL)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) < 1 OR UBOUND($AARRAY, $UBOUND_DIMENSIONS) > 2 THEN
		RETURN SETERROR(6, 0, 0)
	ENDIF
	RETURN __ARRAYDISPLAY_SORTARRAYSTRUCT($AARRAY, $ICOL)
ENDFUNC
FUNC __ARRAYDISPLAY_SORTARRAYSTRUCT(CONST BYREF $AARRAY, $ICOL)
	LOCAL $IDIMS = UBOUND($AARRAY, $UBOUND_DIMENSIONS)
	LOCAL $TINDEX = DLLSTRUCTCREATE("uint[" & $_G_ARRAYDISPLAY_NROWS & "]")
	LOCAL $PINDEX = DLLSTRUCTGETPTR($TINDEX)
	STATIC $HDLL = DLLOPEN("kernel32.dll")
	STATIC $HDLLCOMP = DLLOPEN("shlwapi.dll")
	LOCAL $LO, $HI, $MI, $R, $NVAL1, $NVAL2
	FOR $I = 1 TO $_G_ARRAYDISPLAY_NROWS - 1
		$LO = 0
		$HI = $I - 1
		DO
			$MI = INT(($LO + $HI) / 2)
			IF NOT $_G_ARRAYDISPLAY_ITRANSPOSE AND $_G_ARRAYDISPLAY_ANUMERICSORT[$ICOL] THEN
				IF $IDIMS = 1 THEN
					$NVAL1 = NUMBER($AARRAY[$I])
					$NVAL2 = NUMBER($AARRAY[DLLSTRUCTGETDATA($TINDEX, 1, $MI + 1)])
				ELSE
					$NVAL1 = NUMBER($AARRAY[$I][$ICOL])
					$NVAL2 = NUMBER($AARRAY[DLLSTRUCTGETDATA($TINDEX, 1, $MI + 1)][$ICOL])
				ENDIF
				$R = $NVAL1 < $NVAL2 ? -1 : $NVAL1 > $NVAL2 ? 1 : 0
			ELSE
				IF $IDIMS = 1 THEN
					$R = DLLCALL($HDLLCOMP, "int", "StrCmpLogicalW", "wstr", $AARRAY[$I], "wstr", $AARRAY[DLLSTRUCTGETDATA($TINDEX, 1, $MI + 1)])[0]
				ELSE
					$R = DLLCALL($HDLLCOMP, "int", "StrCmpLogicalW", "wstr", $AARRAY[$I][$ICOL], "wstr", $AARRAY[DLLSTRUCTGETDATA($TINDEX, 1, $MI + 1)][$ICOL])[0]
				ENDIF
			ENDIF
			SWITCH $R
				CASE -1
					$HI = $MI - 1
				CASE 1
					$LO = $MI + 1
				CASE 0
					EXITLOOP
			ENDSWITCH
		UNTIL $LO > $HI
		DLLCALL($HDLL, "none", "RtlMoveMemory", "struct*", $PINDEX + ($MI + 1) * 4, "struct*", $PINDEX + $MI * 4, "ulong_ptr", ($I - $MI) * 4)
		DLLSTRUCTSETDATA($TINDEX, 1, $I, $MI + 1 + ($LO = $MI + 1))
	NEXT
	RETURN $TINDEX
ENDFUNC
FUNC __ARRAYDISPLAY_CREATESUBARRAY()
	LOCAL $NROWS = $_G_ARRAYDISPLAY_IITEM_END - $_G_ARRAYDISPLAY_IITEM_START + 1
	LOCAL $NCOLS = $_G_ARRAYDISPLAY_ISUBITEM_END - $_G_ARRAYDISPLAY_ISUBITEM_START + 1
	LOCAL $IROW = -1, $ICOL, $ITEMP, $ATEMP
	IF $_G_ARRAYDISPLAY_ITRANSPOSE THEN
		DIM $ATEMP[$NCOLS][$NROWS]
		FOR $I = $_G_ARRAYDISPLAY_IITEM_START TO $_G_ARRAYDISPLAY_IITEM_END
			$IROW += 1
			$ICOL = -1
			FOR $J = $_G_ARRAYDISPLAY_ISUBITEM_START TO $_G_ARRAYDISPLAY_ISUBITEM_END
				$ICOL += 1
				$ATEMP[$ICOL][$IROW] = $_G_ARRAYDISPLAY_AARRAY[$I][$J]
			NEXT
		NEXT
		$ITEMP = $_G_ARRAYDISPLAY_IITEM_START
		$_G_ARRAYDISPLAY_IITEM_START = $_G_ARRAYDISPLAY_ISUBITEM_START
		$_G_ARRAYDISPLAY_ISUBITEM_START = $ITEMP
		$ITEMP = $_G_ARRAYDISPLAY_IITEM_END
		$_G_ARRAYDISPLAY_IITEM_END = $_G_ARRAYDISPLAY_ISUBITEM_END
		$_G_ARRAYDISPLAY_ISUBITEM_END = $ITEMP
		$_G_ARRAYDISPLAY_NROWS = $NCOLS
		$_G_ARRAYDISPLAY_NCOLS = $NROWS
	ELSE
		IF $_G_ARRAYDISPLAY_IDIMS = 1 THEN
			DIM $ATEMP[$NROWS]
			FOR $I = $_G_ARRAYDISPLAY_IITEM_START TO $_G_ARRAYDISPLAY_IITEM_END
				$IROW += 1
				$ATEMP[$IROW] = $_G_ARRAYDISPLAY_AARRAY[$I]
			NEXT
		ELSE
			DIM $ATEMP[$NROWS][$NCOLS]
			FOR $I = $_G_ARRAYDISPLAY_IITEM_START TO $_G_ARRAYDISPLAY_IITEM_END
				$IROW += 1
				$ICOL = -1
				FOR $J = $_G_ARRAYDISPLAY_ISUBITEM_START TO $_G_ARRAYDISPLAY_ISUBITEM_END
					$ICOL += 1
					$ATEMP[$IROW][$ICOL] = $_G_ARRAYDISPLAY_AARRAY[$I][$J]
				NEXT
			NEXT
			$_G_ARRAYDISPLAY_NCOLS = $NCOLS
		ENDIF
		$_G_ARRAYDISPLAY_NROWS = $NROWS
	ENDIF
	RETURN $ATEMP
ENDFUNC
FUNC __ARRAYDISPLAY_HEADERSETITEMFORMAT($HWND, $IINDEX, $IFORMAT)
	LOCAL STATIC $THDITEM = DLLSTRUCTCREATE("uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State")
	DLLSTRUCTSETDATA($THDITEM, "Mask", 4)
	DLLSTRUCTSETDATA($THDITEM, "Fmt", $IFORMAT)
	LOCAL $ARESULT = DLLCALL("user32.dll", "lresult", "SendMessageW", "hwnd", $HWND, "uint", 4620, "wparam", $IINDEX, "struct*", $THDITEM)
	RETURN $ARESULT[0] <> 0
ENDFUNC
FUNC __ARRAYDISPLAY_GETITEMTEXT($IDLISTVIEW, $IINDEX, $ISUBITEM = 0)
	LOCAL $TBUFFER = DLLSTRUCTCREATE("wchar Text[4096]")
	LOCAL $PBUFFER = DLLSTRUCTGETPTR($TBUFFER)
	LOCAL $TITEM = DLLSTRUCTCREATE($_ARRAYCONSTANT_TAGLVITEM)
	DLLSTRUCTSETDATA($TITEM, "SubItem", $ISUBITEM)
	DLLSTRUCTSETDATA($TITEM, "TextMax", 4096)
	DLLSTRUCTSETDATA($TITEM, "Text", $PBUFFER)
	IF ISHWND($IDLISTVIEW) THEN
		DLLCALL("user32.dll", "lresult", "SendMessageW", "hwnd", $IDLISTVIEW, "uint", 4211, "wparam", $IINDEX, "struct*", $TITEM)
	ELSE
		LOCAL $PITEM = DLLSTRUCTGETPTR($TITEM)
		GUICTRLSENDMSG($IDLISTVIEW, 4211, $IINDEX, $PITEM)
	ENDIF
	RETURN DLLSTRUCTGETDATA($TBUFFER, "Text")
ENDFUNC
FUNC __ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED($IDLISTVIEW, $IITEM, $IFIRSTCOL)
	LOCAL $SROW = "", $SSEPARATORCHAR = OPT("GUIDataSeparatorChar")
	LOCAL $ISELECTED = $IITEM
	LOCAL $HHEADER = HWND(GUICTRLSENDMSG($IDLISTVIEW, 4127, 0, 0))
	LOCAL $NCOL = DLLCALL("user32.dll", "lresult", "SendMessageW", "hwnd", $HHEADER, "uint", 4608, "wparam", 0, "lparam", 0)[0]
	FOR $X = $IFIRSTCOL TO $NCOL - 1
		$SROW &= __ARRAYDISPLAY_GETITEMTEXT($IDLISTVIEW, $ISELECTED, $X) & $SSEPARATORCHAR
	NEXT
	RETURN STRINGTRIMRIGHT($SROW, 1)
ENDFUNC
FUNC __ARRAYDISPLAY_JUSTIFYCOLUMN($IDLISTVIEW, $IINDEX, $IALIGN = -1)
	LOCAL $TCOLUMN = DLLSTRUCTCREATE("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
	IF $IALIGN < 0 OR $IALIGN > 2 THEN $IALIGN = 0
	DLLSTRUCTSETDATA($TCOLUMN, "Mask", 1)
	DLLSTRUCTSETDATA($TCOLUMN, "Fmt", $IALIGN)
	LOCAL $PCOLUMN = DLLSTRUCTGETPTR($TCOLUMN)
	LOCAL $IRET = GUICTRLSENDMSG($IDLISTVIEW, 4192, $IINDEX, $PCOLUMN)
	RETURN $IRET <> 0
ENDFUNC
GLOBAL ENUM $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER, $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING, $ARRAYFILL_FORCE_BOOLEAN
GLOBAL ENUM $ARRAYUNIQUE_NOCOUNT, $ARRAYUNIQUE_COUNT
GLOBAL ENUM $ARRAYUNIQUE_AUTO, $ARRAYUNIQUE_FORCE32, $ARRAYUNIQUE_FORCE64, $ARRAYUNIQUE_MATCH, $ARRAYUNIQUE_DISTINCT
FUNC _ARRAYADD(BYREF $AARRAY, $VVALUE, $ISTART = 0, $SDELIM_ITEM = "|", $SDELIM_ROW = @CRLF, $IFORCE = $ARRAYFILL_FORCE_DEFAULT)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $SDELIM_ITEM = DEFAULT THEN $SDELIM_ITEM = "|"
	IF $SDELIM_ROW = DEFAULT THEN $SDELIM_ROW = @CRLF
	IF $IFORCE = DEFAULT THEN $IFORCE = $ARRAYFILL_FORCE_DEFAULT
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	LOCAL $HDATATYPE = 0
	SWITCH $IFORCE
		CASE $ARRAYFILL_FORCE_INT
			$HDATATYPE = INT
		CASE $ARRAYFILL_FORCE_NUMBER
			$HDATATYPE = NUMBER
		CASE $ARRAYFILL_FORCE_PTR
			$HDATATYPE = PTR
		CASE $ARRAYFILL_FORCE_HWND
			$HDATATYPE = HWND
		CASE $ARRAYFILL_FORCE_STRING
			$HDATATYPE = STRING
		CASE $ARRAYFILL_FORCE_BOOLEAN
			$HDATATYPE = "Boolean"
	ENDSWITCH
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $IFORCE = $ARRAYFILL_FORCE_SINGLEITEM THEN
				REDIM $AARRAY[$IDIM_1 + 1]
				$AARRAY[$IDIM_1] = $VVALUE
				RETURN $IDIM_1
			ENDIF
			IF ISARRAY($VVALUE) THEN
				IF UBOUND($VVALUE, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(5, 0, -1)
				$HDATATYPE = 0
			ELSE
				LOCAL $ATMP = STRINGSPLIT($VVALUE, $SDELIM_ITEM, $STR_NOCOUNT + $STR_ENTIRESPLIT)
				IF UBOUND($ATMP, $UBOUND_ROWS) = 1 THEN
					$ATMP[0] = $VVALUE
				ENDIF
				$VVALUE = $ATMP
			ENDIF
			LOCAL $IADD = UBOUND($VVALUE, $UBOUND_ROWS)
			REDIM $AARRAY[$IDIM_1 + $IADD]
			FOR $I = 0 TO $IADD - 1
				IF STRING($HDATATYPE) = "Boolean" THEN
					SWITCH $VVALUE[$I]
						CASE "True", "1"
							$AARRAY[$IDIM_1 + $I] = TRUE
						CASE "False", "0", ""
							$AARRAY[$IDIM_1 + $I] = FALSE
					ENDSWITCH
				ELSEIF ISFUNC($HDATATYPE) THEN
					$AARRAY[$IDIM_1 + $I] = $HDATATYPE($VVALUE[$I])
				ELSE
					$AARRAY[$IDIM_1 + $I] = $VVALUE[$I]
				ENDIF
			NEXT
			RETURN $IDIM_1 + $IADD - 1
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
			IF $ISTART < 0 OR $ISTART > $IDIM_2 - 1 THEN RETURN SETERROR(4, 0, -1)
			LOCAL $IVALDIM_1, $IVALDIM_2 = 0, $ICOLCOUNT
			IF ISARRAY($VVALUE) THEN
				IF UBOUND($VVALUE, $UBOUND_DIMENSIONS) <> 2 THEN RETURN SETERROR(5, 0, -1)
				$IVALDIM_1 = UBOUND($VVALUE, $UBOUND_ROWS)
				$IVALDIM_2 = UBOUND($VVALUE, $UBOUND_COLUMNS)
				$HDATATYPE = 0
			ELSE
				LOCAL $ASPLIT_1 = STRINGSPLIT($VVALUE, $SDELIM_ROW, $STR_NOCOUNT + $STR_ENTIRESPLIT)
				$IVALDIM_1 = UBOUND($ASPLIT_1, $UBOUND_ROWS)
				LOCAL $ATMP[$IVALDIM_1][0], $ASPLIT_2
				FOR $I = 0 TO $IVALDIM_1 - 1
					$ASPLIT_2 = STRINGSPLIT($ASPLIT_1[$I], $SDELIM_ITEM, $STR_NOCOUNT + $STR_ENTIRESPLIT)
					$ICOLCOUNT = UBOUND($ASPLIT_2)
					IF $ICOLCOUNT > $IVALDIM_2 THEN
						$IVALDIM_2 = $ICOLCOUNT
						REDIM $ATMP[$IVALDIM_1][$IVALDIM_2]
					ENDIF
					FOR $J = 0 TO $ICOLCOUNT - 1
						$ATMP[$I][$J] = $ASPLIT_2[$J]
					NEXT
				NEXT
				$VVALUE = $ATMP
			ENDIF
			IF UBOUND($VVALUE, $UBOUND_COLUMNS) + $ISTART > UBOUND($AARRAY, $UBOUND_COLUMNS) THEN RETURN SETERROR(3, 0, -1)
			REDIM $AARRAY[$IDIM_1 + $IVALDIM_1][$IDIM_2]
			FOR $IWRITETO_INDEX = 0 TO $IVALDIM_1 - 1
				FOR $J = 0 TO $IDIM_2 - 1
					IF $J < $ISTART THEN
						$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = ""
					ELSEIF $J - $ISTART > $IVALDIM_2 - 1 THEN
						$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = ""
					ELSE
						IF STRING($HDATATYPE) = "Boolean" THEN
							SWITCH $VVALUE[$IWRITETO_INDEX][$J - $ISTART]
								CASE "True", "1"
									$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = TRUE
								CASE "False", "0", ""
									$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = FALSE
							ENDSWITCH
						ELSEIF ISFUNC($HDATATYPE) THEN
							$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = $HDATATYPE($VVALUE[$IWRITETO_INDEX][$J - $ISTART])
						ELSE
							$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = $VVALUE[$IWRITETO_INDEX][$J - $ISTART]
						ENDIF
					ENDIF
				NEXT
			NEXT
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_ROWS) - 1
ENDFUNC
FUNC _ARRAYBINARYSEARCH(CONST BYREF $AARRAY, $VVALUE, $ISTART = 0, $IEND = 0, $ICOLUMN = 0)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ICOLUMN = DEFAULT THEN $ICOLUMN = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	IF $IDIM_1 = 0 THEN RETURN SETERROR(6, 0, -1)
	IF $IEND < 1 OR $IEND > $IDIM_1 - 1 THEN $IEND = $IDIM_1 - 1
	IF $ISTART < 0 THEN $ISTART = 0
	IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	LOCAL $IMID = INT(($IEND + $ISTART) / 2)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $AARRAY[$ISTART] > $VVALUE OR $AARRAY[$IEND] < $VVALUE THEN RETURN SETERROR(2, 0, -1)
			WHILE $ISTART <= $IMID AND $VVALUE <> $AARRAY[$IMID]
				IF $VVALUE < $AARRAY[$IMID] THEN
					$IEND = $IMID - 1
				ELSE
					$ISTART = $IMID + 1
				ENDIF
				$IMID = INT(($IEND + $ISTART) / 2)
			WEND
			IF $ISTART > $IEND THEN RETURN SETERROR(3, 0, -1)
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $ICOLUMN < 0 OR $ICOLUMN > $IDIM_2 THEN RETURN SETERROR(7, 0, -1)
			IF $AARRAY[$ISTART][$ICOLUMN] > $VVALUE OR $AARRAY[$IEND][$ICOLUMN] < $VVALUE THEN RETURN SETERROR(2, 0, -1)
			WHILE $ISTART <= $IMID AND $VVALUE <> $AARRAY[$IMID][$ICOLUMN]
				IF $VVALUE < $AARRAY[$IMID][$ICOLUMN] THEN
					$IEND = $IMID - 1
				ELSE
					$ISTART = $IMID + 1
				ENDIF
				$IMID = INT(($IEND + $ISTART) / 2)
			WEND
			IF $ISTART > $IEND THEN RETURN SETERROR(3, 0, -1)
		CASE ELSE
			RETURN SETERROR(5, 0, -1)
	ENDSWITCH
	RETURN $IMID
ENDFUNC
FUNC _ARRAYCOLDELETE(BYREF $AARRAY, $ICOLUMN, $BCONVERT = FALSE)
	IF $BCONVERT = DEFAULT THEN $BCONVERT = FALSE
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 2 THEN RETURN SETERROR(2, 0, -1)
	LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
	SWITCH $IDIM_2
		CASE 2
			IF $ICOLUMN < 0 OR $ICOLUMN > 1 THEN RETURN SETERROR(3, 0, -1)
			IF $BCONVERT THEN
				LOCAL $ATEMPARRAY[$IDIM_1]
				FOR $I = 0 TO $IDIM_1 - 1
					$ATEMPARRAY[$I] = $AARRAY[$I][(NOT $ICOLUMN)]
				NEXT
				$AARRAY = $ATEMPARRAY
			ELSE
				CONTINUECASE
			ENDIF
		CASE ELSE
			IF $ICOLUMN < 0 OR $ICOLUMN > $IDIM_2 - 1 THEN RETURN SETERROR(3, 0, -1)
			FOR $I = 0 TO $IDIM_1 - 1
				FOR $J = $ICOLUMN TO $IDIM_2 - 2
					$AARRAY[$I][$J] = $AARRAY[$I][$J + 1]
				NEXT
			NEXT
			REDIM $AARRAY[$IDIM_1][$IDIM_2 - 1]
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_COLUMNS)
ENDFUNC
FUNC _ARRAYCOLINSERT(BYREF $AARRAY, $ICOLUMN)
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			LOCAL $ATEMPARRAY[$IDIM_1][2]
			SWITCH $ICOLUMN
				CASE 0, 1
					FOR $I = 0 TO $IDIM_1 - 1
						$ATEMPARRAY[$I][(NOT $ICOLUMN)] = $AARRAY[$I]
					NEXT
				CASE ELSE
					RETURN SETERROR(3, 0, -1)
			ENDSWITCH
			$AARRAY = $ATEMPARRAY
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
			IF $ICOLUMN < 0 OR $ICOLUMN > $IDIM_2 THEN RETURN SETERROR(3, 0, -1)
			REDIM $AARRAY[$IDIM_1][$IDIM_2 + 1]
			FOR $I = 0 TO $IDIM_1 - 1
				FOR $J = $IDIM_2 TO $ICOLUMN + 1 STEP -1
					$AARRAY[$I][$J] = $AARRAY[$I][$J - 1]
				NEXT
				$AARRAY[$I][$ICOLUMN] = ""
			NEXT
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_COLUMNS)
ENDFUNC
FUNC _ARRAYCOMBINATIONS(CONST BYREF $AARRAY, $ISET, $SDELIMITER = "")
	IF $SDELIMITER = DEFAULT THEN $SDELIMITER = ""
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(2, 0, 0)
	LOCAL $IN = UBOUND($AARRAY)
	LOCAL $IR = $ISET
	LOCAL $AIDX[$IR]
	FOR $I = 0 TO $IR - 1
		$AIDX[$I] = $I
	NEXT
	LOCAL $ITOTAL = __ARRAY_COMBINATIONS($IN, $IR)
	LOCAL $ILEFT = $ITOTAL
	LOCAL $ARESULT[$ITOTAL + 1]
	$ARESULT[0] = $ITOTAL
	LOCAL $ICOUNT = 1
	WHILE $ILEFT > 0
		__ARRAY_GETNEXT($IN, $IR, $ILEFT, $ITOTAL, $AIDX)
		FOR $I = 0 TO $ISET - 1
			$ARESULT[$ICOUNT] &= $AARRAY[$AIDX[$I]] & $SDELIMITER
		NEXT
		IF $SDELIMITER <> "" THEN $ARESULT[$ICOUNT] = STRINGTRIMRIGHT($ARESULT[$ICOUNT], 1)
		$ICOUNT += 1
	WEND
	RETURN $ARESULT
ENDFUNC
FUNC _ARRAYCONCATENATE(BYREF $AARRAYTARGET, CONST BYREF $AARRAYSOURCE, $ISTART = 0)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF NOT ISARRAY($AARRAYTARGET) THEN RETURN SETERROR(1, 0, -1)
	IF NOT ISARRAY($AARRAYSOURCE) THEN RETURN SETERROR(2, 0, -1)
	LOCAL $IDIM_TOTAL_TGT = UBOUND($AARRAYTARGET, $UBOUND_DIMENSIONS)
	LOCAL $IDIM_TOTAL_SRC = UBOUND($AARRAYSOURCE, $UBOUND_DIMENSIONS)
	LOCAL $IDIM_1_TGT = UBOUND($AARRAYTARGET, $UBOUND_ROWS)
	LOCAL $IDIM_1_SRC = UBOUND($AARRAYSOURCE, $UBOUND_ROWS)
	IF $ISTART < 0 OR $ISTART > $IDIM_1_SRC - 1 THEN RETURN SETERROR(6, 0, -1)
	SWITCH $IDIM_TOTAL_TGT
		CASE 1
			IF $IDIM_TOTAL_SRC <> 1 THEN RETURN SETERROR(4, 0, -1)
			REDIM $AARRAYTARGET[$IDIM_1_TGT + $IDIM_1_SRC - $ISTART]
			FOR $I = $ISTART TO $IDIM_1_SRC - 1
				$AARRAYTARGET[$IDIM_1_TGT + $I - $ISTART] = $AARRAYSOURCE[$I]
			NEXT
		CASE 2
			IF $IDIM_TOTAL_SRC <> 2 THEN RETURN SETERROR(4, 0, -1)
			LOCAL $IDIM_2_TGT = UBOUND($AARRAYTARGET, $UBOUND_COLUMNS)
			IF UBOUND($AARRAYSOURCE, $UBOUND_COLUMNS) <> $IDIM_2_TGT THEN RETURN SETERROR(5, 0, -1)
			REDIM $AARRAYTARGET[$IDIM_1_TGT + $IDIM_1_SRC - $ISTART][$IDIM_2_TGT]
			FOR $I = $ISTART TO $IDIM_1_SRC - 1
				FOR $J = 0 TO $IDIM_2_TGT - 1
					$AARRAYTARGET[$IDIM_1_TGT + $I - $ISTART][$J] = $AARRAYSOURCE[$I][$J]
				NEXT
			NEXT
		CASE ELSE
			RETURN SETERROR(3, 0, -1)
	ENDSWITCH
	RETURN UBOUND($AARRAYTARGET, $UBOUND_ROWS)
ENDFUNC
FUNC _ARRAYDELETE(BYREF $AARRAY, $VRANGE)
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF ISARRAY($VRANGE) THEN
		IF UBOUND($VRANGE, $UBOUND_DIMENSIONS) <> 1 OR UBOUND($VRANGE, $UBOUND_ROWS) < 2 THEN RETURN SETERROR(4, 0, -1)
	ELSE
		LOCAL $INUMBER, $ASPLIT_1, $ASPLIT_2
		$VRANGE = STRINGSTRIPWS($VRANGE, 8)
		$ASPLIT_1 = STRINGSPLIT($VRANGE, ";")
		$VRANGE = ""
		FOR $I = 1 TO $ASPLIT_1[0]
			IF NOT STRINGREGEXP($ASPLIT_1[$I], "^\d+(-\d+)?$") THEN RETURN SETERROR(3, 0, -1)
			$ASPLIT_2 = STRINGSPLIT($ASPLIT_1[$I], "-")
			SWITCH $ASPLIT_2[0]
				CASE 1
					$VRANGE &= $ASPLIT_2[1] & ";"
				CASE 2
					IF NUMBER($ASPLIT_2[2]) >= NUMBER($ASPLIT_2[1]) THEN
						$INUMBER = $ASPLIT_2[1] - 1
						DO
							$INUMBER += 1
							$VRANGE &= $INUMBER & ";"
						UNTIL $INUMBER = $ASPLIT_2[2]
					ENDIF
			ENDSWITCH
		NEXT
		$VRANGE = STRINGSPLIT(STRINGTRIMRIGHT($VRANGE, 1), ";")
	ENDIF
	FOR $I = 1 TO $VRANGE[0]
		$VRANGE[$I] = NUMBER($VRANGE[$I])
	NEXT
	IF $VRANGE[1] < 0 OR $VRANGE[$VRANGE[0]] > $IDIM_1 THEN RETURN SETERROR(5, 0, -1)
	LOCAL $ICOPYTO_INDEX = 0
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			FOR $I = 1 TO $VRANGE[0]
				$AARRAY[$VRANGE[$I]] = CHRW(64177)
			NEXT
			FOR $IREADFROM_INDEX = 0 TO $IDIM_1
				IF $AARRAY[$IREADFROM_INDEX] == CHRW(64177) THEN
					CONTINUELOOP
				ELSE
					IF $IREADFROM_INDEX <> $ICOPYTO_INDEX THEN
						$AARRAY[$ICOPYTO_INDEX] = $AARRAY[$IREADFROM_INDEX]
					ENDIF
					$ICOPYTO_INDEX += 1
				ENDIF
			NEXT
			REDIM $AARRAY[$IDIM_1 - $VRANGE[0] + 1]
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			FOR $I = 1 TO $VRANGE[0]
				$AARRAY[$VRANGE[$I]][0] = CHRW(64177)
			NEXT
			FOR $IREADFROM_INDEX = 0 TO $IDIM_1
				IF $AARRAY[$IREADFROM_INDEX][0] == CHRW(64177) THEN
					CONTINUELOOP
				ELSE
					IF $IREADFROM_INDEX <> $ICOPYTO_INDEX THEN
						FOR $J = 0 TO $IDIM_2
							$AARRAY[$ICOPYTO_INDEX][$J] = $AARRAY[$IREADFROM_INDEX][$J]
						NEXT
					ENDIF
					$ICOPYTO_INDEX += 1
				ENDIF
			NEXT
			REDIM $AARRAY[$IDIM_1 - $VRANGE[0] + 1][$IDIM_2 + 1]
		CASE ELSE
			RETURN SETERROR(2, 0, FALSE)
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_ROWS)
ENDFUNC
FUNC _ARRAYDISPLAY(CONST BYREF $AARRAY, $STITLE = DEFAULT, $SARRAYRANGE = DEFAULT, $IFLAGS = DEFAULT, $VUSER_SEPARATOR = DEFAULT, $SHEADER = DEFAULT, $IMAX_COLWIDTH = DEFAULT)
	#forceref $VUSER_SEPARATOR
	LOCAL $IRET = __ARRAYDISPLAY_SHARE($AARRAY, $STITLE, $SARRAYRANGE, $IFLAGS, DEFAULT, $SHEADER, $IMAX_COLWIDTH, 0, FALSE)
	RETURN SETERROR(@ERROR, @EXTENDED, $IRET)
ENDFUNC
FUNC _ARRAYEXTRACT(CONST BYREF $AARRAY, $ISTART_ROW = -1, $IEND_ROW = -1, $ISTART_COL = -1, $IEND_COL = -1)
	IF $ISTART_ROW = DEFAULT THEN $ISTART_ROW = -1
	IF $IEND_ROW = DEFAULT THEN $IEND_ROW = -1
	IF $ISTART_COL = DEFAULT THEN $ISTART_COL = -1
	IF $IEND_COL = DEFAULT THEN $IEND_COL = -1
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF $IEND_ROW = -1 THEN $IEND_ROW = $IDIM_1
	IF $ISTART_ROW = -1 THEN $ISTART_ROW = 0
	IF $ISTART_ROW < -1 OR $IEND_ROW < -1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART_ROW > $IDIM_1 OR $IEND_ROW > $IDIM_1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART_ROW > $IEND_ROW THEN RETURN SETERROR(4, 0, -1)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			LOCAL $ARETARRAY[$IEND_ROW - $ISTART_ROW + 1]
			FOR $I = 0 TO $IEND_ROW - $ISTART_ROW
				$ARETARRAY[$I] = $AARRAY[$I + $ISTART_ROW]
			NEXT
			RETURN $ARETARRAY
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $IEND_COL = -1 THEN $IEND_COL = $IDIM_2
			IF $ISTART_COL = -1 THEN $ISTART_COL = 0
			IF $ISTART_COL < -1 OR $IEND_COL < -1 THEN RETURN SETERROR(5, 0, -1)
			IF $ISTART_COL > $IDIM_2 OR $IEND_COL > $IDIM_2 THEN RETURN SETERROR(5, 0, -1)
			IF $ISTART_COL > $IEND_COL THEN RETURN SETERROR(6, 0, -1)
			IF $ISTART_COL = $IEND_COL THEN
				LOCAL $ARETARRAY[$IEND_ROW - $ISTART_ROW + 1]
			ELSE
				LOCAL $ARETARRAY[$IEND_ROW - $ISTART_ROW + 1][$IEND_COL - $ISTART_COL + 1]
			ENDIF
			FOR $I = 0 TO $IEND_ROW - $ISTART_ROW
				FOR $J = 0 TO $IEND_COL - $ISTART_COL
					IF $ISTART_COL = $IEND_COL THEN
						$ARETARRAY[$I] = $AARRAY[$I + $ISTART_ROW][$J + $ISTART_COL]
					ELSE
						$ARETARRAY[$I][$J] = $AARRAY[$I + $ISTART_ROW][$J + $ISTART_COL]
					ENDIF
				NEXT
			NEXT
			RETURN $ARETARRAY
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYFINDALL(CONST BYREF $AARRAY, $VVALUE, $ISTART = 0, $IEND = 0, $ICASE = 0, $ICOMPARE = 0, $ISUBITEM = 0, $BROW = FALSE)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ICASE = DEFAULT THEN $ICASE = 0
	IF $ICOMPARE = DEFAULT THEN $ICOMPARE = 0
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	IF $BROW = DEFAULT THEN $BROW = FALSE
	$ISTART = _ARRAYSEARCH($AARRAY, $VVALUE, $ISTART, $IEND, $ICASE, $ICOMPARE, 1, $ISUBITEM, $BROW)
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, -1)
	LOCAL $IINDEX = 0, $AVRESULT[UBOUND($AARRAY, ($BROW ? $UBOUND_COLUMNS : $UBOUND_ROWS))]
	DO
		$AVRESULT[$IINDEX] = $ISTART
		$IINDEX += 1
		$ISTART = _ARRAYSEARCH($AARRAY, $VVALUE, $ISTART + 1, $IEND, $ICASE, $ICOMPARE, 1, $ISUBITEM, $BROW)
	UNTIL @ERROR
	REDIM $AVRESULT[$IINDEX]
	RETURN $AVRESULT
ENDFUNC
FUNC _ARRAYFROMSTRING($SARRAYSTR, $SDELIM_COL = "|", $SDELIM_ROW = @CRLF, $BFORCE2D = FALSE, $ISTRIPWS = $STR_STRIPLEADING + $STR_STRIPTRAILING)
	IF $SDELIM_COL = DEFAULT THEN $SDELIM_COL = "|"
	IF $SDELIM_ROW = DEFAULT THEN $SDELIM_ROW = @CRLF
	IF $BFORCE2D = DEFAULT THEN $BFORCE2D = FALSE
	IF $ISTRIPWS = DEFAULT THEN $ISTRIPWS = $STR_STRIPLEADING + $STR_STRIPTRAILING
	LOCAL $AROW, $ACOL = STRINGSPLIT($SARRAYSTR, $SDELIM_ROW, $STR_ENTIRESPLIT + $STR_NOCOUNT)
	$AROW = STRINGSPLIT($ACOL[0], $SDELIM_COL, $STR_ENTIRESPLIT + $STR_NOCOUNT)
	IF UBOUND($ACOL) = 1 AND NOT $BFORCE2D THEN
		FOR $M = 0 TO UBOUND($AROW) - 1
			$AROW[$M] = ($ISTRIPWS ? STRINGSTRIPWS($AROW[$M], $ISTRIPWS) : $AROW[$M])
		NEXT
		RETURN $AROW
	ENDIF
	LOCAL $ARET[UBOUND($ACOL)][UBOUND($AROW)]
	FOR $N = 0 TO UBOUND($ACOL) - 1
		$AROW = STRINGSPLIT($ACOL[$N], $SDELIM_COL, $STR_ENTIRESPLIT + $STR_NOCOUNT)
		IF UBOUND($AROW) > UBOUND($ARET, 2) THEN RETURN SETERROR(1)
		FOR $M = 0 TO UBOUND($AROW) - 1
			$ARET[$N][$M] = ($ISTRIPWS ? STRINGSTRIPWS($AROW[$M], $ISTRIPWS) : $AROW[$M])
		NEXT
	NEXT
	RETURN $ARET
ENDFUNC
FUNC _ARRAYINSERT(BYREF $AARRAY, $VRANGE, $VVALUE = "", $ISTART = 0, $SDELIM_ITEM = "|", $SDELIM_ROW = @CRLF, $IFORCE = $ARRAYFILL_FORCE_DEFAULT)
	IF $VVALUE = DEFAULT THEN $VVALUE = ""
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $SDELIM_ITEM = DEFAULT THEN $SDELIM_ITEM = "|"
	IF $SDELIM_ROW = DEFAULT THEN $SDELIM_ROW = @CRLF
	IF $IFORCE = DEFAULT THEN $IFORCE = $ARRAYFILL_FORCE_DEFAULT
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	LOCAL $HDATATYPE = 0
	SWITCH $IFORCE
		CASE $ARRAYFILL_FORCE_INT
			$HDATATYPE = INT
		CASE $ARRAYFILL_FORCE_NUMBER
			$HDATATYPE = NUMBER
		CASE $ARRAYFILL_FORCE_PTR
			$HDATATYPE = PTR
		CASE $ARRAYFILL_FORCE_HWND
			$HDATATYPE = HWND
		CASE $ARRAYFILL_FORCE_STRING
			$HDATATYPE = STRING
	ENDSWITCH
	LOCAL $ASPLIT_1, $ASPLIT_2
	IF ISARRAY($VRANGE) THEN
		IF UBOUND($VRANGE, $UBOUND_DIMENSIONS) <> 1 OR UBOUND($VRANGE, $UBOUND_ROWS) < 2 THEN RETURN SETERROR(4, 0, -1)
	ELSE
		LOCAL $INUMBER
		$VRANGE = STRINGSTRIPWS($VRANGE, 8)
		$ASPLIT_1 = STRINGSPLIT($VRANGE, ";")
		$VRANGE = ""
		FOR $I = 1 TO $ASPLIT_1[0]
			IF NOT STRINGREGEXP($ASPLIT_1[$I], "^\d+(-\d+)?$") THEN RETURN SETERROR(3, 0, -1)
			$ASPLIT_2 = STRINGSPLIT($ASPLIT_1[$I], "-")
			SWITCH $ASPLIT_2[0]
				CASE 1
					$VRANGE &= $ASPLIT_2[1] & ";"
				CASE 2
					IF NUMBER($ASPLIT_2[2]) >= NUMBER($ASPLIT_2[1]) THEN
						$INUMBER = $ASPLIT_2[1] - 1
						DO
							$INUMBER += 1
							$VRANGE &= $INUMBER & ";"
						UNTIL $INUMBER = $ASPLIT_2[2]
					ENDIF
			ENDSWITCH
		NEXT
		$VRANGE = STRINGSPLIT(STRINGTRIMRIGHT($VRANGE, 1), ";")
	ENDIF
	FOR $I = 1 TO $VRANGE[0]
		$VRANGE[$I] = NUMBER($VRANGE[$I])
	NEXT
	IF $VRANGE[1] < 0 OR $VRANGE[$VRANGE[0]] > $IDIM_1 THEN RETURN SETERROR(5, 0, -1)
	FOR $I = 2 TO $VRANGE[0]
		IF $VRANGE[$I] < $VRANGE[$I - 1] THEN RETURN SETERROR(3, 0, -1)
	NEXT
	LOCAL $ICOPYTO_INDEX = $IDIM_1 + $VRANGE[0]
	LOCAL $IINSERTPOINT_INDEX = $VRANGE[0]
	LOCAL $IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $IFORCE = $ARRAYFILL_FORCE_SINGLEITEM THEN
				REDIM $AARRAY[$IDIM_1 + $VRANGE[0] + 1]
				FOR $IREADFROMINDEX = $IDIM_1 TO 0 STEP -1
					$AARRAY[$ICOPYTO_INDEX] = $AARRAY[$IREADFROMINDEX]
					$ICOPYTO_INDEX -= 1
					$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
					WHILE $IREADFROMINDEX = $IINSERT_INDEX
						$AARRAY[$ICOPYTO_INDEX] = $VVALUE
						$ICOPYTO_INDEX -= 1
						$IINSERTPOINT_INDEX -= 1
						IF $IINSERTPOINT_INDEX < 1 THEN EXITLOOP 2
						$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
					WEND
				NEXT
				RETURN $IDIM_1 + $VRANGE[0] + 1
			ENDIF
			REDIM $AARRAY[$IDIM_1 + $VRANGE[0] + 1]
			IF ISARRAY($VVALUE) THEN
				IF UBOUND($VVALUE, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(5, 0, -1)
				$HDATATYPE = 0
			ELSE
				LOCAL $ATMP = STRINGSPLIT($VVALUE, $SDELIM_ITEM, $STR_NOCOUNT + $STR_ENTIRESPLIT)
				IF UBOUND($ATMP, $UBOUND_ROWS) = 1 THEN
					$ATMP[0] = $VVALUE
					$HDATATYPE = 0
				ENDIF
				$VVALUE = $ATMP
			ENDIF
			FOR $IREADFROMINDEX = $IDIM_1 TO 0 STEP -1
				$AARRAY[$ICOPYTO_INDEX] = $AARRAY[$IREADFROMINDEX]
				$ICOPYTO_INDEX -= 1
				$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
				WHILE $IREADFROMINDEX = $IINSERT_INDEX
					IF $IINSERTPOINT_INDEX <= UBOUND($VVALUE, $UBOUND_ROWS) THEN
						IF ISFUNC($HDATATYPE) THEN
							$AARRAY[$ICOPYTO_INDEX] = $HDATATYPE($VVALUE[$IINSERTPOINT_INDEX - 1])
						ELSE
							$AARRAY[$ICOPYTO_INDEX] = $VVALUE[$IINSERTPOINT_INDEX - 1]
						ENDIF
					ELSE
						$AARRAY[$ICOPYTO_INDEX] = ""
					ENDIF
					$ICOPYTO_INDEX -= 1
					$IINSERTPOINT_INDEX -= 1
					IF $IINSERTPOINT_INDEX = 0 THEN EXITLOOP 2
					$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
				WEND
			NEXT
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
			IF $ISTART < 0 OR $ISTART > $IDIM_2 - 1 THEN RETURN SETERROR(6, 0, -1)
			LOCAL $IVALDIM_1, $IVALDIM_2
			IF ISARRAY($VVALUE) THEN
				IF UBOUND($VVALUE, $UBOUND_DIMENSIONS) <> 2 THEN RETURN SETERROR(7, 0, -1)
				$IVALDIM_1 = UBOUND($VVALUE, $UBOUND_ROWS)
				$IVALDIM_2 = UBOUND($VVALUE, $UBOUND_COLUMNS)
				$HDATATYPE = 0
			ELSE
				$ASPLIT_1 = STRINGSPLIT($VVALUE, $SDELIM_ROW, $STR_NOCOUNT + $STR_ENTIRESPLIT)
				$IVALDIM_1 = UBOUND($ASPLIT_1, $UBOUND_ROWS)
				STRINGREPLACE($ASPLIT_1[0], $SDELIM_ITEM, "")
				$IVALDIM_2 = @EXTENDED + 1
				LOCAL $ATMP[$IVALDIM_1][$IVALDIM_2]
				FOR $I = 0 TO $IVALDIM_1 - 1
					$ASPLIT_2 = STRINGSPLIT($ASPLIT_1[$I], $SDELIM_ITEM, $STR_NOCOUNT + $STR_ENTIRESPLIT)
					FOR $J = 0 TO $IVALDIM_2 - 1
						$ATMP[$I][$J] = $ASPLIT_2[$J]
					NEXT
				NEXT
				$VVALUE = $ATMP
			ENDIF
			IF UBOUND($VVALUE, $UBOUND_COLUMNS) + $ISTART > UBOUND($AARRAY, $UBOUND_COLUMNS) THEN RETURN SETERROR(8, 0, -1)
			REDIM $AARRAY[$IDIM_1 + $VRANGE[0] + 1][$IDIM_2]
			FOR $IREADFROMINDEX = $IDIM_1 TO 0 STEP -1
				FOR $J = 0 TO $IDIM_2 - 1
					$AARRAY[$ICOPYTO_INDEX][$J] = $AARRAY[$IREADFROMINDEX][$J]
				NEXT
				$ICOPYTO_INDEX -= 1
				$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
				WHILE $IREADFROMINDEX = $IINSERT_INDEX
					FOR $J = 0 TO $IDIM_2 - 1
						IF $J < $ISTART THEN
							$AARRAY[$ICOPYTO_INDEX][$J] = ""
						ELSEIF $J - $ISTART > $IVALDIM_2 - 1 THEN
							$AARRAY[$ICOPYTO_INDEX][$J] = ""
						ELSE
							IF $IINSERTPOINT_INDEX - 1 < $IVALDIM_1 THEN
								IF ISFUNC($HDATATYPE) THEN
									$AARRAY[$ICOPYTO_INDEX][$J] = $HDATATYPE($VVALUE[$IINSERTPOINT_INDEX - 1][$J - $ISTART])
								ELSE
									$AARRAY[$ICOPYTO_INDEX][$J] = $VVALUE[$IINSERTPOINT_INDEX - 1][$J - $ISTART]
								ENDIF
							ELSE
								$AARRAY[$ICOPYTO_INDEX][$J] = ""
							ENDIF
						ENDIF
					NEXT
					$ICOPYTO_INDEX -= 1
					$IINSERTPOINT_INDEX -= 1
					IF $IINSERTPOINT_INDEX = 0 THEN EXITLOOP 2
					$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
				WEND
			NEXT
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_ROWS)
ENDFUNC
FUNC _ARRAYMAX(CONST BYREF $AARRAY, $ICOMPNUMERIC = 0, $ISTART = -1, $IEND = -1, $ISUBITEM = 0)
	LOCAL $IRESULT = _ARRAYMAXINDEX($AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, "")
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) = 1 THEN
		RETURN $AARRAY[$IRESULT]
	ELSE
		RETURN $AARRAY[$IRESULT][$ISUBITEM]
	ENDIF
ENDFUNC
FUNC _ARRAYMAXINDEX(CONST BYREF $AARRAY, $ICOMPNUMERIC = 0, $ISTART = -1, $IEND = -1, $ISUBITEM = 0)
	IF $ICOMPNUMERIC = DEFAULT THEN $ICOMPNUMERIC = 0
	IF $ISTART = DEFAULT THEN $ISTART = -1
	IF $IEND = DEFAULT THEN $IEND = -1
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	LOCAL $IRET = __ARRAY_MINMAXINDEX($AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM, __ARRAY_GREATERTHAN)
	RETURN SETERROR(@ERROR, 0, $IRET)
ENDFUNC
FUNC _ARRAYMIN(CONST BYREF $AARRAY, $ICOMPNUMERIC = 0, $ISTART = -1, $IEND = -1, $ISUBITEM = 0)
	LOCAL $IRESULT = _ARRAYMININDEX($AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, "")
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) = 1 THEN
		RETURN $AARRAY[$IRESULT]
	ELSE
		RETURN $AARRAY[$IRESULT][$ISUBITEM]
	ENDIF
ENDFUNC
FUNC _ARRAYMININDEX(CONST BYREF $AARRAY, $ICOMPNUMERIC = 0, $ISTART = -1, $IEND = -1, $ISUBITEM = 0)
	IF $ICOMPNUMERIC = DEFAULT THEN $ICOMPNUMERIC = 0
	IF $ISTART = DEFAULT THEN $ISTART = -1
	IF $IEND = DEFAULT THEN $IEND = -1
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	LOCAL $IRET = __ARRAY_MINMAXINDEX($AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM, __ARRAY_LESSTHAN)
	RETURN SETERROR(@ERROR, 0, $IRET)
ENDFUNC
FUNC _ARRAYPERMUTE(BYREF $AARRAY, $SDELIMITER = "")
	IF $SDELIMITER = DEFAULT THEN $SDELIMITER = ""
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(2, 0, 0)
	LOCAL $ISIZE = UBOUND($AARRAY), $IFACTORIAL = 1, $AIDX[$ISIZE], $ARESULT[1], $ICOUNT = 1
	IF UBOUND($AARRAY) THEN
		FOR $I = 0 TO $ISIZE - 1
			$AIDX[$I] = $I
		NEXT
		FOR $I = $ISIZE TO 1 STEP -1
			$IFACTORIAL *= $I
		NEXT
		REDIM $ARESULT[$IFACTORIAL + 1]
		$ARESULT[0] = $IFACTORIAL
		__ARRAY_EXETERINTERNAL($AARRAY, 0, $ISIZE, $SDELIMITER, $AIDX, $ARESULT, $ICOUNT)
	ELSE
		$ARESULT[0] = 0
	ENDIF
	RETURN $ARESULT
ENDFUNC
FUNC _ARRAYPOP(BYREF $AARRAY)
	IF(NOT ISARRAY($AARRAY)) THEN RETURN SETERROR(1, 0, "")
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(2, 0, "")
	LOCAL $IUBOUND = UBOUND($AARRAY) - 1
	IF $IUBOUND = -1 THEN RETURN SETERROR(3, 0, "")
	LOCAL $SLASTVAL = $AARRAY[$IUBOUND]
	IF $IUBOUND > -1 THEN
		REDIM $AARRAY[$IUBOUND]
	ENDIF
	RETURN $SLASTVAL
ENDFUNC
FUNC _ARRAYPUSH(BYREF $AARRAY, $VVALUE, $IDIRECTION = 0)
	IF $IDIRECTION = DEFAULT THEN $IDIRECTION = 0
	IF(NOT ISARRAY($AARRAY)) THEN RETURN SETERROR(1, 0, 0)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(3, 0, 0)
	LOCAL $IUBOUND = UBOUND($AARRAY) - 1
	IF ISARRAY($VVALUE) THEN
		LOCAL $IUBOUNDS = UBOUND($VVALUE)
		IF($IUBOUNDS - 1) > $IUBOUND THEN RETURN SETERROR(2, 0, 0)
		IF $IDIRECTION THEN
			FOR $I = $IUBOUND TO $IUBOUNDS STEP -1
				$AARRAY[$I] = $AARRAY[$I - $IUBOUNDS]
			NEXT
			FOR $I = 0 TO $IUBOUNDS - 1
				$AARRAY[$I] = $VVALUE[$I]
			NEXT
		ELSE
			FOR $I = 0 TO $IUBOUND - $IUBOUNDS
				$AARRAY[$I] = $AARRAY[$I + $IUBOUNDS]
			NEXT
			FOR $I = 0 TO $IUBOUNDS - 1
				$AARRAY[$I + $IUBOUND - $IUBOUNDS + 1] = $VVALUE[$I]
			NEXT
		ENDIF
	ELSE
		IF $IUBOUND > -1 THEN
			IF $IDIRECTION THEN
				FOR $I = $IUBOUND TO 1 STEP -1
					$AARRAY[$I] = $AARRAY[$I - 1]
				NEXT
				$AARRAY[0] = $VVALUE
			ELSE
				FOR $I = 0 TO $IUBOUND - 1
					$AARRAY[$I] = $AARRAY[$I + 1]
				NEXT
				$AARRAY[$IUBOUND] = $VVALUE
			ENDIF
		ENDIF
	ENDIF
	RETURN 1
ENDFUNC
FUNC _ARRAYREVERSE(BYREF $AARRAY, $ISTART = 0, $IEND = 0)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(3, 0, 0)
	IF NOT UBOUND($AARRAY) THEN RETURN SETERROR(4, 0, 0)
	LOCAL $VTMP, $IUBOUND = UBOUND($AARRAY) - 1
	IF $IEND < 1 OR $IEND > $IUBOUND THEN $IEND = $IUBOUND
	IF $ISTART < 0 THEN $ISTART = 0
	IF $ISTART > $IEND THEN RETURN SETERROR(2, 0, 0)
	FOR $I = $ISTART TO INT(($ISTART + $IEND - 1) / 2)
		$VTMP = $AARRAY[$I]
		$AARRAY[$I] = $AARRAY[$IEND]
		$AARRAY[$IEND] = $VTMP
		$IEND -= 1
	NEXT
	RETURN 1
ENDFUNC
FUNC _ARRAYSEARCH(CONST BYREF $AARRAY, $VVALUE, $ISTART = 0, $IEND = 0, $ICASE = 0, $ICOMPARE = 0, $IFORWARD = 1, $ISUBITEM = -1, $BROW = FALSE)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ICASE = DEFAULT THEN $ICASE = 0
	IF $ICOMPARE = DEFAULT THEN $ICOMPARE = 0
	IF $IFORWARD = DEFAULT THEN $IFORWARD = 1
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = -1
	IF $BROW = DEFAULT THEN $BROW = FALSE
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY) - 1
	IF $IDIM_1 = -1 THEN RETURN SETERROR(3, 0, -1)
	LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
	LOCAL $BCOMPTYPE = FALSE
	IF $ICOMPARE = 2 THEN
		$ICOMPARE = 0
		$BCOMPTYPE = TRUE
	ENDIF
	IF $BROW THEN
		IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) = 1 THEN RETURN SETERROR(5, 0, -1)
		IF $IEND < 1 OR $IEND > $IDIM_2 THEN $IEND = $IDIM_2
		IF $ISTART < 0 THEN $ISTART = 0
		IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	ELSE
		IF $IEND < 1 OR $IEND > $IDIM_1 THEN $IEND = $IDIM_1
		IF $ISTART < 0 THEN $ISTART = 0
		IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	ENDIF
	LOCAL $ISTEP = 1
	IF NOT $IFORWARD THEN
		LOCAL $ITMP = $ISTART
		$ISTART = $IEND
		$IEND = $ITMP
		$ISTEP = -1
	ENDIF
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF NOT $ICOMPARE THEN
				IF NOT $ICASE THEN
					FOR $I = $ISTART TO $IEND STEP $ISTEP
						IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$I]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
						IF $AARRAY[$I] = $VVALUE THEN RETURN $I
					NEXT
				ELSE
					FOR $I = $ISTART TO $IEND STEP $ISTEP
						IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$I]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
						IF $AARRAY[$I] == $VVALUE THEN RETURN $I
					NEXT
				ENDIF
			ELSE
				FOR $I = $ISTART TO $IEND STEP $ISTEP
					IF $ICOMPARE = 3 THEN
						IF STRINGREGEXP($AARRAY[$I], $VVALUE) THEN RETURN $I
					ELSE
						IF STRINGINSTR($AARRAY[$I], $VVALUE, $ICASE) > 0 THEN RETURN $I
					ENDIF
				NEXT
			ENDIF
		CASE 2
			LOCAL $IDIM_SUB
			IF $BROW THEN
				$IDIM_SUB = $IDIM_1
				IF $ISUBITEM > $IDIM_SUB THEN $ISUBITEM = $IDIM_SUB
				IF $ISUBITEM < 0 THEN
					$ISUBITEM = 0
				ELSE
					$IDIM_SUB = $ISUBITEM
				ENDIF
			ELSE
				$IDIM_SUB = $IDIM_2
				IF $ISUBITEM > $IDIM_SUB THEN $ISUBITEM = $IDIM_SUB
				IF $ISUBITEM < 0 THEN
					$ISUBITEM = 0
				ELSE
					$IDIM_SUB = $ISUBITEM
				ENDIF
			ENDIF
			FOR $J = $ISUBITEM TO $IDIM_SUB
				IF NOT $ICOMPARE THEN
					IF NOT $ICASE THEN
						FOR $I = $ISTART TO $IEND STEP $ISTEP
							IF $BROW THEN
								IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$J][$I]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
								IF $AARRAY[$J][$I] = $VVALUE THEN RETURN $I
							ELSE
								IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$I][$J]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
								IF $AARRAY[$I][$J] = $VVALUE THEN RETURN $I
							ENDIF
						NEXT
					ELSE
						FOR $I = $ISTART TO $IEND STEP $ISTEP
							IF $BROW THEN
								IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$J][$I]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
								IF $AARRAY[$J][$I] == $VVALUE THEN RETURN $I
							ELSE
								IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$I][$J]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
								IF $AARRAY[$I][$J] == $VVALUE THEN RETURN $I
							ENDIF
						NEXT
					ENDIF
				ELSE
					FOR $I = $ISTART TO $IEND STEP $ISTEP
						IF $ICOMPARE = 3 THEN
							IF $BROW THEN
								IF STRINGREGEXP($AARRAY[$J][$I], $VVALUE) THEN RETURN $I
							ELSE
								IF STRINGREGEXP($AARRAY[$I][$J], $VVALUE) THEN RETURN $I
							ENDIF
						ELSE
							IF $BROW THEN
								IF STRINGINSTR($AARRAY[$J][$I], $VVALUE, $ICASE) > 0 THEN RETURN $I
							ELSE
								IF STRINGINSTR($AARRAY[$I][$J], $VVALUE, $ICASE) > 0 THEN RETURN $I
							ENDIF
						ENDIF
					NEXT
				ENDIF
			NEXT
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN SETERROR(6, 0, -1)
ENDFUNC
FUNC _ARRAYSHUFFLE(BYREF $AARRAY, $ISTART_ROW = 0, $IEND_ROW = 0, $ICOL = -1)
	IF $ISTART_ROW = DEFAULT THEN $ISTART_ROW = 0
	IF $IEND_ROW = DEFAULT THEN $IEND_ROW = 0
	IF $ICOL = DEFAULT THEN $ICOL = -1
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	IF $IEND_ROW = 0 THEN $IEND_ROW = $IDIM_1 - 1
	IF $ISTART_ROW < 0 OR $ISTART_ROW > $IDIM_1 - 1 THEN RETURN SETERROR(3, 0, -1)
	IF $IEND_ROW < 1 OR $IEND_ROW > $IDIM_1 - 1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART_ROW > $IEND_ROW THEN RETURN SETERROR(4, 0, -1)
	LOCAL $VTMP, $IRAND
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			FOR $I = $IEND_ROW TO $ISTART_ROW + 1 STEP -1
				$IRAND = RANDOM($ISTART_ROW, $I, 1)
				$VTMP = $AARRAY[$I]
				$AARRAY[$I] = $AARRAY[$IRAND]
				$AARRAY[$IRAND] = $VTMP
			NEXT
			RETURN 1
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
			IF $ICOL < -1 OR $ICOL > $IDIM_2 - 1 THEN RETURN SETERROR(5, 0, -1)
			LOCAL $ICOL_START, $ICOL_END
			IF $ICOL = -1 THEN
				$ICOL_START = 0
				$ICOL_END = $IDIM_2 - 1
			ELSE
				$ICOL_START = $ICOL
				$ICOL_END = $ICOL
			ENDIF
			FOR $I = $IEND_ROW TO $ISTART_ROW + 1 STEP -1
				$IRAND = RANDOM($ISTART_ROW, $I, 1)
				FOR $J = $ICOL_START TO $ICOL_END
					$VTMP = $AARRAY[$I][$J]
					$AARRAY[$I][$J] = $AARRAY[$IRAND][$J]
					$AARRAY[$IRAND][$J] = $VTMP
				NEXT
			NEXT
			RETURN 1
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
ENDFUNC
FUNC _ARRAYSORT(BYREF $AARRAY, $IDESCENDING = 0, $ISTART = 0, $IEND = 0, $ISUBITEM = 0, $IPIVOT = 0)
	IF $IDESCENDING = DEFAULT THEN $IDESCENDING = 0
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	IF $IPIVOT = DEFAULT THEN $IPIVOT = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IUBOUND = UBOUND($AARRAY) - 1
	IF $IUBOUND = -1 THEN RETURN SETERROR(5, 0, 0)
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $IEND < 1 OR $IEND > $IUBOUND OR $IEND = DEFAULT THEN $IEND = $IUBOUND
	IF $ISTART < 0 OR $ISTART = DEFAULT THEN $ISTART = 0
	IF $ISTART > $IEND THEN RETURN SETERROR(2, 0, 0)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $IPIVOT THEN
				__ARRAYDUALPIVOTSORT($AARRAY, $ISTART, $IEND)
			ELSE
				__ARRAYQUICKSORT1D($AARRAY, $ISTART, $IEND)
			ENDIF
			IF $IDESCENDING THEN _ARRAYREVERSE($AARRAY, $ISTART, $IEND)
		CASE 2
			IF $IPIVOT THEN RETURN SETERROR(6, 0, 0)
			LOCAL $ISUBMAX = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $ISUBITEM > $ISUBMAX THEN RETURN SETERROR(3, 0, 0)
			IF $IDESCENDING THEN
				$IDESCENDING = -1
			ELSE
				$IDESCENDING = 1
			ENDIF
			__ARRAYQUICKSORT2D($AARRAY, $IDESCENDING, $ISTART, $IEND, $ISUBITEM, $ISUBMAX)
		CASE ELSE
			RETURN SETERROR(4, 0, 0)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC __ARRAYQUICKSORT1D(BYREF $AARRAY, CONST BYREF $ISTART, CONST BYREF $IEND)
	IF $IEND <= $ISTART THEN RETURN
	LOCAL $VTMP
	IF($IEND - $ISTART) < 15 THEN
		LOCAL $VCUR
		FOR $I = $ISTART + 1 TO $IEND
			$VTMP = $AARRAY[$I]
			IF ISNUMBER($VTMP) THEN
				FOR $J = $I - 1 TO $ISTART STEP -1
					$VCUR = $AARRAY[$J]
					IF($VTMP >= $VCUR AND ISNUMBER($VCUR)) OR(NOT ISNUMBER($VCUR) AND STRINGCOMPARE($VTMP, $VCUR) >= 0) THEN EXITLOOP
					$AARRAY[$J + 1] = $VCUR
				NEXT
			ELSE
				FOR $J = $I - 1 TO $ISTART STEP -1
					IF(STRINGCOMPARE($VTMP, $AARRAY[$J]) >= 0) THEN EXITLOOP
					$AARRAY[$J + 1] = $AARRAY[$J]
				NEXT
			ENDIF
			$AARRAY[$J + 1] = $VTMP
		NEXT
		RETURN
	ENDIF
	LOCAL $L = $ISTART, $R = $IEND, $VPIVOT = $AARRAY[INT(($ISTART + $IEND) / 2)], $BNUM = ISNUMBER($VPIVOT)
	DO
		IF $BNUM THEN
			WHILE($AARRAY[$L] < $VPIVOT AND ISNUMBER($AARRAY[$L])) OR(NOT ISNUMBER($AARRAY[$L]) AND STRINGCOMPARE($AARRAY[$L], $VPIVOT) < 0)
				$L += 1
			WEND
			WHILE($AARRAY[$R] > $VPIVOT AND ISNUMBER($AARRAY[$R])) OR(NOT ISNUMBER($AARRAY[$R]) AND STRINGCOMPARE($AARRAY[$R], $VPIVOT) > 0)
				$R -= 1
			WEND
		ELSE
			WHILE(STRINGCOMPARE($AARRAY[$L], $VPIVOT) < 0)
				$L += 1
			WEND
			WHILE(STRINGCOMPARE($AARRAY[$R], $VPIVOT) > 0)
				$R -= 1
			WEND
		ENDIF
		IF $L <= $R THEN
			$VTMP = $AARRAY[$L]
			$AARRAY[$L] = $AARRAY[$R]
			$AARRAY[$R] = $VTMP
			$L += 1
			$R -= 1
		ENDIF
	UNTIL $L > $R
	__ARRAYQUICKSORT1D($AARRAY, $ISTART, $R)
	__ARRAYQUICKSORT1D($AARRAY, $L, $IEND)
ENDFUNC
FUNC __ARRAYQUICKSORT2D(BYREF $AARRAY, CONST BYREF $ISTEP, CONST BYREF $ISTART, CONST BYREF $IEND, CONST BYREF $ISUBITEM, CONST BYREF $ISUBMAX)
	IF $IEND <= $ISTART THEN RETURN
	LOCAL $VTMP, $L = $ISTART, $R = $IEND, $VPIVOT = $AARRAY[INT(($ISTART + $IEND) / 2)][$ISUBITEM], $BNUM = ISNUMBER($VPIVOT)
	DO
		IF $BNUM THEN
			WHILE($ISTEP * ($AARRAY[$L][$ISUBITEM] - $VPIVOT) < 0 AND ISNUMBER($AARRAY[$L][$ISUBITEM])) OR(NOT ISNUMBER($AARRAY[$L][$ISUBITEM]) AND $ISTEP * STRINGCOMPARE($AARRAY[$L][$ISUBITEM], $VPIVOT) < 0)
				$L += 1
			WEND
			WHILE($ISTEP * ($AARRAY[$R][$ISUBITEM] - $VPIVOT) > 0 AND ISNUMBER($AARRAY[$R][$ISUBITEM])) OR(NOT ISNUMBER($AARRAY[$R][$ISUBITEM]) AND $ISTEP * STRINGCOMPARE($AARRAY[$R][$ISUBITEM], $VPIVOT) > 0)
				$R -= 1
			WEND
		ELSE
			WHILE($ISTEP * STRINGCOMPARE($AARRAY[$L][$ISUBITEM], $VPIVOT) < 0)
				$L += 1
			WEND
			WHILE($ISTEP * STRINGCOMPARE($AARRAY[$R][$ISUBITEM], $VPIVOT) > 0)
				$R -= 1
			WEND
		ENDIF
		IF $L <= $R THEN
			FOR $I = 0 TO $ISUBMAX
				$VTMP = $AARRAY[$L][$I]
				$AARRAY[$L][$I] = $AARRAY[$R][$I]
				$AARRAY[$R][$I] = $VTMP
			NEXT
			$L += 1
			$R -= 1
		ENDIF
	UNTIL $L > $R
	__ARRAYQUICKSORT2D($AARRAY, $ISTEP, $ISTART, $R, $ISUBITEM, $ISUBMAX)
	__ARRAYQUICKSORT2D($AARRAY, $ISTEP, $L, $IEND, $ISUBITEM, $ISUBMAX)
ENDFUNC
FUNC __ARRAYDUALPIVOTSORT(BYREF $AARRAY, $IPIVOT_LEFT, $IPIVOT_RIGHT, $BLEFTMOST = TRUE)
	IF $IPIVOT_LEFT > $IPIVOT_RIGHT THEN RETURN
	LOCAL $ILENGTH = $IPIVOT_RIGHT - $IPIVOT_LEFT + 1
	LOCAL $I, $J, $K, $IAI, $IAK, $IA1, $IA2, $ILAST
	IF $ILENGTH < 45 THEN
		IF $BLEFTMOST THEN
			$I = $IPIVOT_LEFT
			WHILE $I < $IPIVOT_RIGHT
				$J = $I
				$IAI = $AARRAY[$I + 1]
				WHILE $IAI < $AARRAY[$J]
					$AARRAY[$J + 1] = $AARRAY[$J]
					$J -= 1
					IF $J + 1 = $IPIVOT_LEFT THEN EXITLOOP
				WEND
				$AARRAY[$J + 1] = $IAI
				$I += 1
			WEND
		ELSE
			WHILE 1
				IF $IPIVOT_LEFT >= $IPIVOT_RIGHT THEN RETURN 1
				$IPIVOT_LEFT += 1
				IF $AARRAY[$IPIVOT_LEFT] < $AARRAY[$IPIVOT_LEFT - 1] THEN EXITLOOP
			WEND
			WHILE 1
				$K = $IPIVOT_LEFT
				$IPIVOT_LEFT += 1
				IF $IPIVOT_LEFT > $IPIVOT_RIGHT THEN EXITLOOP
				$IA1 = $AARRAY[$K]
				$IA2 = $AARRAY[$IPIVOT_LEFT]
				IF $IA1 < $IA2 THEN
					$IA2 = $IA1
					$IA1 = $AARRAY[$IPIVOT_LEFT]
				ENDIF
				$K -= 1
				WHILE $IA1 < $AARRAY[$K]
					$AARRAY[$K + 2] = $AARRAY[$K]
					$K -= 1
				WEND
				$AARRAY[$K + 2] = $IA1
				WHILE $IA2 < $AARRAY[$K]
					$AARRAY[$K + 1] = $AARRAY[$K]
					$K -= 1
				WEND
				$AARRAY[$K + 1] = $IA2
				$IPIVOT_LEFT += 1
			WEND
			$ILAST = $AARRAY[$IPIVOT_RIGHT]
			$IPIVOT_RIGHT -= 1
			WHILE $ILAST < $AARRAY[$IPIVOT_RIGHT]
				$AARRAY[$IPIVOT_RIGHT + 1] = $AARRAY[$IPIVOT_RIGHT]
				$IPIVOT_RIGHT -= 1
			WEND
			$AARRAY[$IPIVOT_RIGHT + 1] = $ILAST
		ENDIF
		RETURN 1
	ENDIF
	LOCAL $ISEVENTH = BITSHIFT($ILENGTH, 3) + BITSHIFT($ILENGTH, 6) + 1
	LOCAL $IE1, $IE2, $IE3, $IE4, $IE5, $T
	$IE3 = CEILING(($IPIVOT_LEFT + $IPIVOT_RIGHT) / 2)
	$IE2 = $IE3 - $ISEVENTH
	$IE1 = $IE2 - $ISEVENTH
	$IE4 = $IE3 + $ISEVENTH
	$IE5 = $IE4 + $ISEVENTH
	IF $AARRAY[$IE2] < $AARRAY[$IE1] THEN
		$T = $AARRAY[$IE2]
		$AARRAY[$IE2] = $AARRAY[$IE1]
		$AARRAY[$IE1] = $T
	ENDIF
	IF $AARRAY[$IE3] < $AARRAY[$IE2] THEN
		$T = $AARRAY[$IE3]
		$AARRAY[$IE3] = $AARRAY[$IE2]
		$AARRAY[$IE2] = $T
		IF $T < $AARRAY[$IE1] THEN
			$AARRAY[$IE2] = $AARRAY[$IE1]
			$AARRAY[$IE1] = $T
		ENDIF
	ENDIF
	IF $AARRAY[$IE4] < $AARRAY[$IE3] THEN
		$T = $AARRAY[$IE4]
		$AARRAY[$IE4] = $AARRAY[$IE3]
		$AARRAY[$IE3] = $T
		IF $T < $AARRAY[$IE2] THEN
			$AARRAY[$IE3] = $AARRAY[$IE2]
			$AARRAY[$IE2] = $T
			IF $T < $AARRAY[$IE1] THEN
				$AARRAY[$IE2] = $AARRAY[$IE1]
				$AARRAY[$IE1] = $T
			ENDIF
		ENDIF
	ENDIF
	IF $AARRAY[$IE5] < $AARRAY[$IE4] THEN
		$T = $AARRAY[$IE5]
		$AARRAY[$IE5] = $AARRAY[$IE4]
		$AARRAY[$IE4] = $T
		IF $T < $AARRAY[$IE3] THEN
			$AARRAY[$IE4] = $AARRAY[$IE3]
			$AARRAY[$IE3] = $T
			IF $T < $AARRAY[$IE2] THEN
				$AARRAY[$IE3] = $AARRAY[$IE2]
				$AARRAY[$IE2] = $T
				IF $T < $AARRAY[$IE1] THEN
					$AARRAY[$IE2] = $AARRAY[$IE1]
					$AARRAY[$IE1] = $T
				ENDIF
			ENDIF
		ENDIF
	ENDIF
	LOCAL $ILESS = $IPIVOT_LEFT
	LOCAL $IGREATER = $IPIVOT_RIGHT
	IF(($AARRAY[$IE1] <> $AARRAY[$IE2]) AND($AARRAY[$IE2] <> $AARRAY[$IE3]) AND($AARRAY[$IE3] <> $AARRAY[$IE4]) AND($AARRAY[$IE4] <> $AARRAY[$IE5])) THEN
		LOCAL $IPIVOT_1 = $AARRAY[$IE2]
		LOCAL $IPIVOT_2 = $AARRAY[$IE4]
		$AARRAY[$IE2] = $AARRAY[$IPIVOT_LEFT]
		$AARRAY[$IE4] = $AARRAY[$IPIVOT_RIGHT]
		DO
			$ILESS += 1
		UNTIL $AARRAY[$ILESS] >= $IPIVOT_1
		DO
			$IGREATER -= 1
		UNTIL $AARRAY[$IGREATER] <= $IPIVOT_2
		$K = $ILESS
		WHILE $K <= $IGREATER
			$IAK = $AARRAY[$K]
			IF $IAK < $IPIVOT_1 THEN
				$AARRAY[$K] = $AARRAY[$ILESS]
				$AARRAY[$ILESS] = $IAK
				$ILESS += 1
			ELSEIF $IAK > $IPIVOT_2 THEN
				WHILE $AARRAY[$IGREATER] > $IPIVOT_2
					$IGREATER -= 1
					IF $IGREATER + 1 = $K THEN EXITLOOP 2
				WEND
				IF $AARRAY[$IGREATER] < $IPIVOT_1 THEN
					$AARRAY[$K] = $AARRAY[$ILESS]
					$AARRAY[$ILESS] = $AARRAY[$IGREATER]
					$ILESS += 1
				ELSE
					$AARRAY[$K] = $AARRAY[$IGREATER]
				ENDIF
				$AARRAY[$IGREATER] = $IAK
				$IGREATER -= 1
			ENDIF
			$K += 1
		WEND
		$AARRAY[$IPIVOT_LEFT] = $AARRAY[$ILESS - 1]
		$AARRAY[$ILESS - 1] = $IPIVOT_1
		$AARRAY[$IPIVOT_RIGHT] = $AARRAY[$IGREATER + 1]
		$AARRAY[$IGREATER + 1] = $IPIVOT_2
		__ARRAYDUALPIVOTSORT($AARRAY, $IPIVOT_LEFT, $ILESS - 2, TRUE)
		__ARRAYDUALPIVOTSORT($AARRAY, $IGREATER + 2, $IPIVOT_RIGHT, FALSE)
		IF($ILESS < $IE1) AND($IE5 < $IGREATER) THEN
			WHILE $AARRAY[$ILESS] = $IPIVOT_1
				$ILESS += 1
			WEND
			WHILE $AARRAY[$IGREATER] = $IPIVOT_2
				$IGREATER -= 1
			WEND
			$K = $ILESS
			WHILE $K <= $IGREATER
				$IAK = $AARRAY[$K]
				IF $IAK = $IPIVOT_1 THEN
					$AARRAY[$K] = $AARRAY[$ILESS]
					$AARRAY[$ILESS] = $IAK
					$ILESS += 1
				ELSEIF $IAK = $IPIVOT_2 THEN
					WHILE $AARRAY[$IGREATER] = $IPIVOT_2
						$IGREATER -= 1
						IF $IGREATER + 1 = $K THEN EXITLOOP 2
					WEND
					IF $AARRAY[$IGREATER] = $IPIVOT_1 THEN
						$AARRAY[$K] = $AARRAY[$ILESS]
						$AARRAY[$ILESS] = $IPIVOT_1
						$ILESS += 1
					ELSE
						$AARRAY[$K] = $AARRAY[$IGREATER]
					ENDIF
					$AARRAY[$IGREATER] = $IAK
					$IGREATER -= 1
				ENDIF
				$K += 1
			WEND
		ENDIF
		__ARRAYDUALPIVOTSORT($AARRAY, $ILESS, $IGREATER, FALSE)
	ELSE
		LOCAL $IPIVOT = $AARRAY[$IE3]
		$K = $ILESS
		WHILE $K <= $IGREATER
			IF $AARRAY[$K] = $IPIVOT THEN
				$K += 1
				CONTINUELOOP
			ENDIF
			$IAK = $AARRAY[$K]
			IF $IAK < $IPIVOT THEN
				$AARRAY[$K] = $AARRAY[$ILESS]
				$AARRAY[$ILESS] = $IAK
				$ILESS += 1
			ELSE
				WHILE $AARRAY[$IGREATER] > $IPIVOT
					$IGREATER -= 1
				WEND
				IF $AARRAY[$IGREATER] < $IPIVOT THEN
					$AARRAY[$K] = $AARRAY[$ILESS]
					$AARRAY[$ILESS] = $AARRAY[$IGREATER]
					$ILESS += 1
				ELSE
					$AARRAY[$K] = $IPIVOT
				ENDIF
				$AARRAY[$IGREATER] = $IAK
				$IGREATER -= 1
			ENDIF
			$K += 1
		WEND
		__ARRAYDUALPIVOTSORT($AARRAY, $IPIVOT_LEFT, $ILESS - 1, TRUE)
		__ARRAYDUALPIVOTSORT($AARRAY, $IGREATER + 1, $IPIVOT_RIGHT, FALSE)
	ENDIF
ENDFUNC
FUNC _ARRAYSWAP(BYREF $AARRAY, $IINDEX_1, $IINDEX_2, $BCOL = FALSE, $ISTART = -1, $IEND = -1)
	IF $BCOL = DEFAULT THEN $BCOL = FALSE
	IF $ISTART = DEFAULT THEN $ISTART = -1
	IF $IEND = DEFAULT THEN $IEND = -1
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
	IF $IDIM_2 = -1 THEN
		$BCOL = FALSE
		$ISTART = -1
		$IEND = -1
	ENDIF
	IF $ISTART > $IEND THEN RETURN SETERROR(5, 0, -1)
	IF $BCOL THEN
		IF $IINDEX_1 < 0 OR $IINDEX_2 > $IDIM_2 THEN RETURN SETERROR(3, 0, -1)
		IF $ISTART = -1 THEN $ISTART = 0
		IF $IEND = -1 THEN $IEND = $IDIM_1
	ELSE
		IF $IINDEX_1 < 0 OR $IINDEX_2 > $IDIM_1 THEN RETURN SETERROR(3, 0, -1)
		IF $ISTART = -1 THEN $ISTART = 0
		IF $IEND = -1 THEN $IEND = $IDIM_2
	ENDIF
	LOCAL $VTMP
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			$VTMP = $AARRAY[$IINDEX_1]
			$AARRAY[$IINDEX_1] = $AARRAY[$IINDEX_2]
			$AARRAY[$IINDEX_2] = $VTMP
		CASE 2
			IF $ISTART < -1 OR $IEND < -1 THEN RETURN SETERROR(4, 0, -1)
			IF $BCOL THEN
				IF $ISTART > $IDIM_1 OR $IEND > $IDIM_1 THEN RETURN SETERROR(4, 0, -1)
				FOR $J = $ISTART TO $IEND
					$VTMP = $AARRAY[$J][$IINDEX_1]
					$AARRAY[$J][$IINDEX_1] = $AARRAY[$J][$IINDEX_2]
					$AARRAY[$J][$IINDEX_2] = $VTMP
				NEXT
			ELSE
				IF $ISTART > $IDIM_2 OR $IEND > $IDIM_2 THEN RETURN SETERROR(4, 0, -1)
				FOR $J = $ISTART TO $IEND
					$VTMP = $AARRAY[$IINDEX_1][$J]
					$AARRAY[$IINDEX_1][$J] = $AARRAY[$IINDEX_2][$J]
					$AARRAY[$IINDEX_2][$J] = $VTMP
				NEXT
			ENDIF
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYTOCLIP(CONST BYREF $AARRAY, $SDELIM_COL = "|", $ISTART_ROW = -1, $IEND_ROW = -1, $SDELIM_ROW = @CRLF, $ISTART_COL = -1, $IEND_COL = -1)
	LOCAL $SRESULT = _ARRAYTOSTRING($AARRAY, $SDELIM_COL, $ISTART_ROW, $IEND_ROW, $SDELIM_ROW, $ISTART_COL, $IEND_COL)
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, 0)
	IF CLIPPUT($SRESULT) THEN RETURN 1
	RETURN SETERROR(-1, 0, 0)
ENDFUNC
FUNC _ARRAYTOSTRING(CONST BYREF $AARRAY, $SDELIM_COL = "|", $ISTART_ROW = DEFAULT, $IEND_ROW = DEFAULT, $SDELIM_ROW = @CRLF, $ISTART_COL = DEFAULT, $IEND_COL = DEFAULT)
	IF $SDELIM_COL = DEFAULT THEN $SDELIM_COL = "|"
	IF $SDELIM_ROW = DEFAULT THEN $SDELIM_ROW = @CRLF
	IF $ISTART_ROW = DEFAULT THEN $ISTART_ROW = -1
	IF $IEND_ROW = DEFAULT THEN $IEND_ROW = -1
	IF $ISTART_COL = DEFAULT THEN $ISTART_COL = -1
	IF $IEND_COL = DEFAULT THEN $IEND_COL = -1
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF $IDIM_1 = -1 THEN RETURN ""
	IF $ISTART_ROW = -1 THEN $ISTART_ROW = 0
	IF $IEND_ROW = -1 THEN $IEND_ROW = $IDIM_1
	IF $ISTART_ROW < -1 OR $IEND_ROW < -1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART_ROW > $IDIM_1 OR $IEND_ROW > $IDIM_1 THEN RETURN SETERROR(3, 0, "")
	IF $ISTART_ROW > $IEND_ROW THEN RETURN SETERROR(4, 0, -1)
	LOCAL $SRET = ""
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			FOR $I = $ISTART_ROW TO $IEND_ROW
				$SRET &= $AARRAY[$I] & $SDELIM_COL
			NEXT
			RETURN STRINGTRIMRIGHT($SRET, STRINGLEN($SDELIM_COL))
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $IDIM_2 = -1 THEN RETURN ""
			IF $ISTART_COL = -1 THEN $ISTART_COL = 0
			IF $IEND_COL = -1 THEN $IEND_COL = $IDIM_2
			IF $ISTART_COL < -1 OR $IEND_COL < -1 THEN RETURN SETERROR(5, 0, -1)
			IF $ISTART_COL > $IDIM_2 OR $IEND_COL > $IDIM_2 THEN RETURN SETERROR(5, 0, -1)
			IF $ISTART_COL > $IEND_COL THEN RETURN SETERROR(6, 0, -1)
			LOCAL $IDELIMCOLLEN = STRINGLEN($SDELIM_COL)
			FOR $I = $ISTART_ROW TO $IEND_ROW
				FOR $J = $ISTART_COL TO $IEND_COL
					$SRET &= $AARRAY[$I][$J] & $SDELIM_COL
				NEXT
				$SRET = STRINGTRIMRIGHT($SRET, $IDELIMCOLLEN) & $SDELIM_ROW
			NEXT
			RETURN STRINGTRIMRIGHT($SRET, STRINGLEN($SDELIM_ROW))
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYTRANSPOSE(BYREF $AARRAY, $BFORCE1D = FALSE)
	LOCAL $ATEMP
	SWITCH $BFORCE1D
		CASE DEFAULT
			$BFORCE1D = FALSE
		CASE TRUE, FALSE
		CASE ELSE
			RETURN SETERROR(3, 0, 0)
	ENDSWITCH
	SWITCH UBOUND($AARRAY, 0)
		CASE 0
			RETURN SETERROR(2, 0, 0)
		CASE 1
			LOCAL $ATEMP[1][UBOUND($AARRAY)]
			FOR $I = 0 TO UBOUND($AARRAY) - 1
				$ATEMP[0][$I] = $AARRAY[$I]
			NEXT
			$AARRAY = $ATEMP
		CASE 2
			LOCAL $IDIM_1 = UBOUND($AARRAY, 1), $IDIM_2 = UBOUND($AARRAY, 2)
			IF $IDIM_1 <> $IDIM_2 THEN
				LOCAL $ATEMP[$IDIM_2][$IDIM_1]
				FOR $I = 0 TO $IDIM_1 - 1
					FOR $J = 0 TO $IDIM_2 - 1
						$ATEMP[$J][$I] = $AARRAY[$I][$J]
					NEXT
				NEXT
				$AARRAY = $ATEMP
			ELSE
				LOCAL $VELEMENT
				FOR $I = 0 TO $IDIM_1 - 1
					FOR $J = $I + 1 TO $IDIM_2 - 1
						$VELEMENT = $AARRAY[$I][$J]
						$AARRAY[$I][$J] = $AARRAY[$J][$I]
						$AARRAY[$J][$I] = $VELEMENT
					NEXT
				NEXT
			ENDIF
			IF $BFORCE1D = TRUE AND UBOUND($AARRAY, 2) = 1 THEN
				$ATEMP = $AARRAY
				REDIM $AARRAY[UBOUND($ATEMP)]
				FOR $I = 0 TO UBOUND($ATEMP) - 1
					$AARRAY[$I] = $ATEMP[$I][0]
				NEXT
			ENDIF
		CASE ELSE
			RETURN SETERROR(1, 0, 0)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYTRIM(BYREF $AARRAY, $ITRIMNUM, $IDIRECTION = 0, $ISTART = 0, $IEND = 0, $ISUBITEM = 0)
	IF $IDIRECTION = DEFAULT THEN $IDIRECTION = 0
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF $IEND = 0 THEN $IEND = $IDIM_1
	IF $ISTART > $IEND THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART < 0 OR $IEND < 0 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART > $IDIM_1 OR $IEND > $IDIM_1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $IDIRECTION THEN
				FOR $I = $ISTART TO $IEND
					$AARRAY[$I] = STRINGTRIMRIGHT($AARRAY[$I], $ITRIMNUM)
				NEXT
			ELSE
				FOR $I = $ISTART TO $IEND
					$AARRAY[$I] = STRINGTRIMLEFT($AARRAY[$I], $ITRIMNUM)
				NEXT
			ENDIF
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $ISUBITEM < 0 OR $ISUBITEM > $IDIM_2 THEN RETURN SETERROR(5, 0, -1)
			IF $IDIRECTION THEN
				FOR $I = $ISTART TO $IEND
					$AARRAY[$I][$ISUBITEM] = STRINGTRIMRIGHT($AARRAY[$I][$ISUBITEM], $ITRIMNUM)
				NEXT
			ELSE
				FOR $I = $ISTART TO $IEND
					$AARRAY[$I][$ISUBITEM] = STRINGTRIMLEFT($AARRAY[$I][$ISUBITEM], $ITRIMNUM)
				NEXT
			ENDIF
		CASE ELSE
			RETURN SETERROR(2, 0, 0)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYUNIQUE(CONST BYREF $AARRAY, $ICOLUMN = 0, $IBASE = 0, $ICASE = 0, $ICOUNT = $ARRAYUNIQUE_COUNT, $IINTTYPE = $ARRAYUNIQUE_AUTO)
	IF $ICOLUMN = DEFAULT THEN $ICOLUMN = 0
	IF $IBASE = DEFAULT THEN $IBASE = 0
	IF $ICASE = DEFAULT THEN $ICASE = 0
	IF $ICOUNT = DEFAULT THEN $ICOUNT = $ARRAYUNIQUE_COUNT
	IF $IINTTYPE = DEFAULT THEN $IINTTYPE = $ARRAYUNIQUE_AUTO
	IF UBOUND($AARRAY, $UBOUND_ROWS) = 0 THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IDIMS = UBOUND($AARRAY, $UBOUND_DIMENSIONS), $INUMCOLUMNS = UBOUND($AARRAY, $UBOUND_COLUMNS)
	IF $IDIMS > 2 THEN RETURN SETERROR(2, 0, 0)
	IF $IBASE < 0 OR $IBASE > 1 OR(NOT ISINT($IBASE)) THEN RETURN SETERROR(3, 0, 0)
	IF $ICASE < 0 OR $ICASE > 1 OR(NOT ISINT($ICASE)) THEN RETURN SETERROR(3, 0, 0)
	IF $ICOUNT < 0 OR $ICOUNT > 1 OR(NOT ISINT($ICOUNT)) THEN RETURN SETERROR(4, 0, 0)
	IF $IINTTYPE < 0 OR $IINTTYPE > 4 OR(NOT ISINT($IINTTYPE)) THEN RETURN SETERROR(5, 0, 0)
	IF $ICOLUMN < 0 OR($INUMCOLUMNS = 0 AND $ICOLUMN > 0) OR($INUMCOLUMNS > 0 AND $ICOLUMN >= $INUMCOLUMNS) THEN RETURN SETERROR(6, 0, 0)
	IF $IINTTYPE = $ARRAYUNIQUE_AUTO THEN
		LOCAL $BINT, $SVARTYPE
		IF $IDIMS = 1 THEN
			$BINT = ISINT($AARRAY[$IBASE])
			$SVARTYPE = VARGETTYPE($AARRAY[$IBASE])
		ELSE
			$BINT = ISINT($AARRAY[$IBASE][$ICOLUMN])
			$SVARTYPE = VARGETTYPE($AARRAY[$IBASE][$ICOLUMN])
		ENDIF
		IF $BINT AND $SVARTYPE = "Int64" THEN
			$IINTTYPE = $ARRAYUNIQUE_FORCE64
		ELSE
			$IINTTYPE = $ARRAYUNIQUE_FORCE32
		ENDIF
	ENDIF
	OBJEVENT("AutoIt.Error", __ARRAYUNIQUE_AUTOERRFUNC)
	LOCAL $ODICTIONARY = OBJCREATE("Scripting.Dictionary")
	$ODICTIONARY.CompareMode = NUMBER(NOT $ICASE)
	LOCAL $VELEM, $STYPE, $VKEY, $BCOMERROR = FALSE
	FOR $I = $IBASE TO UBOUND($AARRAY) - 1
		IF $IDIMS = 1 THEN
			$VELEM = $AARRAY[$I]
		ELSE
			$VELEM = $AARRAY[$I][$ICOLUMN]
		ENDIF
		SWITCH $IINTTYPE
			CASE $ARRAYUNIQUE_FORCE32
				$ODICTIONARY.Item($VELEM)
				IF @ERROR THEN
					$BCOMERROR = TRUE
					EXITLOOP
				ENDIF
			CASE $ARRAYUNIQUE_FORCE64
				$STYPE = VARGETTYPE($VELEM)
				IF $STYPE = "Int32" THEN
					$BCOMERROR = TRUE
					EXITLOOP
				ENDIF
				$VKEY = "#" & $STYPE & "#" & STRING($VELEM)
				IF NOT $ODICTIONARY.Item($VKEY) THEN
					$ODICTIONARY($VKEY) = $VELEM
				ENDIF
			CASE $ARRAYUNIQUE_MATCH
				$STYPE = VARGETTYPE($VELEM)
				IF STRINGLEFT($STYPE, 3) = "Int" THEN
					$VKEY = "#Int#" & STRING($VELEM)
				ELSE
					$VKEY = "#" & $STYPE & "#" & STRING($VELEM)
				ENDIF
				IF NOT $ODICTIONARY.Item($VKEY) THEN
					$ODICTIONARY($VKEY) = $VELEM
				ENDIF
			CASE $ARRAYUNIQUE_DISTINCT
				$VKEY = "#" & VARGETTYPE($VELEM) & "#" & STRING($VELEM)
				IF NOT $ODICTIONARY.Item($VKEY) THEN
					$ODICTIONARY($VKEY) = $VELEM
				ENDIF
		ENDSWITCH
	NEXT
	LOCAL $AVALUES, $J = 0
	IF $BCOMERROR THEN
		RETURN SETERROR(7, 0, 0)
	ELSEIF $IINTTYPE <> $ARRAYUNIQUE_FORCE32 THEN
		LOCAL $AVALUES[$ODICTIONARY.Count]
		FOR $VKEY IN $ODICTIONARY.Keys()
			$AVALUES[$J] = $ODICTIONARY($VKEY)
			IF STRINGLEFT($VKEY, 5) = "#Ptr#" THEN
				$AVALUES[$J] = PTR($AVALUES[$J])
			ENDIF
			$J += 1
		NEXT
	ELSE
		$AVALUES = $ODICTIONARY.Keys()
	ENDIF
	IF $ICOUNT THEN
		_ARRAYINSERT($AVALUES, 0, $ODICTIONARY.Count)
	ENDIF
	RETURN $AVALUES
ENDFUNC
FUNC _ARRAY1DTOHISTOGRAM($AARRAY, $ISIZING = 100)
	IF UBOUND($AARRAY, 0) > 1 THEN RETURN SETERROR(1, 0, "")
	$ISIZING = $ISIZING * 8
	LOCAL $T, $N, $IMIN = 0, $IMAX = 0, $IOFFSET = 0
	FOR $I = 0 TO UBOUND($AARRAY) - 1
		$T = $AARRAY[$I]
		$T = ISNUMBER($T) ? ROUND($T) : 0
		IF $T < $IMIN THEN $IMIN = $T
		IF $T > $IMAX THEN $IMAX = $T
	NEXT
	LOCAL $IRANGE = INT(ROUND(($IMAX - $IMIN) / 8)) * 8
	LOCAL $ISPACERATIO = 4
	FOR $I = 0 TO UBOUND($AARRAY) - 1
		$T = $AARRAY[$I]
		IF $T THEN
			$N = ABS(ROUND(($ISIZING * $T) / $IRANGE) / 8)
			$AARRAY[$I] = ""
			IF $T > 0 THEN
				IF $IMIN THEN
					$IOFFSET = INT(ABS(ROUND(($ISIZING * $IMIN) / $IRANGE) / 8) / 8 * $ISPACERATIO)
					$AARRAY[$I] = __ARRAY_STRINGREPEAT(CHRW(32), $IOFFSET)
				ENDIF
			ELSE
				IF $IMIN <> $T THEN
					$IOFFSET = INT(ABS(ROUND(($ISIZING * ($T - $IMIN)) / $IRANGE) / 8) / 8 * $ISPACERATIO)
					$AARRAY[$I] = __ARRAY_STRINGREPEAT(CHRW(32), $IOFFSET)
				ENDIF
			ENDIF
			$AARRAY[$I] &= __ARRAY_STRINGREPEAT(CHRW(9608), INT($N / 8))
			$N = MOD($N, 8)
			IF $N > 0 THEN $AARRAY[$I] &= CHRW(9608 + 8 - $N)
			$AARRAY[$I] &= " " & $T
		ELSE
			$AARRAY[$I] = ""
		ENDIF
	NEXT
	RETURN $AARRAY
ENDFUNC
FUNC _ARRAY2DCREATE($ACOL0, $ACOL1)
	IF(UBOUND($ACOL0, 0) <> 1) OR(UBOUND($ACOL1, 0) <> 1) THEN RETURN SETERROR(1, 0, "")
	LOCAL $NROWS = UBOUND($ACOL0)
	IF $NROWS <> UBOUND($ACOL1) THEN RETURN SETERROR(2, 0, "")
	LOCAL $ATMP[$NROWS][2]
	FOR $I = 0 TO $NROWS - 1
		$ATMP[$I][0] = $ACOL0[$I]
		$ATMP[$I][1] = $ACOL1[$I]
	NEXT
	RETURN $ATMP
ENDFUNC
FUNC __ARRAY_STRINGREPEAT($SSTRING, $IREPEATCOUNT)
	$IREPEATCOUNT = INT($IREPEATCOUNT)
	IF STRINGLEN($SSTRING) < 1 OR $IREPEATCOUNT <= 0 THEN RETURN SETERROR(1, 0, "")
	LOCAL $SRESULT = ""
	WHILE $IREPEATCOUNT > 1
		IF BITAND($IREPEATCOUNT, 1) THEN $SRESULT &= $SSTRING
		$SSTRING &= $SSTRING
		$IREPEATCOUNT = BITSHIFT($IREPEATCOUNT, 1)
	WEND
	RETURN $SSTRING & $SRESULT
ENDFUNC
FUNC __ARRAY_EXETERINTERNAL(BYREF $AARRAY, $ISTART, $ISIZE, $SDELIMITER, BYREF $AIDX, BYREF $ARESULT, BYREF $ICOUNT)
	IF $ISTART == $ISIZE - 1 THEN
		FOR $I = 0 TO $ISIZE - 1
			$ARESULT[$ICOUNT] &= $AARRAY[$AIDX[$I]] & $SDELIMITER
		NEXT
		IF $SDELIMITER <> "" THEN $ARESULT[$ICOUNT] = STRINGTRIMRIGHT($ARESULT[$ICOUNT], STRINGLEN($SDELIMITER))
		$ICOUNT += 1
	ELSE
		LOCAL $ITEMP
		FOR $I = $ISTART TO $ISIZE - 1
			$ITEMP = $AIDX[$I]
			$AIDX[$I] = $AIDX[$ISTART]
			$AIDX[$ISTART] = $ITEMP
			__ARRAY_EXETERINTERNAL($AARRAY, $ISTART + 1, $ISIZE, $SDELIMITER, $AIDX, $ARESULT, $ICOUNT)
			$AIDX[$ISTART] = $AIDX[$I]
			$AIDX[$I] = $ITEMP
		NEXT
	ENDIF
ENDFUNC
FUNC __ARRAY_COMBINATIONS($IN, $IR)
	LOCAL $I_TOTAL = 1
	FOR $I = $IR TO 1 STEP -1
		$I_TOTAL *= ($IN / $I)
		$IN -= 1
	NEXT
	RETURN ROUND($I_TOTAL)
ENDFUNC
FUNC __ARRAY_GETNEXT($IN, $IR, BYREF $ILEFT, $ITOTAL, BYREF $AIDX)
	IF $ILEFT == $ITOTAL THEN
		$ILEFT -= 1
		RETURN
	ENDIF
	LOCAL $I = $IR - 1
	WHILE $AIDX[$I] == $IN - $IR + $I
		$I -= 1
	WEND
	$AIDX[$I] += 1
	FOR $J = $I + 1 TO $IR - 1
		$AIDX[$J] = $AIDX[$I] + $J - $I
	NEXT
	$ILEFT -= 1
ENDFUNC
FUNC __ARRAY_MINMAXINDEX(CONST BYREF $AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM, $FUCOMPARISON)
	IF $ICOMPNUMERIC = DEFAULT THEN $ICOMPNUMERIC = 0
	IF $ICOMPNUMERIC <> 1 THEN $ICOMPNUMERIC = 0
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF $IDIM_1 < 0 THEN RETURN SETERROR(1, 0, -1)
	IF $IEND = -1 THEN $IEND = $IDIM_1
	IF $ISTART = -1 THEN $ISTART = 0
	IF $ISTART < -1 OR $IEND < -1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART > $IDIM_1 OR $IEND > $IDIM_1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	IF $IDIM_1 < 0 THEN RETURN SETERROR(5, 0, -1)
	LOCAL $IMAXMININDEX = $ISTART
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $ICOMPNUMERIC THEN
				FOR $I = $ISTART TO $IEND
					IF $FUCOMPARISON(NUMBER($AARRAY[$I]), NUMBER($AARRAY[$IMAXMININDEX])) THEN $IMAXMININDEX = $I
				NEXT
			ELSE
				FOR $I = $ISTART TO $IEND
					IF $FUCOMPARISON($AARRAY[$I], $AARRAY[$IMAXMININDEX]) THEN $IMAXMININDEX = $I
				NEXT
			ENDIF
		CASE 2
			IF $ISUBITEM < 0 OR $ISUBITEM > UBOUND($AARRAY, $UBOUND_COLUMNS) - 1 THEN RETURN SETERROR(6, 0, -1)
			IF $ICOMPNUMERIC THEN
				FOR $I = $ISTART TO $IEND
					IF $FUCOMPARISON(NUMBER($AARRAY[$I][$ISUBITEM]), NUMBER($AARRAY[$IMAXMININDEX][$ISUBITEM])) THEN $IMAXMININDEX = $I
				NEXT
			ELSE
				FOR $I = $ISTART TO $IEND
					IF $FUCOMPARISON($AARRAY[$I][$ISUBITEM], $AARRAY[$IMAXMININDEX][$ISUBITEM]) THEN $IMAXMININDEX = $I
				NEXT
			ENDIF
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN $IMAXMININDEX
ENDFUNC
FUNC __ARRAY_GREATERTHAN($VVALUE1, $VVALUE2)
	RETURN $VVALUE1 > $VVALUE2
ENDFUNC
FUNC __ARRAY_LESSTHAN($VVALUE1, $VVALUE2)
	RETURN $VVALUE1 < $VVALUE2
ENDFUNC
FUNC __ARRAYUNIQUE_AUTOERRFUNC()
ENDFUNC
#Region ### START Koda GUI section ### Form=e:\ctf\ctf_challenge\kcscctf-2022\flag checker\flagchecker.kxf
	$BGUI = GUICREATE("Flag Checker", 314, 136, 192, 124)
	$IFLAG = GUICTRLCREATEINPUT("", 80, 65, 201, 21)
	GUICTRLCREATELABEL("FLAG CHECKER", 96, 16, 136, 27)
	GUICTRLSETFONT(-1, 15, 800, 0, "Consolas")
	GUICTRLCREATELABEL("Enter flag: ", 22, 68, 55, 17)
	$BNTCHECK = GUICTRLCREATEBUTTON("Check", 112, 99, 75, 25)
	GUISETSTATE(@SW_SHOW)
#EndRegion ### END Koda GUI section ###
WHILE 1
	$NMSG = GUIGETMSG()
	SWITCH $NMSG
		CASE $GUI_EVENT_CLOSE
			EXIT
		CASE $BNTCHECK
			CHECKER()
			SLEEP(100)
	ENDSWITCH
WEND
FUNC CHECKER()
	LOCAL $INPUT = GUICTRLREAD($IFLAG)
	LOCAL $LEN_INPUT = STRINGLEN($INPUT)
	LOCAL $OPCODE = "0x558bec83ec6c8d45d850e8aa05000083c4048d4d94518d55d8" & "52e8cb03000083c408e80c0000007573657233322e646c6c00" & "00ff55d88945f8837df8007505e9fb000000e80c0000004d65" & "7373616765426f7841008b45f850e8b306000083c4088945f0" & "8b4d0851ff55e883f81c740b8b550cc60200e9c4000000c645" & "bcf8c645bd50c645beccc645bfefc645c0e6c645c13cc645c2" & "35c645c396c645c41dc645c561c645c6aec645c7c0c645c8c5" & "c645c931c645cacec645cbb0c645cce7c645cd1dc645ceedc6" & "45cfbcc645d05dc645d181c645d269c645d38ac645d435c645" & "d574c645d657c645d7b68b4508508d4d94518d55d852e84700" & "000083c40c8945f4c745fc00000000eb098b45fc83c0018945" & "fc837dfc1c7d1f8b4df4034dfc0fb6118b45fc0fb64c05bc3b" & "d174088b550cc60200eb08ebd28b450cc600018be55dc3558b" & "ec83ec445657b90b000000e82c00000068747470733a2f2f77" & "77772e796f75747562652e636f6d2f77617463683f763d6451" & "773477395767586351005e8d7dbcf3a5c745f800000000c745" & "f400000000c745fc000000008b4510508b4d088b5110ffd289" & "45ec6a006a016a006a008d45f8508b4d0c8b11ffd285c07507" & "33c0e91b0200008d45f4506a006a0068048000008b4df8518b" & "550c8b420cffd085c075156a008b4df8518b550c8b4224ffd0" & "33c0e9e9010000837df40075156a008b4df8518b550c8b4224" & "ffd033c0e9ce0100006a008d4dbc518b55088b4210ffd0508d" & "4dbc518b55f4528b450c8b4808ffd185c075218b55f4528b45" & "0c8b481cffd16a008b55f8528b450c8b4824ffd133c0e98a01" & "00008d55fc526a008b45f45068016800008b4df8518b550c8b" & "4214ffd085c075218b4df4518b550c8b421cffd06a008b4df8" & "518b550c8b4224ffd033c0e94a0100008b4df4518b550c8b42" & "1cffd06a008d4dec516a006a006a016a008b55fc528b450c8b" & "4810ffd185c07527837dfc0074218b55fc528b450c8b4820ff" & "d16a008b55f8528b450c8b4824ffd133c0e9f90000006a0468" & "001000008b55ec83c201526a008b45088b4808ffd18945e883" & "7de8007527837dfc0074218b55fc528b450c8b4820ffd16a00" & "8b55f8528b450c8b4824ffd133c0e9b10000008b55ec83c201" & "528b45e850e8cc06000083c408c745f000000000eb098b4df0" & "83c101894df08b55f03b55ec73128b45e80345f08b4d10034d" & "f08a118810ebdd8b4510508b4d088b5110ffd2508d45ec508b" & "4de8516a006a016a008b55fc528b450c8b4810ffd185c07524" & "837dfc00741e8b55fc528b450c8b4820ffd16a008b55f8528b" & "450c8b4824ffd133c0eb23837dfc00741a8b55fc528b450c8b" & "4820ffd16a008b55f8528b450c8b4824ffd18b45e85f5e8be5" & "5dc3558bec51e81000000061647661706933322e646c6c0000" & "00008b45088b08ffd18945fc837dfc00750732c0e99b010000" & "e818000000437279707441637175697265436f6e7465787441" & "000000008b55fc52e8d102000083c4088b4d0c8901e8100000" & "00437279707443726561746548617368008b55fc52e8ab0200" & "0083c4088b4d0c89410ce8100000004372797074496d706f72" & "744b657900008b55fc52e88402000083c4088b4d0c894104e8" & "1000000043727970744465726976654b657900008b55fc52e8" & "5d02000083c4088b4d0c894114e81000000043727970744861" & "7368446174610000008b55fc52e83602000083c4088b4d0c89" & "4108e8100000004372797074456e6372797074000000008b55" & "fc52e80f02000083c4088b4d0c894110e81400000043727970" & "7447657448617368506172616d0000008b55fc52e8e4010000" & "83c4088b4d0c894118e814000000437279707444657374726f" & "7948617368000000008b55fc52e8b901000083c4088b4d0c89" & "411ce810000000437279707444657374726f794b6579008b55" & "fc52e89201000083c4088b4d0c894120e81400000043727970" & "7452656c65617365436f6e74657874008b55fc52e867010000" & "83c4088b4d0c894124b0018be55dc3558bec83ec18e81c0000" & "006b00650072006e0065006c00330032002e0064006c006c00" & "00000000e88602000083c4048945fc837dfc00750732c0e915" & "010000e8100000004c6f61644c69627261727941000000008b" & "45fc50e8fb00000083c4088945f8837df800750732c0e9e400" & "0000e81000000047657450726f634164647265737300008b4d" & "fc51e8ca00000083c4088945f4837df400750732c0e9b30000" & "00e8100000005669727475616c416c6c6f63000000008b55fc" & "52e89900000083c4088945f0837df000750732c0e982000000" & "e80c0000005669727475616c46726565008b45fc50e86c0000" & "0083c4088945ec837dec00750432c0eb58e80c0000006c7374" & "726c656e41000000008b4dfc51e84200000083c4088945e883" & "7de800750432c0eb2e8b55088b45f889028b4d088b55f48951" & "048b45088b4df08948088b55088b45ec89420c8b4d088b55e8" & "895110b0018be55dc3558bec83ec3c8b45088945ec8b4dec0f" & "b71181fa4d5a0000740733c0e9350100008b45ec8b4d080348" & "3c894de4ba080000006bc2008b4de48d5401788955e88b45e8" & "833800750733c0e9080100008b4de88b118955e08b45e00345" & "088945f48b4df48b51188955dc8b45f48b481c894dd08b55f4" & "8b42208945d88b4df48b51248955d4c745f800000000eb098b" & "45f883c0018945f88b4df83b4ddc0f83b30000008b55080355" & "d88b45f88d0c82894dc88b55080355d48b45f88d0c42894dcc" & "8b55080355d08b45cc0fb7088d148a8955c48b45c88b4d0803" & "08894df0c745fc00000000c745fc00000000eb098b55fc83c2" & "018955fc8b450c0345fc0fbe0885c974278b55f00355fc0fbe" & "0285c0741a8b4d0c034dfc0fbe118b45f00345fc0fbe083bd1" & "7402eb02ebc38b550c0355fc0fbe0285c075198b4df0034dfc" & "0fbe1185d2750c8b45c48b4d0803088bc1eb07e938ffffff33" & "c08be55dc3558bec83ec34c745e40000000064a13000000089" & "45e48b4de48b510c8955d88b45d88b480c8b5010894dcc8955" & "d08b45cc8945d48b4dd4894de8837de8000f845a0100008b55" & "e8837a18000f844d0100008b45e8837830007502ebde8b4de8" & "8b51308955ecc745f000000000c745f000000000eb098b45f0" & "83c0018945f08b4df08b55080fb7044a85c00f84dd0000008b" & "4df08b55ec0fb7044a85c00f84cb0000008b4df08b55080fb7" & "044a83f85a7f378b4df08b55080fb7044a83f8417c288b4df0" & "8b55080fb7044a83c0208945e08b4df08b5508668b45e06689" & "044a668b4de066894dfeeb0e8b55f08b4508668b0c5066894d" & "fe668b55fe668955f88b45f08b4dec0fb7144183fa5a7f378b" & "45f08b4dec0fb7144183fa417c288b45f08b4dec0fb7144183" & "c2208955dc8b45f08b4dec668b55dc66891441668b45dc6689" & "45fceb0e8b4df08b55ec668b044a668945fc668b4dfc66894d" & "f40fb755f80fb745f43bd07402eb05e908ffffff8b4df08b55" & "080fb7044a85c075168b4df08b55ec0fb7044a85c075088b4d" & "e88b4118eb0f8b55e88b028945e8e99cfeffff33c08be55dc3" & "558bec518b45088945fc837d0c00741a8b4dfcc601008b55fc" & "83c2018955fc8b450c83e80189450cebe08b45088be55dc300" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000"
	LOCAL $OPCODE_BUF = DLLSTRUCTCREATE("byte[" & BINARYLEN($OPCODE) & "]")
	DLLSTRUCTSETDATA($OPCODE_BUF, 1, BINARY($OPCODE))
	LOCAL $INPUT_BUF = DLLSTRUCTCREATE("byte[" & BINARYLEN($INPUT) + 1 & "]")
	DLLSTRUCTSETDATA($INPUT_BUF, 1, BINARY($INPUT))
	LOCAL $IS_FLAG = DLLSTRUCTCREATE("byte[1]")
	DLLSTRUCTSETDATA($IS_FLAG, 1, BINARY("0x00"))
	DLLCALL("user32.dll", "none", "CallWindowProcA", "ptr", DLLSTRUCTGETPTR($OPCODE_BUF), "ptr", DLLSTRUCTGETPTR($INPUT_BUF), "ptr", DLLSTRUCTGETPTR($IS_FLAG), "int", 0, "int", 0)
	IF DLLSTRUCTGETDATA($IS_FLAG, 1) == "0x01" THEN
		MSGBOX(0, "", "Correct!")
	ELSE
		MSGBOX($MB_ICONERROR, "", "Incorrect!")
	ENDIF
ENDFUNC
; DeTokenise by myAut2Exe >The Open Source AutoIT/AutoHotKey script decompiler< 2.15 build(212)